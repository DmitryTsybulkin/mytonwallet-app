/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/api/blockchains/index.ts":
/*!**************************************!*\
  !*** ./src/api/blockchains/index.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _ton__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ton */ \"./src/api/blockchains/ton/index.ts\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  ton: _ton__WEBPACK_IMPORTED_MODULE_0__\n});\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/blockchains/index.ts?");

/***/ }),

/***/ "./src/api/blockchains/ton/address.ts":
/*!********************************************!*\
  !*** ./src/api/blockchains/ton/address.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"normalizeAddress\": () => (/* binding */ normalizeAddress),\n/* harmony export */   \"resolveAddress\": () => (/* binding */ resolveAddress)\n/* harmony export */ });\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ton/core */ \"./node_modules/@ton/core/dist/index.js\");\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ton_core__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _util_dns__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/dns */ \"./src/util/dns.ts\");\n/* harmony import */ var _util_dns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/dns */ \"./src/api/blockchains/ton/util/dns.ts\");\n/* harmony import */ var _util_tonCore__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/tonCore */ \"./src/api/blockchains/ton/util/tonCore.ts\");\n\n\n\n\nconst TON_DNS_COLLECTION = 'EQC3dNlesgVD8YbAazcauIrXBPfiVhMMr5YYk2in0Mtsz0Bz';\nconst VIP_DNS_COLLECTION = 'EQBWG4EBbPDv4Xj7xlPwzxd7hSyHMzwwLB5O6rY-0BBeaixS';\nasync function resolveAddress(network, address) {\n  if (!_util_dns__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isDnsDomain(address)) {\n    return {\n      address\n    };\n  }\n  const domain = address;\n  try {\n    let base;\n    let collection;\n    if (_util_dns__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isVipDnsDomain(domain)) {\n      base = _util_dns__WEBPACK_IMPORTED_MODULE_1__[\"default\"].removeVipZone(domain);\n      collection = VIP_DNS_COLLECTION;\n    } else {\n      base = _util_dns__WEBPACK_IMPORTED_MODULE_1__[\"default\"].removeTonZone(domain);\n      collection = TON_DNS_COLLECTION;\n    }\n    const result = await (0,_util_dns__WEBPACK_IMPORTED_MODULE_2__.dnsResolve)((0,_util_tonCore__WEBPACK_IMPORTED_MODULE_3__.getTonClient)(network), collection, base, _util_dns__WEBPACK_IMPORTED_MODULE_2__.DnsCategory.Wallet);\n    if (!(result instanceof _ton_core__WEBPACK_IMPORTED_MODULE_0__.Address)) {\n      return undefined;\n    }\n    return {\n      address: (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_3__.toBase64Address)(result, undefined, network),\n      domain\n    };\n  } catch (err) {\n    if (err.message !== 'http provider parse response error') {\n      throw err;\n    }\n    return undefined;\n  }\n}\nfunction normalizeAddress(address, network) {\n  return (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_3__.toBase64Address)(address, true, network);\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/blockchains/ton/address.ts?");

/***/ }),

/***/ "./src/api/blockchains/ton/auth.ts":
/*!*****************************************!*\
  !*** ./src/api/blockchains/ton/auth.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"decryptMnemonic\": () => (/* binding */ decryptMnemonic),\n/* harmony export */   \"encryptMnemonic\": () => (/* binding */ encryptMnemonic),\n/* harmony export */   \"fetchKeyPair\": () => (/* binding */ fetchKeyPair),\n/* harmony export */   \"fetchMnemonic\": () => (/* binding */ fetchMnemonic),\n/* harmony export */   \"fetchPrivateKey\": () => (/* binding */ fetchPrivateKey),\n/* harmony export */   \"generateMnemonic\": () => (/* binding */ generateMnemonic),\n/* harmony export */   \"mnemonicToSeed\": () => (/* binding */ mnemonicToSeed),\n/* harmony export */   \"rawSign\": () => (/* binding */ rawSign),\n/* harmony export */   \"seedToKeyPair\": () => (/* binding */ seedToKeyPair),\n/* harmony export */   \"validateMnemonic\": () => (/* binding */ validateMnemonic),\n/* harmony export */   \"verifyPassword\": () => (/* binding */ verifyPassword)\n/* harmony export */ });\n/* harmony import */ var tonweb_mnemonic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tonweb-mnemonic */ \"./node_modules/tonweb-mnemonic/dist/web/index.js\");\n/* harmony import */ var tonweb_mnemonic__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tonweb_mnemonic__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var tweetnacl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tweetnacl */ \"./node_modules/tweetnacl/nacl-fast.js\");\n/* harmony import */ var tweetnacl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(tweetnacl__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../types */ \"./src/api/types/index.ts\");\n/* harmony import */ var _util_logs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../util/logs */ \"./src/util/logs.ts\");\n/* harmony import */ var _common_accounts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/accounts */ \"./src/api/common/accounts.ts\");\n/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/utils */ \"./src/api/common/utils.ts\");\n\n\n\n\n\n\nconst PBKDF2_IMPORT_KEY_ARGS = [{\n  name: 'PBKDF2'\n}, false, ['deriveBits', 'deriveKey']];\nconst PBKDF2_DERIVE_KEY_ARGS = {\n  name: 'PBKDF2',\n  iterations: 100000,\n  // Higher is more secure but slower\n  hash: 'SHA-256'\n};\nconst PBKDF2_DERIVE_KEY_TYPE = {\n  name: 'AES-GCM',\n  length: 256\n};\nfunction generateMnemonic() {\n  return tonweb_mnemonic__WEBPACK_IMPORTED_MODULE_0__.generateMnemonic();\n}\nfunction validateMnemonic(mnemonic) {\n  return tonweb_mnemonic__WEBPACK_IMPORTED_MODULE_0__.validateMnemonic(mnemonic);\n}\nasync function mnemonicToSeed(mnemonic) {\n  const keyPair = await tonweb_mnemonic__WEBPACK_IMPORTED_MODULE_0__.mnemonicToKeyPair(mnemonic);\n  return (0,_common_utils__WEBPACK_IMPORTED_MODULE_5__.bytesToBase64)(keyPair.secretKey.slice(0, 32));\n}\nfunction seedToKeyPair(seed) {\n  return tweetnacl__WEBPACK_IMPORTED_MODULE_1___default().sign.keyPair.fromSeed((0,_common_utils__WEBPACK_IMPORTED_MODULE_5__.base64ToBytes)(seed));\n}\nasync function encryptMnemonic(mnemonic, password) {\n  const plaintext = mnemonic.join(',');\n  const salt = crypto.getRandomValues(new Uint8Array(16)); // generate a 128-bit salt\n  const keyMaterial = await crypto.subtle.importKey('raw', new TextEncoder().encode(password), ...PBKDF2_IMPORT_KEY_ARGS);\n  const key = await crypto.subtle.deriveKey({\n    salt,\n    ...PBKDF2_DERIVE_KEY_ARGS\n  }, keyMaterial, PBKDF2_DERIVE_KEY_TYPE, false, ['encrypt']);\n  const iv = crypto.getRandomValues(new Uint8Array(12)); // get 96-bit random iv\n  const ptUint8 = new TextEncoder().encode(plaintext); // encode plaintext as UTF-8\n  const ctBuffer = await crypto.subtle.encrypt({\n    name: 'AES-GCM',\n    iv\n  }, key, ptUint8); // encrypt plaintext using key\n  const ctArray = Array.from(new Uint8Array(ctBuffer)); // ciphertext as byte array\n  const ctBase64 = btoa(String.fromCharCode(...ctArray)); // encode ciphertext as base64\n  const ivHex = Array.from(iv).map(b => `00${b.toString(16)}`.slice(-2)).join(''); // iv as hex string\n  const saltHex = Array.from(salt).map(b => `00${b.toString(16)}`.slice(-2)).join(''); // salt as hex string\n\n  return `${saltHex}:${ivHex}:${ctBase64}`;\n}\nasync function decryptMnemonic(encrypted, password) {\n  if (!encrypted.includes(':')) {\n    return decryptMnemonicLegacy(encrypted, password);\n  }\n  const [saltHex, ivHex, encryptedData] = encrypted.split(':');\n  const salt = new Uint8Array(saltHex.match(/.{2}/g).map(b => parseInt(b, 16)));\n  const iv = new Uint8Array(ivHex.match(/.{2}/g).map(b => parseInt(b, 16)));\n  const keyMaterial = await crypto.subtle.importKey('raw', new TextEncoder().encode(password), ...PBKDF2_IMPORT_KEY_ARGS);\n  const key = await crypto.subtle.deriveKey({\n    salt,\n    ...PBKDF2_DERIVE_KEY_ARGS\n  }, keyMaterial, PBKDF2_DERIVE_KEY_TYPE, false, ['decrypt']);\n  const ctStr = atob(encryptedData); // decode base64 ciphertext\n  const ctUint8 = new Uint8Array(ctStr.match(/[\\s\\S]/g).map(ch => ch.charCodeAt(0))); // ciphertext as Uint8Array\n  const plainBuffer = await crypto.subtle.decrypt({\n    name: 'AES-GCM',\n    iv\n  }, key, ctUint8); // decrypt ciphertext using key\n  const plaintext = new TextDecoder().decode(plainBuffer); // decode password from UTF-8\n\n  return plaintext.split(',');\n}\nasync function decryptMnemonicLegacy(encrypted, password) {\n  const pwUtf8 = new TextEncoder().encode(password); // encode password as UTF-8\n  const pwHash = await crypto.subtle.digest('SHA-256', pwUtf8); // hash the password\n  const iv = encrypted.slice(0, 24).match(/.{2}/g).map(byte => parseInt(byte, 16)); // get iv from ciphertext\n  const alg = {\n    name: 'AES-GCM',\n    iv: new Uint8Array(iv)\n  }; // specify algorithm to use\n  const key = await crypto.subtle.importKey('raw', pwHash, alg, false, ['decrypt']); // use pw to generate key\n  const ctStr = atob(encrypted.slice(24)); // decode base64 ciphertext\n  const ctUint8 = new Uint8Array(ctStr.match(/[\\s\\S]/g).map(ch => ch.charCodeAt(0))); // ciphertext as Uint8Array\n  const plainBuffer = await crypto.subtle.decrypt(alg, key, ctUint8); // decrypt ciphertext using key\n  const plaintext = new TextDecoder().decode(plainBuffer); // decode password from UTF-8\n\n  return plaintext.split(',');\n}\nasync function fetchMnemonic(accountId, password) {\n  try {\n    const mnemonicEncrypted = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_4__.getAccountValue)(accountId, 'mnemonicsEncrypted');\n    const mnemonic = await decryptMnemonic(mnemonicEncrypted, password);\n    if (!mnemonicEncrypted.includes(':')) {\n      await tryMigratingMnemonicEncryption(accountId, mnemonic, password);\n    }\n    return mnemonic;\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.error(err);\n    return undefined;\n  }\n}\nasync function tryMigratingMnemonicEncryption(accountId, mnemonic, password) {\n  try {\n    const mnemonicEncrypted = await encryptMnemonic(mnemonic, password);\n\n    // This is a defensive approach against potential corrupted encryption reported by some users\n    const decryptedMnemonic = await decryptMnemonic(mnemonicEncrypted, password).catch(() => undefined);\n    if (!password || !decryptedMnemonic) {\n      return {\n        error: _types__WEBPACK_IMPORTED_MODULE_2__.ApiCommonError.DebugError\n      };\n    }\n    await Promise.all([(0,_common_accounts__WEBPACK_IMPORTED_MODULE_4__.setAccountValue)(accountId, 'mnemonicsEncrypted', mnemonicEncrypted)]);\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.error(err);\n  }\n  return undefined;\n}\nasync function fetchPrivateKey(accountId, password) {\n  try {\n    const mnemonic = await fetchMnemonic(accountId, password);\n    if (!mnemonic) {\n      return undefined;\n    }\n    const seedBase64 = await mnemonicToSeed(mnemonic);\n    const {\n      secretKey: privateKey\n    } = seedToKeyPair(seedBase64);\n    return privateKey;\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.error(err);\n    return undefined;\n  }\n}\nasync function fetchKeyPair(accountId, password) {\n  try {\n    const mnemonic = await fetchMnemonic(accountId, password);\n    if (!mnemonic) {\n      return undefined;\n    }\n    return await tonweb_mnemonic__WEBPACK_IMPORTED_MODULE_0__.mnemonicToKeyPair(mnemonic);\n  } catch (err) {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_3__.logDebugError)('fetchKeyPair', err);\n    return undefined;\n  }\n}\nasync function rawSign(accountId, password, dataHex) {\n  const privateKey = await fetchPrivateKey(accountId, password);\n  if (!privateKey) {\n    return undefined;\n  }\n  const signature = tweetnacl__WEBPACK_IMPORTED_MODULE_1___default().sign.detached((0,_common_utils__WEBPACK_IMPORTED_MODULE_5__.hexToBytes)(dataHex), privateKey);\n  return (0,_common_utils__WEBPACK_IMPORTED_MODULE_5__.bytesToHex)(signature);\n}\nasync function verifyPassword(accountId, password) {\n  const mnemonic = await fetchMnemonic(accountId, password);\n  return Boolean(mnemonic);\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/blockchains/ton/auth.ts?");

/***/ }),

/***/ "./src/api/blockchains/ton/constants.ts":
/*!**********************************************!*\
  !*** ./src/api/blockchains/ton/constants.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ALL_WALLET_VERSIONS\": () => (/* binding */ ALL_WALLET_VERSIONS),\n/* harmony export */   \"ATTEMPTS\": () => (/* binding */ ATTEMPTS),\n/* harmony export */   \"ContractType\": () => (/* binding */ ContractType),\n/* harmony export */   \"DEFAULT_DECIMALS\": () => (/* binding */ DEFAULT_DECIMALS),\n/* harmony export */   \"DEFAULT_IS_BOUNCEABLE\": () => (/* binding */ DEFAULT_IS_BOUNCEABLE),\n/* harmony export */   \"FEE_FACTOR\": () => (/* binding */ FEE_FACTOR),\n/* harmony export */   \"JettonOpCode\": () => (/* binding */ JettonOpCode),\n/* harmony export */   \"KnownContracts\": () => (/* binding */ KnownContracts),\n/* harmony export */   \"LEDGER_SUPPORTED_PAYLOADS\": () => (/* binding */ LEDGER_SUPPORTED_PAYLOADS),\n/* harmony export */   \"LiquidStakingOpCode\": () => (/* binding */ LiquidStakingOpCode),\n/* harmony export */   \"NftOpCode\": () => (/* binding */ NftOpCode),\n/* harmony export */   \"OpCode\": () => (/* binding */ OpCode),\n/* harmony export */   \"STAKE_COMMENT\": () => (/* binding */ STAKE_COMMENT),\n/* harmony export */   \"TOKEN_TRANSFER_TON_AMOUNT\": () => (/* binding */ TOKEN_TRANSFER_TON_AMOUNT),\n/* harmony export */   \"TOKEN_TRANSFER_TON_FORWARD_AMOUNT\": () => (/* binding */ TOKEN_TRANSFER_TON_FORWARD_AMOUNT),\n/* harmony export */   \"UNSTAKE_COMMENT\": () => (/* binding */ UNSTAKE_COMMENT),\n/* harmony export */   \"WALLET_IS_BOUNCEABLE\": () => (/* binding */ WALLET_IS_BOUNCEABLE)\n/* harmony export */ });\nconst TOKEN_TRANSFER_TON_AMOUNT = 100000000n; // 0.1 TON\nconst TOKEN_TRANSFER_TON_FORWARD_AMOUNT = 1n; // 0.000000001 TON\n\nconst STAKE_COMMENT = 'd';\nconst UNSTAKE_COMMENT = 'w';\nconst ATTEMPTS = 5;\nconst DEFAULT_DECIMALS = 9;\nconst DEFAULT_IS_BOUNCEABLE = true;\nconst WALLET_IS_BOUNCEABLE = false;\n\n// Fee may change, so we add 5% for more reliability. This is only safe for low-fee blockchains such as TON.\nconst FEE_FACTOR = 1.05;\nconst LEDGER_SUPPORTED_PAYLOADS = ['nft:transfer', 'tokens:transfer', 'comment'];\nconst ALL_WALLET_VERSIONS = ['simpleR1', 'simpleR2', 'simpleR3', 'v2R1', 'v2R2', 'v3R1', 'v3R2', 'v4R2'];\nlet OpCode = /*#__PURE__*/function (OpCode) {\n  OpCode[OpCode[\"Comment\"] = 0] = \"Comment\";\n  OpCode[OpCode[\"Encrypted\"] = 560454219] = \"Encrypted\";\n  return OpCode;\n}({});\nlet JettonOpCode = /*#__PURE__*/function (JettonOpCode) {\n  JettonOpCode[JettonOpCode[\"Transfer\"] = 260734629] = \"Transfer\";\n  JettonOpCode[JettonOpCode[\"TransferNotification\"] = 1935855772] = \"TransferNotification\";\n  JettonOpCode[JettonOpCode[\"InternalTransfer\"] = 395134233] = \"InternalTransfer\";\n  JettonOpCode[JettonOpCode[\"Excesses\"] = 3576854235] = \"Excesses\";\n  JettonOpCode[JettonOpCode[\"Burn\"] = 1499400124] = \"Burn\";\n  JettonOpCode[JettonOpCode[\"BurnNotification\"] = 2078119902] = \"BurnNotification\";\n  return JettonOpCode;\n}({});\nlet NftOpCode = /*#__PURE__*/function (NftOpCode) {\n  NftOpCode[NftOpCode[\"TransferOwnership\"] = 1607220500] = \"TransferOwnership\";\n  return NftOpCode;\n}({});\nlet LiquidStakingOpCode = /*#__PURE__*/function (LiquidStakingOpCode) {\n  LiquidStakingOpCode[LiquidStakingOpCode[\"RequestLoan\"] = 3863136613] = \"RequestLoan\";\n  LiquidStakingOpCode[LiquidStakingOpCode[\"LoanRepayment\"] = 3755778683] = \"LoanRepayment\";\n  LiquidStakingOpCode[LiquidStakingOpCode[\"Deposit\"] = 1205158801] = \"Deposit\";\n  LiquidStakingOpCode[LiquidStakingOpCode[\"Withdraw\"] = 832244956] = \"Withdraw\";\n  LiquidStakingOpCode[LiquidStakingOpCode[\"Withdrawal\"] = 175592284] = \"Withdrawal\";\n  LiquidStakingOpCode[LiquidStakingOpCode[\"DeployController\"] = 2994658477] = \"DeployController\";\n  LiquidStakingOpCode[LiquidStakingOpCode[\"Touch\"] = 1271382751] = \"Touch\";\n  LiquidStakingOpCode[LiquidStakingOpCode[\"Donate\"] = 1940913697] = \"Donate\";\n  LiquidStakingOpCode[LiquidStakingOpCode[\"DistributedAsset\"] = 3678112445] = \"DistributedAsset\";\n  return LiquidStakingOpCode;\n}({});\nlet ContractType = /*#__PURE__*/function (ContractType) {\n  ContractType[\"Wallet\"] = \"wallet\";\n  ContractType[\"Staking\"] = \"staking\";\n  return ContractType;\n}({});\nconst KnownContracts = {\n  simpleR1: {\n    name: 'simpleR1',\n    hash: '3232dc55b02b3d2a9485adc151cf29c50b94c374d3571cb59390d761b87af8bd',\n    type: ContractType.Wallet,\n    isLedgerAllowed: true\n  },\n  simpleR2: {\n    name: 'simpleR2',\n    hash: '672ce2b01d2fd487a5e0528611e7e4fc11867148cc13ff772bd773b72fb368df',\n    type: ContractType.Wallet,\n    isLedgerAllowed: true\n  },\n  simpleR3: {\n    name: 'simpleR3',\n    hash: 'd95417233f66ae218317f533630cbbddc677d6d893d5722be6947c8fad8e9d52',\n    type: ContractType.Wallet,\n    isLedgerAllowed: true\n  },\n  v2R1: {\n    name: 'v2R1',\n    hash: 'fb3bd539b7e50166f1cfdc0bbd298b1c88f6b261fe5ee61343ea47ab4b256029',\n    type: ContractType.Wallet,\n    isLedgerAllowed: true\n  },\n  v2R2: {\n    name: 'v2R2',\n    hash: 'b584b6106753b7f34709df505be603e463a44ff6a85adf7fec4e26453c325983',\n    type: ContractType.Wallet,\n    isLedgerAllowed: true\n  },\n  v3R1: {\n    name: 'v3R1',\n    hash: '11d123ed5c2055128e75a9ef4cf1e837e6d14a9c079c39939885c78dc13626e6',\n    type: ContractType.Wallet,\n    isLedgerAllowed: true\n  },\n  v3R2: {\n    name: 'v3R2',\n    hash: 'df7bf014ee7ac0c38da19ef1b7fa054e2cc7a4513df1f1aa295109cf3606ac14',\n    type: ContractType.Wallet,\n    isLedgerAllowed: true\n  },\n  v4R1: {\n    name: 'v4R1',\n    hash: '1bc0dfa40956c911616f8a5db09ecc217601bae48d7d3f9311562c5afcb66dcf',\n    type: ContractType.Wallet,\n    isLedgerAllowed: true\n  },\n  v4R2: {\n    name: 'v4R2',\n    hash: '5659ce2300f4a09a37b0bdee41246ded52474f032c1d6ffce0d7d31b18b7b2b1',\n    type: ContractType.Wallet,\n    isLedgerAllowed: true\n  },\n  highloadV2: {\n    name: 'highloadV2',\n    hash: 'fcd7d1f3b3847f0b9bd44bc64a2256c03450979dd1646a24fbc874b075392d6e',\n    type: ContractType.Wallet,\n    isLedgerAllowed: true\n  },\n  nominatorPool: {\n    name: 'nominatorPool',\n    hash: 'bffbc2310c6c535fe7271667fd3352a1151d097905c052701c5c98bf45487f08',\n    type: ContractType.Staking,\n    isLedgerAllowed: true\n  },\n  multisig: {\n    name: 'multisig',\n    hash: '45d890485cdd6b152bcbbe3fb2e16d2df82f6da840440a5b9f34ea13cb0b92d2',\n    type: ContractType.Wallet,\n    isLedgerAllowed: true\n  },\n  multisigV2: {\n    name: 'multisigV2',\n    hash: 'eb1323c5544d5bf26248dc427d108d722d5c2922dd97dd0bdf903c4cea73ca97',\n    type: ContractType.Wallet,\n    isLedgerAllowed: true\n  },\n  vesting: {\n    name: 'vesting',\n    hash: '69dc931958f7aa203c4a7bfcf263d25d2d828d573184b542a65dd55c8398ad83',\n    type: ContractType.Wallet,\n    isLedgerAllowed: true\n  },\n  dedustPool: {\n    name: 'dedustPool',\n    hash: 'af6a1790ccd322e9b996733cce5618901a99d76c4c5a219309deef9b0910b238',\n    isSwapAllowed: true\n  },\n  dedustVaultNative: {\n    name: 'dedustVaultNative',\n    hash: '8ecbfbe7642ebceec39712a4b3e7b3d1ffc2cfbb1b712fbf1f27f1051afb5220',\n    isSwapAllowed: true\n  },\n  dedustVaultNative2: {\n    name: 'dedustVaultNative2',\n    hash: '546ea179831fd6bda3d7515f07a5322486ae4ea4685125e6034758b8cca5b917',\n    isSwapAllowed: true\n  },\n  dedustVaultJetton: {\n    name: 'dedustVaultJetton',\n    hash: '54f0c2a249ea3c5fc844c48e2586d8a72e6fc188a1ccaec609fac58248b8c8e3',\n    isSwapAllowed: true\n  },\n  stonPtonWallet: {\n    name: 'stonPtonWallet',\n    hash: '6ccbf71a3ed9c7355f84a698a44a7406574bfb8aa34d4bbd86ab75ee9c994880',\n    isSwapAllowed: true\n  },\n  stonRouter: {\n    name: 'stonRouter',\n    hash: '14ce618a0e9a94adc99fa6e975219ddd675425b30dfa9728f98714c8dc55f9da',\n    isSwapAllowed: true\n  },\n  megatonWtonMaster: {\n    name: 'megatonWtonMaster',\n    hash: '4c9790d808ea4470614e021f76c40529efe2fbce8138da4284a29b5f1943ef19',\n    isSwapAllowed: true\n  },\n  megatonRouter: {\n    name: 'megatonRouter',\n    hash: '5d5f0e3ed9602d1ba96006ead98cb5e9b53f49ce4a5cf675e06e4d440b7d267c',\n    isSwapAllowed: true\n  }\n};\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/blockchains/ton/constants.ts?");

/***/ }),

/***/ "./src/api/blockchains/ton/contracts/JettonConstants.ts":
/*!**************************************************************!*\
  !*** ./src/api/blockchains/ton/contracts/JettonConstants.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Errors\": () => (/* binding */ Errors),\n/* harmony export */   \"Op\": () => (/* binding */ Op)\n/* harmony export */ });\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// eslint-disable-next-line max-classes-per-file\nclass Op {}\n_defineProperty(Op, \"transfer\", 0xf8a7ea5);\n_defineProperty(Op, \"transfer_notification\", 0x7362d09c);\n_defineProperty(Op, \"internal_transfer\", 0x178d4519);\n_defineProperty(Op, \"excesses\", 0xd53276db);\n_defineProperty(Op, \"burn\", 0x595f07bc);\n_defineProperty(Op, \"burn_notification\", 0x7bdd97de);\n_defineProperty(Op, \"provide_wallet_address\", 0x2c76b973);\n_defineProperty(Op, \"take_wallet_address\", 0xd1735400);\n_defineProperty(Op, \"mint\", 21);\n_defineProperty(Op, \"change_admin\", 3);\n_defineProperty(Op, \"change_content\", 4);\nclass Errors {}\n_defineProperty(Errors, \"invalid_op\", 709);\n_defineProperty(Errors, \"not_admin\", 73);\n_defineProperty(Errors, \"unouthorized_burn\", 74);\n_defineProperty(Errors, \"discovery_fee_not_matched\", 75);\n_defineProperty(Errors, \"wrong_op\", 0xffff);\n_defineProperty(Errors, \"not_owner\", 705);\n_defineProperty(Errors, \"not_enough_ton\", 709);\n_defineProperty(Errors, \"not_enough_gas\", 707);\n_defineProperty(Errors, \"not_valid_wallet\", 707);\n_defineProperty(Errors, \"wrong_workchain\", 333);\n_defineProperty(Errors, \"balance_error\", 706);\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/blockchains/ton/contracts/JettonConstants.ts?");

/***/ }),

/***/ "./src/api/blockchains/ton/contracts/JettonMaster.ts":
/*!***********************************************************!*\
  !*** ./src/api/blockchains/ton/contracts/JettonMaster.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"JettonMinter\": () => (/* binding */ JettonMinter),\n/* harmony export */   \"jettonContentToCell\": () => (/* binding */ jettonContentToCell),\n/* harmony export */   \"jettonMinterConfigToCell\": () => (/* binding */ jettonMinterConfigToCell)\n/* harmony export */ });\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ton/core */ \"./node_modules/@ton/core/dist/index.js\");\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ton_core__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _JettonConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./JettonConstants */ \"./src/api/blockchains/ton/contracts/JettonConstants.ts\");\n\n\nfunction jettonMinterConfigToCell(config) {\n  return (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.beginCell)().storeCoins(0).storeAddress(config.admin).storeRef(config.content).storeRef(config.wallet_code).endCell();\n}\nfunction jettonContentToCell(content) {\n  return (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.beginCell)().storeUint(content.type, 8).storeStringTail(content.uri) // Snake logic under the hood\n  .endCell();\n}\nclass JettonMinter {\n  constructor(address, init) {\n    this.address = address;\n    this.init = init;\n  }\n  static createFromAddress(address) {\n    return new JettonMinter(address);\n  }\n  static createFromConfig(config, code) {\n    let workchain = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const data = jettonMinterConfigToCell(config);\n    const init = {\n      code,\n      data\n    };\n    return new JettonMinter((0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.contractAddress)(workchain, init), init);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async sendDeploy(provider, via, value) {\n    await provider.internal(via, {\n      value,\n      sendMode: _ton_core__WEBPACK_IMPORTED_MODULE_0__.SendMode.PAY_GAS_SEPARATELY,\n      body: (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.beginCell)().endCell()\n    });\n  }\n  static jettonInternalTransfer(jetton_amount, forward_ton_amount, response_addr) {\n    let query_id = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    return (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.beginCell)().storeUint(_JettonConstants__WEBPACK_IMPORTED_MODULE_1__.Op.internal_transfer, 32).storeUint(query_id, 64).storeCoins(jetton_amount).storeAddress(undefined).storeAddress(response_addr).storeCoins(forward_ton_amount).storeBit(false).endCell();\n  }\n  static mintMessage(from, to, jetton_amount, forward_ton_amount, total_ton_amount) {\n    let query_id = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    const mintMsg = (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.beginCell)().storeUint(_JettonConstants__WEBPACK_IMPORTED_MODULE_1__.Op.internal_transfer, 32).storeUint(0, 64).storeCoins(jetton_amount).storeAddress(undefined).storeAddress(from) // Response addr\n    .storeCoins(forward_ton_amount).storeMaybeRef(undefined).endCell();\n    return (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.beginCell)().storeUint(_JettonConstants__WEBPACK_IMPORTED_MODULE_1__.Op.mint, 32).storeUint(query_id, 64) // op, queryId\n    .storeAddress(to).storeCoins(total_ton_amount).storeCoins(jetton_amount).storeRef(mintMsg).endCell();\n  }\n  async sendMint(provider, via, to, jetton_amount, forward_ton_amount, total_ton_amount) {\n    if (total_ton_amount <= forward_ton_amount) {\n      throw new Error('Total ton amount should be > forward amount');\n    }\n    await provider.internal(via, {\n      sendMode: _ton_core__WEBPACK_IMPORTED_MODULE_0__.SendMode.PAY_GAS_SEPARATELY,\n      body: JettonMinter.mintMessage(this.address, to, jetton_amount, forward_ton_amount, total_ton_amount),\n      value: total_ton_amount + (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.toNano)('0.015')\n    });\n  }\n\n  /* provide_wallet_address#2c76b973 query_id:uint64 owner_address:MsgAddress include_address:Bool = InternalMsgBody;\n  */\n  static discoveryMessage(owner, include_address) {\n    return (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.beginCell)().storeUint(0x2c76b973, 32).storeUint(0, 64) // op, queryId\n    .storeAddress(owner).storeBit(include_address).endCell();\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async sendDiscovery(provider, via, owner, include_address) {\n    let value = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.toNano)('0.1');\n    await provider.internal(via, {\n      sendMode: _ton_core__WEBPACK_IMPORTED_MODULE_0__.SendMode.PAY_GAS_SEPARATELY,\n      body: JettonMinter.discoveryMessage(owner, include_address),\n      value\n    });\n  }\n  static changeAdminMessage(newOwner) {\n    return (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.beginCell)().storeUint(_JettonConstants__WEBPACK_IMPORTED_MODULE_1__.Op.change_admin, 32).storeUint(0, 64) // op, queryId\n    .storeAddress(newOwner).endCell();\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async sendChangeAdmin(provider, via, newOwner) {\n    await provider.internal(via, {\n      sendMode: _ton_core__WEBPACK_IMPORTED_MODULE_0__.SendMode.PAY_GAS_SEPARATELY,\n      body: JettonMinter.changeAdminMessage(newOwner),\n      value: (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.toNano)('0.05')\n    });\n  }\n  static changeContentMessage(content) {\n    return (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.beginCell)().storeUint(_JettonConstants__WEBPACK_IMPORTED_MODULE_1__.Op.change_content, 32).storeUint(0, 64) // op, queryId\n    .storeRef(content).endCell();\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async sendChangeContent(provider, via, content) {\n    await provider.internal(via, {\n      sendMode: _ton_core__WEBPACK_IMPORTED_MODULE_0__.SendMode.PAY_GAS_SEPARATELY,\n      body: JettonMinter.changeContentMessage(content),\n      value: (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.toNano)('0.05')\n    });\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async getWalletAddress(provider, owner) {\n    const res = await provider.get('get_wallet_address', [{\n      type: 'slice',\n      cell: (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.beginCell)().storeAddress(owner).endCell()\n    }]);\n    return res.stack.readAddress();\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async getJettonData(provider) {\n    const res = await provider.get('get_jetton_data', []);\n    const totalSupply = res.stack.readBigNumber();\n    const mintable = res.stack.readBoolean();\n    const adminAddress = res.stack.readAddress();\n    const content = res.stack.readCell();\n    const walletCode = res.stack.readCell();\n    return {\n      totalSupply,\n      mintable,\n      adminAddress,\n      content,\n      walletCode\n    };\n  }\n  async getTotalSupply(provider) {\n    const res = await this.getJettonData(provider);\n    return res.totalSupply;\n  }\n  async getAdminAddress(provider) {\n    const res = await this.getJettonData(provider);\n    return res.adminAddress;\n  }\n  async getContent(provider) {\n    const res = await this.getJettonData(provider);\n    return res.content;\n  }\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/blockchains/ton/contracts/JettonMaster.ts?");

/***/ }),

/***/ "./src/api/blockchains/ton/contracts/JettonWallet.ts":
/*!***********************************************************!*\
  !*** ./src/api/blockchains/ton/contracts/JettonWallet.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"JettonWallet\": () => (/* binding */ JettonWallet),\n/* harmony export */   \"jettonWalletConfigToCell\": () => (/* binding */ jettonWalletConfigToCell)\n/* harmony export */ });\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ton/core */ \"./node_modules/@ton/core/dist/index.js\");\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ton_core__WEBPACK_IMPORTED_MODULE_0__);\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction jettonWalletConfigToCell(config) {\n  return (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.beginCell)().endCell();\n}\nclass JettonWallet {\n  constructor(address, init) {\n    this.address = address;\n    this.init = init;\n  }\n  static createFromAddress(address) {\n    return new JettonWallet(address);\n  }\n  static createFromConfig(config, code) {\n    let workchain = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const data = jettonWalletConfigToCell(config);\n    const init = {\n      code,\n      data\n    };\n    return new JettonWallet((0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.contractAddress)(workchain, init), init);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async sendDeploy(provider, via, value) {\n    await provider.internal(via, {\n      value,\n      sendMode: _ton_core__WEBPACK_IMPORTED_MODULE_0__.SendMode.PAY_GAS_SEPARATELY,\n      body: (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.beginCell)().endCell()\n    });\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async getJettonBalance(provider) {\n    const state = await provider.getState();\n    if (state.state.type !== 'active') {\n      return 0n;\n    }\n    const res = await provider.get('get_wallet_data', []);\n    return res.stack.readBigNumber();\n  }\n  static transferMessage(jetton_amount, to, responseAddress, customPayload, forward_ton_amount, forwardPayload) {\n    return (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.beginCell)().storeUint(0xf8a7ea5, 32).storeUint(0, 64) // op, queryId\n    .storeCoins(jetton_amount).storeAddress(to).storeAddress(responseAddress).storeMaybeRef(customPayload).storeCoins(forward_ton_amount).storeMaybeRef(forwardPayload).endCell();\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async sendTransfer(provider, via, value, jetton_amount, to, responseAddress, customPayload, forward_ton_amount, forwardPayload) {\n    await provider.internal(via, {\n      sendMode: _ton_core__WEBPACK_IMPORTED_MODULE_0__.SendMode.PAY_GAS_SEPARATELY,\n      body: JettonWallet.transferMessage(jetton_amount, to, responseAddress, customPayload, forward_ton_amount, forwardPayload),\n      value\n    });\n  }\n\n  /*\n    burn#595f07bc query_id:uint64 amount:(VarUInteger 16)\n                  response_destination:MsgAddress custom_payload:(Maybe ^Cell)\n                  = InternalMsgBody;\n  */\n  static burnMessage(jetton_amount, responseAddress, customPayload) {\n    return (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.beginCell)().storeUint(0x595f07bc, 32).storeUint(0, 64) // op, queryId\n    .storeCoins(jetton_amount).storeAddress(responseAddress).storeMaybeRef(customPayload).endCell();\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async sendBurn(provider, via, value, jetton_amount, responseAddress, customPayload) {\n    await provider.internal(via, {\n      sendMode: _ton_core__WEBPACK_IMPORTED_MODULE_0__.SendMode.PAY_GAS_SEPARATELY,\n      body: JettonWallet.burnMessage(jetton_amount, responseAddress, customPayload),\n      value\n    });\n  }\n\n  /*\n    withdraw_tons#107c49ef query_id:uint64 = InternalMsgBody;\n  */\n  static withdrawTonsMessage() {\n    return (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.beginCell)().storeUint(0x6d8e5e3c, 32).storeUint(0, 64) // op, queryId\n    .endCell();\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async sendWithdrawTons(provider, via) {\n    await provider.internal(via, {\n      sendMode: _ton_core__WEBPACK_IMPORTED_MODULE_0__.SendMode.PAY_GAS_SEPARATELY,\n      body: JettonWallet.withdrawTonsMessage(),\n      value: (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.toNano)('0.1')\n    });\n  }\n\n  /*\n    withdraw_jettons#10 query_id:uint64 wallet:MsgAddressInt amount:Coins = InternalMsgBody;\n  */\n  static withdrawJettonsMessage(from, amount) {\n    return (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.beginCell)().storeUint(0x768a50b2, 32).storeUint(0, 64) // op, queryId\n    .storeAddress(from).storeCoins(amount).storeMaybeRef(undefined).endCell();\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async sendWithdrawJettons(provider, via, from, amount) {\n    await provider.internal(via, {\n      sendMode: _ton_core__WEBPACK_IMPORTED_MODULE_0__.SendMode.PAY_GAS_SEPARATELY,\n      body: JettonWallet.withdrawJettonsMessage(from, amount),\n      value: (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.toNano)('0.1')\n    });\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async getWalletData(provider) {\n    const res = await provider.get('get_wallet_data', []);\n    const balance = res.stack.readBigNumber();\n    const owner = res.stack.readAddress();\n    const minter = res.stack.readAddress();\n    const code = res.stack.readCell();\n    return {\n      balance,\n      owner,\n      minter,\n      code\n    };\n  }\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/blockchains/ton/contracts/JettonWallet.ts?");

/***/ }),

/***/ "./src/api/blockchains/ton/contracts/NominatorPool.ts":
/*!************************************************************!*\
  !*** ./src/api/blockchains/ton/contracts/NominatorPool.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NominatorPool\": () => (/* binding */ NominatorPool),\n/* harmony export */   \"nominatorPoolConfigToCell\": () => (/* binding */ nominatorPoolConfigToCell)\n/* harmony export */ });\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ton/core */ \"./node_modules/@ton/core/dist/index.js\");\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ton_core__WEBPACK_IMPORTED_MODULE_0__);\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction nominatorPoolConfigToCell(config) {\n  return (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.beginCell)().endCell();\n}\nclass NominatorPool {\n  constructor(address, init) {\n    this.address = address;\n    this.init = init;\n  }\n  static createFromAddress(address) {\n    return new NominatorPool(address);\n  }\n  static createFromConfig(config, code) {\n    let workchain = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const data = nominatorPoolConfigToCell(config);\n    const init = {\n      code,\n      data\n    };\n    return new NominatorPool((0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.contractAddress)(workchain, init), init);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async getListNominators(provider) {\n    const res = await provider.get('list_nominators', []);\n    const items = res.stack.items[0].items;\n    return items.map(item => {\n      const tuple = new _ton_core__WEBPACK_IMPORTED_MODULE_0__.TupleReader(item.items);\n      const hash = tuple.readBigNumber().toString(16).padStart(64, '0');\n      const address = _ton_core__WEBPACK_IMPORTED_MODULE_0__.Address.parse(`0:${hash}`);\n      const amount = tuple.readBigNumber();\n      const pendingDepositAmount = tuple.readBigNumber();\n      const withdrawRequested = Boolean(tuple.readNumber());\n      return {\n        address,\n        amount,\n        pendingDepositAmount,\n        withdrawRequested\n      };\n    });\n  }\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/blockchains/ton/contracts/NominatorPool.ts?");

/***/ }),

/***/ "./src/api/blockchains/ton/index.ts":
/*!******************************************!*\
  !*** ./src/api/blockchains/ton/index.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"buildTokenSlug\": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_3__.buildTokenSlug),\n/* harmony export */   \"checkApiAvailability\": () => (/* reexport safe */ _other__WEBPACK_IMPORTED_MODULE_7__.checkApiAvailability),\n/* harmony export */   \"checkMultiTransactionDraft\": () => (/* reexport safe */ _transactions__WEBPACK_IMPORTED_MODULE_4__.checkMultiTransactionDraft),\n/* harmony export */   \"checkStakeDraft\": () => (/* reexport safe */ _staking__WEBPACK_IMPORTED_MODULE_6__.checkStakeDraft),\n/* harmony export */   \"checkTransactionDraft\": () => (/* reexport safe */ _transactions__WEBPACK_IMPORTED_MODULE_4__.checkTransactionDraft),\n/* harmony export */   \"checkUnstakeDraft\": () => (/* reexport safe */ _staking__WEBPACK_IMPORTED_MODULE_6__.checkUnstakeDraft),\n/* harmony export */   \"decryptComment\": () => (/* reexport safe */ _transactions__WEBPACK_IMPORTED_MODULE_4__.decryptComment),\n/* harmony export */   \"decryptMnemonic\": () => (/* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_0__.decryptMnemonic),\n/* harmony export */   \"encryptMnemonic\": () => (/* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_0__.encryptMnemonic),\n/* harmony export */   \"fetchMnemonic\": () => (/* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_0__.fetchMnemonic),\n/* harmony export */   \"fetchPrivateKey\": () => (/* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_0__.fetchPrivateKey),\n/* harmony export */   \"fetchToken\": () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_8__.fetchToken),\n/* harmony export */   \"fixTokenActivitiesAddressForm\": () => (/* reexport safe */ _transactions__WEBPACK_IMPORTED_MODULE_4__.fixTokenActivitiesAddressForm),\n/* harmony export */   \"generateMnemonic\": () => (/* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_0__.generateMnemonic),\n/* harmony export */   \"getAccountBalance\": () => (/* reexport safe */ _wallet__WEBPACK_IMPORTED_MODULE_5__.getAccountBalance),\n/* harmony export */   \"getAccountNewestTxId\": () => (/* reexport safe */ _transactions__WEBPACK_IMPORTED_MODULE_4__.getAccountNewestTxId),\n/* harmony export */   \"getAccountNfts\": () => (/* reexport safe */ _nfts__WEBPACK_IMPORTED_MODULE_1__.getAccountNfts),\n/* harmony export */   \"getAccountTokenBalances\": () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_8__.getAccountTokenBalances),\n/* harmony export */   \"getAccountTransactionSlice\": () => (/* reexport safe */ _transactions__WEBPACK_IMPORTED_MODULE_4__.getAccountTransactionSlice),\n/* harmony export */   \"getAddressTokenBalances\": () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_8__.getAddressTokenBalances),\n/* harmony export */   \"getMergedTransactionSlice\": () => (/* reexport safe */ _transactions__WEBPACK_IMPORTED_MODULE_4__.getMergedTransactionSlice),\n/* harmony export */   \"getNftUpdates\": () => (/* reexport safe */ _nfts__WEBPACK_IMPORTED_MODULE_1__.getNftUpdates),\n/* harmony export */   \"getStakingState\": () => (/* reexport safe */ _staking__WEBPACK_IMPORTED_MODULE_6__.getStakingState),\n/* harmony export */   \"getTokenTransactionSlice\": () => (/* reexport safe */ _transactions__WEBPACK_IMPORTED_MODULE_4__.getTokenTransactionSlice),\n/* harmony export */   \"getWalletBalance\": () => (/* reexport safe */ _wallet__WEBPACK_IMPORTED_MODULE_5__.getWalletBalance),\n/* harmony export */   \"getWalletInfo\": () => (/* reexport safe */ _wallet__WEBPACK_IMPORTED_MODULE_5__.getWalletInfo),\n/* harmony export */   \"getWalletSeqno\": () => (/* reexport safe */ _wallet__WEBPACK_IMPORTED_MODULE_5__.getWalletSeqno),\n/* harmony export */   \"getWalletStateInit\": () => (/* reexport safe */ _wallet__WEBPACK_IMPORTED_MODULE_5__.getWalletStateInit),\n/* harmony export */   \"getWalletVersionInfos\": () => (/* reexport safe */ _wallet__WEBPACK_IMPORTED_MODULE_5__.getWalletVersionInfos),\n/* harmony export */   \"getWalletVersions\": () => (/* reexport safe */ _wallet__WEBPACK_IMPORTED_MODULE_5__.getWalletVersions),\n/* harmony export */   \"isActiveSmartContract\": () => (/* reexport safe */ _wallet__WEBPACK_IMPORTED_MODULE_5__.isActiveSmartContract),\n/* harmony export */   \"isAddressInitialized\": () => (/* reexport safe */ _wallet__WEBPACK_IMPORTED_MODULE_5__.isAddressInitialized),\n/* harmony export */   \"mnemonicToSeed\": () => (/* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_0__.mnemonicToSeed),\n/* harmony export */   \"normalizeAddress\": () => (/* reexport safe */ _address__WEBPACK_IMPORTED_MODULE_10__.normalizeAddress),\n/* harmony export */   \"oneCellFromBoc\": () => (/* reexport safe */ _util_tonCore__WEBPACK_IMPORTED_MODULE_2__.oneCellFromBoc),\n/* harmony export */   \"packPayloadToBoc\": () => (/* reexport safe */ _other__WEBPACK_IMPORTED_MODULE_7__.packPayloadToBoc),\n/* harmony export */   \"parsePayloadBase64\": () => (/* reexport safe */ _util_metadata__WEBPACK_IMPORTED_MODULE_9__.parsePayloadBase64),\n/* harmony export */   \"pickAccountWallet\": () => (/* reexport safe */ _wallet__WEBPACK_IMPORTED_MODULE_5__.pickAccountWallet),\n/* harmony export */   \"pickBestWallet\": () => (/* reexport safe */ _wallet__WEBPACK_IMPORTED_MODULE_5__.pickBestWallet),\n/* harmony export */   \"pickWalletByAddress\": () => (/* reexport safe */ _wallet__WEBPACK_IMPORTED_MODULE_5__.pickWalletByAddress),\n/* harmony export */   \"publicKeyToAddress\": () => (/* reexport safe */ _wallet__WEBPACK_IMPORTED_MODULE_5__.publicKeyToAddress),\n/* harmony export */   \"rawSign\": () => (/* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_0__.rawSign),\n/* harmony export */   \"resolveTokenBySlug\": () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_8__.resolveTokenBySlug),\n/* harmony export */   \"resolveTokenMinterAddress\": () => (/* reexport safe */ _util_tonCore__WEBPACK_IMPORTED_MODULE_2__.resolveTokenMinterAddress),\n/* harmony export */   \"resolveTokenWalletAddress\": () => (/* reexport safe */ _util_tonCore__WEBPACK_IMPORTED_MODULE_2__.resolveTokenWalletAddress),\n/* harmony export */   \"resolveWalletVersion\": () => (/* reexport safe */ _wallet__WEBPACK_IMPORTED_MODULE_5__.resolveWalletVersion),\n/* harmony export */   \"seedToKeyPair\": () => (/* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_0__.seedToKeyPair),\n/* harmony export */   \"sendSignedMessage\": () => (/* reexport safe */ _transactions__WEBPACK_IMPORTED_MODULE_4__.sendSignedMessage),\n/* harmony export */   \"sendSignedMessages\": () => (/* reexport safe */ _transactions__WEBPACK_IMPORTED_MODULE_4__.sendSignedMessages),\n/* harmony export */   \"submitMultiTransfer\": () => (/* reexport safe */ _transactions__WEBPACK_IMPORTED_MODULE_4__.submitMultiTransfer),\n/* harmony export */   \"submitStake\": () => (/* reexport safe */ _staking__WEBPACK_IMPORTED_MODULE_6__.submitStake),\n/* harmony export */   \"submitTransfer\": () => (/* reexport safe */ _transactions__WEBPACK_IMPORTED_MODULE_4__.submitTransfer),\n/* harmony export */   \"submitUnstake\": () => (/* reexport safe */ _staking__WEBPACK_IMPORTED_MODULE_6__.submitUnstake),\n/* harmony export */   \"validateDexSwapTransfers\": () => (/* reexport safe */ _swap__WEBPACK_IMPORTED_MODULE_11__.validateDexSwapTransfers),\n/* harmony export */   \"validateMnemonic\": () => (/* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_0__.validateMnemonic),\n/* harmony export */   \"verifyPassword\": () => (/* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_0__.verifyPassword),\n/* harmony export */   \"waitLastTransfer\": () => (/* reexport safe */ _transactions__WEBPACK_IMPORTED_MODULE_4__.waitLastTransfer),\n/* harmony export */   \"waitUntilTransactionAppears\": () => (/* reexport safe */ _transactions__WEBPACK_IMPORTED_MODULE_4__.waitUntilTransactionAppears)\n/* harmony export */ });\n/* harmony import */ var _auth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./auth */ \"./src/api/blockchains/ton/auth.ts\");\n/* harmony import */ var _nfts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nfts */ \"./src/api/blockchains/ton/nfts.ts\");\n/* harmony import */ var _util_tonCore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/tonCore */ \"./src/api/blockchains/ton/util/tonCore.ts\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ \"./src/api/blockchains/ton/util/index.ts\");\n/* harmony import */ var _transactions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./transactions */ \"./src/api/blockchains/ton/transactions.ts\");\n/* harmony import */ var _wallet__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./wallet */ \"./src/api/blockchains/ton/wallet.ts\");\n/* harmony import */ var _staking__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./staking */ \"./src/api/blockchains/ton/staking.ts\");\n/* harmony import */ var _other__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./other */ \"./src/api/blockchains/ton/other.ts\");\n/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tokens */ \"./src/api/blockchains/ton/tokens.ts\");\n/* harmony import */ var _util_metadata__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./util/metadata */ \"./src/api/blockchains/ton/util/metadata.ts\");\n/* harmony import */ var _address__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./address */ \"./src/api/blockchains/ton/address.ts\");\n/* harmony import */ var _swap__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./swap */ \"./src/api/blockchains/ton/swap.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/blockchains/ton/index.ts?");

/***/ }),

/***/ "./src/api/blockchains/ton/nfts.ts":
/*!*****************************************!*\
  !*** ./src/api/blockchains/ton/nfts.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"buildNft\": () => (/* binding */ buildNft),\n/* harmony export */   \"getAccountNfts\": () => (/* binding */ getAccountNfts),\n/* harmony export */   \"getNftUpdates\": () => (/* binding */ getNftUpdates)\n/* harmony export */ });\n/* harmony import */ var _util_account__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/account */ \"./src/util/account.ts\");\n/* harmony import */ var _util_iteratees__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/iteratees */ \"./src/util/iteratees.ts\");\n/* harmony import */ var _util_tonapiio__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/tonapiio */ \"./src/api/blockchains/ton/util/tonapiio.ts\");\n/* harmony import */ var _util_tonCore__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/tonCore */ \"./src/api/blockchains/ton/util/tonCore.ts\");\n/* harmony import */ var _common_accounts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/accounts */ \"./src/api/common/accounts.ts\");\n/* harmony import */ var _wallet__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./wallet */ \"./src/api/blockchains/ton/wallet.ts\");\n\n\n\n\n\n\nasync function getAccountNfts(accountId, offset, limit) {\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_0__.parseAccountId)(accountId);\n  const address = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_4__.fetchStoredAddress)(accountId);\n  const rawNfts = await (0,_util_tonapiio__WEBPACK_IMPORTED_MODULE_2__.fetchAccountNfts)(network, address, {\n    offset,\n    limit\n  });\n  return (0,_util_iteratees__WEBPACK_IMPORTED_MODULE_1__.compact)(rawNfts.map(rawNft => buildNft(network, rawNft)));\n}\nfunction buildNft(network, rawNft) {\n  if (!rawNft.metadata) {\n    return undefined;\n  }\n  try {\n    const {\n      address,\n      index,\n      collection,\n      metadata: {\n        name,\n        image,\n        description,\n        render_type: renderType\n      },\n      previews,\n      sale\n    } = rawNft;\n    const isHidden = renderType === 'hidden' || description === 'SCAM';\n    return {\n      index,\n      name,\n      address: (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_3__.toBase64Address)(address, true, network),\n      image,\n      thumbnail: previews.find(x => x.resolution === '500x500').url,\n      isOnSale: Boolean(sale),\n      isHidden,\n      ...(collection && {\n        collectionAddress: (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_3__.toBase64Address)(collection.address, true, network),\n        collectionName: collection.name\n      })\n    };\n  } catch (err) {\n    return undefined;\n  }\n}\nasync function getNftUpdates(accountId, fromSec) {\n  var _events$0$timestamp, _events$;\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_0__.parseAccountId)(accountId);\n  const address = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_4__.fetchStoredAddress)(accountId);\n  const events = await (0,_util_tonapiio__WEBPACK_IMPORTED_MODULE_2__.fetchAccountEvents)(network, address, fromSec);\n  fromSec = (_events$0$timestamp = (_events$ = events[0]) === null || _events$ === void 0 ? void 0 : _events$.timestamp) !== null && _events$0$timestamp !== void 0 ? _events$0$timestamp : fromSec;\n  events.reverse();\n  const updates = [];\n  for (const event of events) {\n    for (const action of event.actions) {\n      let to;\n      let nftAddress;\n      let rawNft;\n      const isPurchase = !!action.NftPurchase;\n      if (action.NftItemTransfer) {\n        const {\n          sender,\n          recipient,\n          nft: rawNftAddress\n        } = action.NftItemTransfer;\n        if (!sender || !recipient) continue;\n        to = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_3__.toBase64Address)(recipient.address, undefined, network);\n        nftAddress = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_3__.toBase64Address)(rawNftAddress, true, network);\n      } else if (action.NftPurchase) {\n        const {\n          buyer\n        } = action.NftPurchase;\n        to = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_3__.toBase64Address)(buyer.address, undefined, network);\n        rawNft = action.NftPurchase.nft;\n        if (!rawNft) {\n          continue;\n        }\n        nftAddress = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_3__.toBase64Address)(rawNft.address, true, network);\n      } else {\n        continue;\n      }\n      if (to === address) {\n        if (!rawNft) {\n          [rawNft] = await (0,_util_tonapiio__WEBPACK_IMPORTED_MODULE_2__.fetchNftItems)(network, [nftAddress]);\n        }\n        if (rawNft) {\n          const nft = buildNft(network, rawNft);\n          if (nft) {\n            updates.push({\n              type: 'nftReceived',\n              accountId,\n              nftAddress,\n              nft\n            });\n          }\n        }\n      } else if (!isPurchase && (await (0,_wallet__WEBPACK_IMPORTED_MODULE_5__.isActiveSmartContract)(network, to))) {\n        updates.push({\n          type: 'nftPutUpForSale',\n          accountId,\n          nftAddress\n        });\n      } else {\n        updates.push({\n          type: 'nftSent',\n          accountId,\n          nftAddress\n        });\n      }\n    }\n  }\n  return [fromSec, updates];\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/blockchains/ton/nfts.ts?");

/***/ }),

/***/ "./src/api/blockchains/ton/other.ts":
/*!******************************************!*\
  !*** ./src/api/blockchains/ton/other.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"checkApiAvailability\": () => (/* binding */ checkApiAvailability),\n/* harmony export */   \"packPayloadToBoc\": () => (/* binding */ packPayloadToBoc)\n/* harmony export */ });\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ton/core */ \"./node_modules/@ton/core/dist/index.js\");\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ton_core__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _util_tonCore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/tonCore */ \"./src/api/blockchains/ton/util/tonCore.ts\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\nfunction packPayloadToBoc(payload) {\n  let cell = new _ton_core__WEBPACK_IMPORTED_MODULE_0__.Cell();\n  if (payload) {\n    if (payload instanceof _ton_core__WEBPACK_IMPORTED_MODULE_0__.Cell) {\n      cell = payload;\n    } else if (typeof payload === 'string') {\n      if (payload.length > 0) {\n        cell = new _ton_core__WEBPACK_IMPORTED_MODULE_0__.Builder().storeUint(0, 32).storeStringTail(payload).asCell();\n      }\n    } else {\n      cell = new _ton_core__WEBPACK_IMPORTED_MODULE_0__.Builder().storeBuffer(Buffer.from(payload)).asCell();\n    }\n  }\n  return cell.toBoc().toString('base64');\n}\nasync function checkApiAvailability(network) {\n  try {\n    await (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_1__.getTonClient)(network).getMasterchainInfo();\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/blockchains/ton/other.ts?");

/***/ }),

/***/ "./src/api/blockchains/ton/staking.ts":
/*!********************************************!*\
  !*** ./src/api/blockchains/ton/staking.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"buildLiquidStakingWithdraw\": () => (/* binding */ buildLiquidStakingWithdraw),\n/* harmony export */   \"checkStakeDraft\": () => (/* binding */ checkStakeDraft),\n/* harmony export */   \"checkUnstakeDraft\": () => (/* binding */ checkUnstakeDraft),\n/* harmony export */   \"getStakingState\": () => (/* binding */ getStakingState),\n/* harmony export */   \"submitStake\": () => (/* binding */ submitStake),\n/* harmony export */   \"submitUnstake\": () => (/* binding */ submitUnstake)\n/* harmony export */ });\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ton/core */ \"./node_modules/@ton/core/dist/index.js\");\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ton_core__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../types */ \"./src/api/types/index.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../config */ \"./src/config.ts\");\n/* harmony import */ var _util_account__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../util/account */ \"./src/util/account.ts\");\n/* harmony import */ var _util_bigint__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../util/bigint */ \"./src/util/bigint.ts\");\n/* harmony import */ var _util_decimals__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../util/decimals */ \"./src/util/decimals.ts\");\n/* harmony import */ var _util_tonCore__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util/tonCore */ \"./src/api/blockchains/ton/util/tonCore.ts\");\n/* harmony import */ var _contracts_NominatorPool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./contracts/NominatorPool */ \"./src/api/blockchains/ton/contracts/NominatorPool.ts\");\n/* harmony import */ var _common_accounts__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../common/accounts */ \"./src/api/common/accounts.ts\");\n/* harmony import */ var _common_cache__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../common/cache */ \"./src/api/common/cache.ts\");\n/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../db */ \"./src/api/db.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./constants */ \"./src/api/blockchains/ton/constants.ts\");\n/* harmony import */ var _transactions__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./transactions */ \"./src/api/blockchains/ton/transactions.ts\");\n/* harmony import */ var _wallet__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./wallet */ \"./src/api/blockchains/ton/wallet.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nasync function checkStakeDraft(accountId, amount, backendState) {\n  const staked = await getStakingState(accountId, backendState);\n  let type;\n  let result;\n  if ((staked === null || staked === void 0 ? void 0 : staked.type) === 'nominators' && amount >= _config__WEBPACK_IMPORTED_MODULE_2__.ONE_TON) {\n    type = 'nominators';\n    const poolAddress = backendState.nominatorsPool.address;\n    amount += _config__WEBPACK_IMPORTED_MODULE_2__.ONE_TON;\n    result = await (0,_transactions__WEBPACK_IMPORTED_MODULE_12__.checkTransactionDraft)(accountId, _config__WEBPACK_IMPORTED_MODULE_2__.TON_TOKEN_SLUG, poolAddress, amount, _constants__WEBPACK_IMPORTED_MODULE_11__.STAKE_COMMENT);\n  } else if (amount < _config__WEBPACK_IMPORTED_MODULE_2__.ONE_TON) {\n    return {\n      error: _types__WEBPACK_IMPORTED_MODULE_1__.ApiTransactionDraftError.InvalidAmount\n    };\n  } else {\n    type = 'liquid';\n    const body = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_6__.buildLiquidStakingDepositBody)();\n    result = await (0,_transactions__WEBPACK_IMPORTED_MODULE_12__.checkTransactionDraft)(accountId, _config__WEBPACK_IMPORTED_MODULE_2__.TON_TOKEN_SLUG, _config__WEBPACK_IMPORTED_MODULE_2__.LIQUID_POOL, amount, body);\n  }\n  return {\n    ...result,\n    type\n  };\n}\nasync function checkUnstakeDraft(accountId, amount, backendState) {\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_3__.parseAccountId)(accountId);\n  const address = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_8__.fetchStoredAddress)(accountId);\n  const commonData = (0,_common_cache__WEBPACK_IMPORTED_MODULE_9__.getStakingCommonCache)();\n  const staked = await getStakingState(accountId, backendState);\n  let type;\n  let result;\n  let tokenAmount;\n  if (staked.type === 'nominators') {\n    type = 'nominators';\n    const poolAddress = backendState.nominatorsPool.address;\n    result = await (0,_transactions__WEBPACK_IMPORTED_MODULE_12__.checkTransactionDraft)(accountId, _config__WEBPACK_IMPORTED_MODULE_2__.TON_TOKEN_SLUG, poolAddress, _config__WEBPACK_IMPORTED_MODULE_2__.ONE_TON, _constants__WEBPACK_IMPORTED_MODULE_11__.UNSTAKE_COMMENT);\n  } else if (staked.type === 'liquid') {\n    type = 'liquid';\n    if (amount > staked.amount) {\n      return {\n        error: _types__WEBPACK_IMPORTED_MODULE_1__.ApiTransactionDraftError.InsufficientBalance\n      };\n    } else if (amount === staked.amount) {\n      tokenAmount = staked.tokenAmount;\n    } else {\n      tokenAmount = (0,_util_bigint__WEBPACK_IMPORTED_MODULE_4__.bigintDivideToNumber)(amount, commonData.liquid.currentRate);\n    }\n    const params = await buildLiquidStakingWithdraw(network, address, tokenAmount);\n    result = await (0,_transactions__WEBPACK_IMPORTED_MODULE_12__.checkTransactionDraft)(accountId, _config__WEBPACK_IMPORTED_MODULE_2__.TON_TOKEN_SLUG, params.toAddress, params.amount, params.payload);\n  } else {\n    return {\n      error: _types__WEBPACK_IMPORTED_MODULE_1__.ApiCommonError.Unexpected\n    };\n  }\n  return {\n    ...result,\n    type,\n    tokenAmount\n  };\n}\nasync function submitStake(accountId, password, amount, type, backendState) {\n  let result;\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_3__.parseAccountId)(accountId);\n  const address = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_8__.fetchStoredAddress)(accountId);\n  if (type === 'liquid') {\n    amount += _config__WEBPACK_IMPORTED_MODULE_2__.ONE_TON;\n    result = await (0,_transactions__WEBPACK_IMPORTED_MODULE_12__.submitTransfer)(accountId, password, _config__WEBPACK_IMPORTED_MODULE_2__.TON_TOKEN_SLUG, _config__WEBPACK_IMPORTED_MODULE_2__.LIQUID_POOL, amount, (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_6__.buildLiquidStakingDepositBody)());\n  } else {\n    const poolAddress = backendState.nominatorsPool.address;\n    result = await (0,_transactions__WEBPACK_IMPORTED_MODULE_12__.submitTransfer)(accountId, password, _config__WEBPACK_IMPORTED_MODULE_2__.TON_TOKEN_SLUG, (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_6__.toBase64Address)(poolAddress, true, network), amount, _constants__WEBPACK_IMPORTED_MODULE_11__.STAKE_COMMENT);\n  }\n  if (!('error' in result)) {\n    (0,_common_cache__WEBPACK_IMPORTED_MODULE_9__.updateAccountCache)(accountId, address, {\n      stakedAt: Date.now()\n    });\n  }\n  return result;\n}\nasync function submitUnstake(accountId, password, type, amount, backendState) {\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_3__.parseAccountId)(accountId);\n  const address = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_8__.fetchStoredAddress)(accountId);\n  const staked = await getStakingState(accountId, backendState);\n  let result;\n  if (type === 'liquid') {\n    const mode = staked.type === 'liquid' && !staked.instantAvailable ? _types__WEBPACK_IMPORTED_MODULE_1__.ApiLiquidUnstakeMode.BestRate : _types__WEBPACK_IMPORTED_MODULE_1__.ApiLiquidUnstakeMode.Default;\n    const params = await buildLiquidStakingWithdraw(network, address, amount, mode);\n    result = await (0,_transactions__WEBPACK_IMPORTED_MODULE_12__.submitTransfer)(accountId, password, _config__WEBPACK_IMPORTED_MODULE_2__.TON_TOKEN_SLUG, params.toAddress, params.amount, params.payload);\n  } else {\n    const poolAddress = backendState.nominatorsPool.address;\n    result = await (0,_transactions__WEBPACK_IMPORTED_MODULE_12__.submitTransfer)(accountId, password, _config__WEBPACK_IMPORTED_MODULE_2__.TON_TOKEN_SLUG, (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_6__.toBase64Address)(poolAddress, true, network), _config__WEBPACK_IMPORTED_MODULE_2__.ONE_TON, _constants__WEBPACK_IMPORTED_MODULE_11__.UNSTAKE_COMMENT);\n  }\n  return result;\n}\nasync function buildLiquidStakingWithdraw(network, address, amount) {\n  let mode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _types__WEBPACK_IMPORTED_MODULE_1__.ApiLiquidUnstakeMode.Default;\n  const tokenWalletAddress = await (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_6__.resolveTokenWalletAddress)(network, address, _config__WEBPACK_IMPORTED_MODULE_2__.LIQUID_JETTON);\n  const payload = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_6__.buildLiquidStakingWithdrawBody)({\n    amount,\n    responseAddress: address,\n    fillOrKill: mode === _types__WEBPACK_IMPORTED_MODULE_1__.ApiLiquidUnstakeMode.Instant,\n    waitTillRoundEnd: mode === _types__WEBPACK_IMPORTED_MODULE_1__.ApiLiquidUnstakeMode.BestRate\n  });\n  return {\n    amount: _config__WEBPACK_IMPORTED_MODULE_2__.ONE_TON,\n    toAddress: tokenWalletAddress,\n    payload\n  };\n}\nasync function getStakingState(accountId, backendState) {\n  var _accountCache$stakedA, _backendState$stakedA;\n  const commonData = (0,_common_cache__WEBPACK_IMPORTED_MODULE_9__.getStakingCommonCache)();\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_3__.parseAccountId)(accountId);\n  const address = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_8__.fetchStoredAddress)(accountId);\n  const {\n    currentRate,\n    collection\n  } = commonData.liquid;\n  const tokenBalance = await getLiquidStakingTokenBalance(accountId);\n  let unstakeAmount = 0n;\n  if (collection) {\n    const nfts = await _db__WEBPACK_IMPORTED_MODULE_10__.apiDb.nfts.where({\n      accountId,\n      collectionAddress: collection\n    }).toArray();\n    for (const nft of nfts) {\n      var _nft$name;\n      const billAmount = (_nft$name = nft.name) === null || _nft$name === void 0 || (_nft$name = _nft$name.match(/Bill for (?<amount>[\\d.]+) Pool Jetton/)) === null || _nft$name === void 0 || (_nft$name = _nft$name.groups) === null || _nft$name === void 0 ? void 0 : _nft$name.amount;\n      if (billAmount) {\n        unstakeAmount += (0,_util_decimals__WEBPACK_IMPORTED_MODULE_5__.fromDecimal)(billAmount);\n      }\n    }\n  }\n  const {\n    loyaltyType,\n    shouldUseNominators\n  } = backendState;\n  const accountCache = (0,_common_cache__WEBPACK_IMPORTED_MODULE_9__.getAccountCache)(accountId, address);\n  const stakedAt = Math.max((_accountCache$stakedA = accountCache.stakedAt) !== null && _accountCache$stakedA !== void 0 ? _accountCache$stakedA : 0, (_backendState$stakedA = backendState.stakedAt) !== null && _backendState$stakedA !== void 0 ? _backendState$stakedA : 0);\n  const isInstantUnstake = Date.now() - stakedAt > _config__WEBPACK_IMPORTED_MODULE_2__.VALIDATION_PERIOD_MS;\n  const liquidAvailable = isInstantUnstake ? commonData.liquid.available : 0n;\n  let liquidApy = commonData.liquid.apy;\n  if (loyaltyType && loyaltyType in commonData.liquid.loyaltyApy) {\n    liquidApy = commonData.liquid.loyaltyApy[loyaltyType];\n  }\n  if (tokenBalance > 0n || unstakeAmount > 0n) {\n    const fullTokenAmount = tokenBalance + unstakeAmount;\n    const amount = (0,_util_bigint__WEBPACK_IMPORTED_MODULE_4__.bigintMultiplyToNumber)(fullTokenAmount, currentRate);\n    return {\n      type: 'liquid',\n      tokenAmount: tokenBalance,\n      amount,\n      unstakeRequestAmount: unstakeAmount,\n      apy: liquidApy,\n      instantAvailable: liquidAvailable\n    };\n  }\n  const poolAddress = backendState.nominatorsPool.address;\n  if (backendState.type === 'nominators') {\n    const nominatorPool = getPoolContract(network, poolAddress);\n    const nominators = await nominatorPool.getListNominators();\n    const addressObject = _ton_core__WEBPACK_IMPORTED_MODULE_0__.Address.parse(address);\n    const currentNominator = nominators.find(n => n.address.equals(addressObject));\n    if (currentNominator) {\n      return {\n        type: 'nominators',\n        amount: backendState.balance,\n        pendingDepositAmount: currentNominator.pendingDepositAmount,\n        isUnstakeRequested: currentNominator.withdrawRequested\n      };\n    }\n  }\n  if (shouldUseNominators) {\n    return {\n      type: 'nominators',\n      amount: 0n,\n      pendingDepositAmount: 0n,\n      isUnstakeRequested: false\n    };\n  } else {\n    return {\n      type: 'liquid',\n      tokenAmount: 0n,\n      amount: 0n,\n      unstakeRequestAmount: 0n,\n      apy: liquidApy,\n      instantAvailable: liquidAvailable\n    };\n  }\n}\nfunction getPoolContract(network, poolAddress) {\n  return (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_6__.getTonClient)(network).open(new _contracts_NominatorPool__WEBPACK_IMPORTED_MODULE_7__.NominatorPool(_ton_core__WEBPACK_IMPORTED_MODULE_0__.Address.parse(poolAddress)));\n}\nasync function getLiquidStakingTokenBalance(accountId) {\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_3__.parseAccountId)(accountId);\n  if (network !== 'mainnet') {\n    return 0n;\n  }\n  const address = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_8__.fetchStoredAddress)(accountId);\n  const walletAddress = await (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_6__.resolveTokenWalletAddress)(network, address, _config__WEBPACK_IMPORTED_MODULE_2__.LIQUID_JETTON);\n  const isInitialized = await (0,_wallet__WEBPACK_IMPORTED_MODULE_13__.isAddressInitialized)(network, walletAddress);\n  if (!isInitialized) {\n    return 0n;\n  }\n  return (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_6__.getTokenBalance)(network, walletAddress);\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/blockchains/ton/staking.ts?");

/***/ }),

/***/ "./src/api/blockchains/ton/swap.ts":
/*!*****************************************!*\
  !*** ./src/api/blockchains/ton/swap.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"validateDexSwapTransfers\": () => (/* binding */ validateDexSwapTransfers)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../config */ \"./src/config.ts\");\n/* harmony import */ var _util_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/assert */ \"./src/util/assert.ts\");\n/* harmony import */ var _util_decimals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/decimals */ \"./src/util/decimals.ts\");\n/* harmony import */ var _util_metadata__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/metadata */ \"./src/api/blockchains/ton/util/metadata.ts\");\n/* harmony import */ var _util_tonCore__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util/tonCore */ \"./src/api/blockchains/ton/util/tonCore.ts\");\n/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tokens */ \"./src/api/blockchains/ton/tokens.ts\");\n/* harmony import */ var _wallet__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./wallet */ \"./src/api/blockchains/ton/wallet.ts\");\n\n\n\n\n\n\n\nconst MEGATON_WTON_MINTER = 'EQCajaUU1XXSAjTD-xOV7pE49fGtg4q8kF3ELCOJtGvQFQ2C';\nconst MAX_NETWORK_FEE = 1000000000n; // 1 TON\n\nasync function validateDexSwapTransfers(network, address, params, transfers) {\n  (0,_util_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(transfers.length <= 2);\n  const [mainTransfer, feeTransfer] = transfers;\n  if (params.from === _config__WEBPACK_IMPORTED_MODULE_0__.TON_SYMBOL) {\n    const maxAmount = (0,_util_decimals__WEBPACK_IMPORTED_MODULE_2__.fromDecimal)(params.fromAmount) + MAX_NETWORK_FEE;\n    const {\n      isSwapAllowed,\n      codeHash\n    } = await (0,_wallet__WEBPACK_IMPORTED_MODULE_6__.getContractInfo)(network, mainTransfer.toAddress);\n    (0,_util_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(!!isSwapAllowed, `Not allowed swap contract: ${codeHash} ${mainTransfer.toAddress}`);\n    (0,_util_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(mainTransfer.amount <= maxAmount);\n    if (feeTransfer) {\n      (0,_util_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(feeTransfer.amount <= mainTransfer.amount);\n      (0,_util_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(feeTransfer.amount + mainTransfer.amount < maxAmount);\n      (0,_util_assert__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util_tonCore__WEBPACK_IMPORTED_MODULE_4__.toBase64Address)(feeTransfer.toAddress, false) === _config__WEBPACK_IMPORTED_MODULE_0__.SWAP_FEE_ADDRESS);\n    }\n  } else {\n    const token = (0,_tokens__WEBPACK_IMPORTED_MODULE_5__.findTokenByMinter)(params.from);\n    (0,_util_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(!!token);\n    const maxAmount = (0,_util_decimals__WEBPACK_IMPORTED_MODULE_2__.fromDecimal)(params.fromAmount, token.decimals);\n    const maxTonAmount = MAX_NETWORK_FEE;\n    const walletAddress = await (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_4__.resolveTokenWalletAddress)(network, address, token.minterAddress);\n    const parsedPayload = await (0,_util_metadata__WEBPACK_IMPORTED_MODULE_3__.parsePayloadBase64)(network, mainTransfer.toAddress, mainTransfer.payload);\n    let destination;\n    let tokenAmount = 0n;\n    if (mainTransfer.toAddress === MEGATON_WTON_MINTER) {\n      destination = mainTransfer.toAddress;\n      (0,_util_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(mainTransfer.toAddress === token.minterAddress);\n    } else {\n      (0,_util_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(mainTransfer.toAddress === walletAddress);\n      (0,_util_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(['tokens:transfer', 'tokens:transfer-non-standard'].includes(parsedPayload.type));\n      ({\n        amount: tokenAmount,\n        destination\n      } = parsedPayload);\n      (0,_util_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(tokenAmount <= maxAmount);\n    }\n    (0,_util_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(mainTransfer.amount < maxTonAmount);\n    const {\n      isSwapAllowed\n    } = await (0,_wallet__WEBPACK_IMPORTED_MODULE_6__.getContractInfo)(network, destination);\n    (0,_util_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(!!isSwapAllowed);\n    if (feeTransfer) {\n      const feePayload = await (0,_util_metadata__WEBPACK_IMPORTED_MODULE_3__.parsePayloadBase64)(network, feeTransfer.toAddress, feeTransfer.payload);\n      (0,_util_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(feeTransfer.amount + mainTransfer.amount < maxTonAmount);\n      (0,_util_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(feeTransfer.toAddress === walletAddress);\n      (0,_util_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(['tokens:transfer', 'tokens:transfer-non-standard'].includes(feePayload.type));\n      const {\n        amount: tokenFeeAmount,\n        destination: feeDestination\n      } = feePayload;\n      (0,_util_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(tokenFeeAmount < tokenAmount);\n      (0,_util_assert__WEBPACK_IMPORTED_MODULE_1__.assert)(tokenAmount + tokenFeeAmount <= maxAmount);\n      (0,_util_assert__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util_tonCore__WEBPACK_IMPORTED_MODULE_4__.toBase64Address)(feeDestination, false) === _config__WEBPACK_IMPORTED_MODULE_0__.SWAP_FEE_ADDRESS);\n    }\n  }\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/blockchains/ton/swap.ts?");

/***/ }),

/***/ "./src/api/blockchains/ton/tokens.ts":
/*!*******************************************!*\
  !*** ./src/api/blockchains/ton/tokens.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addKnownTokens\": () => (/* binding */ addKnownTokens),\n/* harmony export */   \"buildTokenTransfer\": () => (/* binding */ buildTokenTransfer),\n/* harmony export */   \"fetchToken\": () => (/* binding */ fetchToken),\n/* harmony export */   \"findTokenByMinter\": () => (/* binding */ findTokenByMinter),\n/* harmony export */   \"getAccountTokenBalances\": () => (/* binding */ getAccountTokenBalances),\n/* harmony export */   \"getAddressTokenBalances\": () => (/* binding */ getAddressTokenBalances),\n/* harmony export */   \"getKnownTokens\": () => (/* binding */ getKnownTokens),\n/* harmony export */   \"getTokenWallet\": () => (/* binding */ getTokenWallet),\n/* harmony export */   \"parseTokenTransaction\": () => (/* binding */ parseTokenTransaction),\n/* harmony export */   \"resolveTokenBySlug\": () => (/* binding */ resolveTokenBySlug)\n/* harmony export */ });\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ton/core */ \"./node_modules/@ton/core/dist/index.js\");\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ton_core__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../config */ \"./src/config.ts\");\n/* harmony import */ var _util_account__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/account */ \"./src/util/account.ts\");\n/* harmony import */ var _util_logs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../util/logs */ \"./src/util/logs.ts\");\n/* harmony import */ var _util_metadata__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../util/metadata */ \"./src/util/metadata.ts\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util */ \"./src/api/blockchains/ton/util/index.ts\");\n/* harmony import */ var _util_metadata__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util/metadata */ \"./src/api/blockchains/ton/util/metadata.ts\");\n/* harmony import */ var _util_tonapiio__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./util/tonapiio */ \"./src/api/blockchains/ton/util/tonapiio.ts\");\n/* harmony import */ var _util_tonCore__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./util/tonCore */ \"./src/api/blockchains/ton/util/tonCore.ts\");\n/* harmony import */ var _contracts_JettonWallet__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./contracts/JettonWallet */ \"./src/api/blockchains/ton/contracts/JettonWallet.ts\");\n/* harmony import */ var _common_accounts__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../common/accounts */ \"./src/api/common/accounts.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./constants */ \"./src/api/blockchains/ton/constants.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst KNOWN_TOKENS = [{\n  slug: _config__WEBPACK_IMPORTED_MODULE_1__.TON_TOKEN_SLUG,\n  name: 'Toncoin',\n  cmcSlug: _config__WEBPACK_IMPORTED_MODULE_1__.TON_TOKEN_SLUG,\n  symbol: _config__WEBPACK_IMPORTED_MODULE_1__.TON_SYMBOL,\n  decimals: _config__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_DECIMAL_PLACES\n}];\nconst knownTokens = {};\naddKnownTokens(KNOWN_TOKENS);\nasync function getAccountTokenBalances(accountId) {\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_2__.parseAccountId)(accountId);\n  const address = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_10__.fetchStoredAddress)(accountId);\n  const balancesRaw = await (0,_util_tonapiio__WEBPACK_IMPORTED_MODULE_7__.fetchJettonBalances)(network, address);\n  return balancesRaw.map(balance => parseTokenBalance(network, balance)).filter(Boolean);\n}\nasync function getAddressTokenBalances(address, network) {\n  const balancesRaw = await (0,_util_tonapiio__WEBPACK_IMPORTED_MODULE_7__.fetchJettonBalances)(network, address);\n  return balancesRaw.map(balance => parseTokenBalance(network, balance)).filter(Boolean);\n}\nfunction parseTokenBalance(network, balanceRaw) {\n  if (!balanceRaw.jetton) {\n    return undefined;\n  }\n  try {\n    const {\n      balance,\n      jetton,\n      wallet_address: walletAddress\n    } = balanceRaw;\n    const minterAddress = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_8__.toBase64Address)(jetton.address, true, network);\n    const token = buildTokenByMetadata(minterAddress, jetton);\n    return {\n      slug: token.slug,\n      balance: BigInt(balance),\n      token,\n      jettonWallet: (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_8__.toBase64Address)(walletAddress.address, undefined, network)\n    };\n  } catch (err) {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_3__.logDebugError)('parseTokenBalance', err);\n    return undefined;\n  }\n}\nfunction parseTokenTransaction(network, tx, slug, walletAddress) {\n  const {\n    extraData\n  } = tx;\n  if (!(extraData !== null && extraData !== void 0 && extraData.body)) {\n    return undefined;\n  }\n  const parsedData = (0,_util_metadata__WEBPACK_IMPORTED_MODULE_6__.parseJettonWalletMsgBody)(network, extraData.body);\n  if (!parsedData) {\n    return undefined;\n  }\n  const {\n    operation,\n    jettonAmount,\n    address,\n    comment,\n    encryptedComment\n  } = parsedData;\n  const isIncoming = operation === 'InternalTransfer';\n  return {\n    ...tx,\n    slug,\n    fromAddress: isIncoming ? address !== null && address !== void 0 ? address : tx.fromAddress : walletAddress,\n    toAddress: isIncoming ? walletAddress : address,\n    amount: isIncoming ? jettonAmount : -jettonAmount,\n    comment,\n    encryptedComment,\n    isIncoming\n  };\n}\nasync function buildTokenTransfer(network, slug, fromAddress, toAddress, amount, payload) {\n  const minterAddress = resolveTokenBySlug(slug).minterAddress;\n  const tokenWalletAddress = await (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_8__.resolveTokenWalletAddress)(network, fromAddress, minterAddress);\n  const realMinterAddress = await (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_8__.resolveTokenMinterAddress)(network, tokenWalletAddress);\n  if (minterAddress !== realMinterAddress) {\n    throw new Error('Invalid contract');\n  }\n  const tokenWallet = getTokenWallet(network, tokenWalletAddress);\n  payload = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_8__.buildTokenTransferBody)({\n    tokenAmount: amount,\n    toAddress,\n    forwardAmount: _constants__WEBPACK_IMPORTED_MODULE_11__.TOKEN_TRANSFER_TON_FORWARD_AMOUNT,\n    forwardPayload: payload,\n    responseAddress: fromAddress\n  });\n  return {\n    tokenWallet,\n    amount: _constants__WEBPACK_IMPORTED_MODULE_11__.TOKEN_TRANSFER_TON_AMOUNT,\n    toAddress: tokenWalletAddress,\n    payload\n  };\n}\nfunction resolveTokenBySlug(slug) {\n  return knownTokens[slug];\n}\nfunction findTokenByMinter(minter) {\n  return Object.values(knownTokens).find(token => token.minterAddress === minter);\n}\nfunction getTokenWallet(network, tokenAddress) {\n  return (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_8__.getTonClient)(network).open(new _contracts_JettonWallet__WEBPACK_IMPORTED_MODULE_9__.JettonWallet(_ton_core__WEBPACK_IMPORTED_MODULE_0__.Address.parse(tokenAddress)));\n}\nfunction getKnownTokens() {\n  return knownTokens;\n}\nfunction addKnownTokens(tokens) {\n  for (const token of tokens) {\n    if (token.slug in knownTokens) continue;\n    knownTokens[token.slug] = {\n      ...token,\n      quote: {\n        slug: token.slug,\n        price: 0,\n        priceUsd: 0,\n        percentChange24h: 0\n      }\n    };\n  }\n}\nasync function fetchToken(network, address) {\n  const metadata = await (0,_util_metadata__WEBPACK_IMPORTED_MODULE_6__.fetchJettonMetadata)(network, address);\n  return buildTokenByMetadata(address, metadata);\n}\nfunction buildTokenByMetadata(address, metadata) {\n  const {\n    name,\n    symbol,\n    image,\n    image_data: imageData,\n    decimals\n  } = metadata;\n  return {\n    slug: (0,_util__WEBPACK_IMPORTED_MODULE_5__.buildTokenSlug)(address),\n    name,\n    symbol,\n    decimals: decimals === undefined ? _constants__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_DECIMALS : Number(decimals),\n    minterAddress: address,\n    image: image && (0,_util_metadata__WEBPACK_IMPORTED_MODULE_4__.fixIpfsUrl)(image) || imageData && (0,_util_metadata__WEBPACK_IMPORTED_MODULE_6__.fixBase64ImageData)(imageData) || undefined\n  };\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/blockchains/ton/tokens.ts?");

/***/ }),

/***/ "./src/api/blockchains/ton/transactions.ts":
/*!*************************************************!*\
  !*** ./src/api/blockchains/ton/transactions.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"checkHasTransaction\": () => (/* binding */ checkHasTransaction),\n/* harmony export */   \"checkMultiTransactionDraft\": () => (/* binding */ checkMultiTransactionDraft),\n/* harmony export */   \"checkTransactionDraft\": () => (/* binding */ checkTransactionDraft),\n/* harmony export */   \"decryptComment\": () => (/* binding */ decryptComment),\n/* harmony export */   \"fetchNewestTxId\": () => (/* binding */ fetchNewestTxId),\n/* harmony export */   \"fixTokenActivitiesAddressForm\": () => (/* binding */ fixTokenActivitiesAddressForm),\n/* harmony export */   \"getAccountNewestTxId\": () => (/* binding */ getAccountNewestTxId),\n/* harmony export */   \"getAccountTransactionSlice\": () => (/* binding */ getAccountTransactionSlice),\n/* harmony export */   \"getMergedTransactionSlice\": () => (/* binding */ getMergedTransactionSlice),\n/* harmony export */   \"getTokenTransactionSlice\": () => (/* binding */ getTokenTransactionSlice),\n/* harmony export */   \"resolveTransactionError\": () => (/* binding */ resolveTransactionError),\n/* harmony export */   \"sendSignedMessage\": () => (/* binding */ sendSignedMessage),\n/* harmony export */   \"sendSignedMessages\": () => (/* binding */ sendSignedMessages),\n/* harmony export */   \"submitMultiTransfer\": () => (/* binding */ submitMultiTransfer),\n/* harmony export */   \"submitTransfer\": () => (/* binding */ submitTransfer),\n/* harmony export */   \"waitLastTransfer\": () => (/* binding */ waitLastTransfer),\n/* harmony export */   \"waitUntilTransactionAppears\": () => (/* binding */ waitUntilTransactionAppears)\n/* harmony export */ });\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ton/core */ \"./node_modules/@ton/core/dist/index.js\");\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ton_core__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../types */ \"./src/api/types/index.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../config */ \"./src/config.ts\");\n/* harmony import */ var _util_account__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../util/account */ \"./src/util/account.ts\");\n/* harmony import */ var _util_bigint__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../util/bigint */ \"./src/util/bigint.ts\");\n/* harmony import */ var _util_compareActivities__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../util/compareActivities */ \"./src/util/compareActivities.ts\");\n/* harmony import */ var _util_iteratees__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../util/iteratees */ \"./src/util/iteratees.ts\");\n/* harmony import */ var _util_logs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../util/logs */ \"./src/util/logs.ts\");\n/* harmony import */ var _util_schedulers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../util/schedulers */ \"./src/util/schedulers.ts\");\n/* harmony import */ var _util_stringFormat__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../util/stringFormat */ \"./src/util/stringFormat.ts\");\n/* harmony import */ var _util_withCacheAsync__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../util/withCacheAsync */ \"./src/util/withCacheAsync.ts\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./util */ \"./src/api/blockchains/ton/util/index.ts\");\n/* harmony import */ var _util_apiV3__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./util/apiV3 */ \"./src/api/blockchains/ton/util/apiV3.ts\");\n/* harmony import */ var _util_encryption__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./util/encryption */ \"./src/api/blockchains/ton/util/encryption.ts\");\n/* harmony import */ var _util_metadata__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./util/metadata */ \"./src/api/blockchains/ton/util/metadata.ts\");\n/* harmony import */ var _util_tonCore__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./util/tonCore */ \"./src/api/blockchains/ton/util/tonCore.ts\");\n/* harmony import */ var _common_accounts__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../common/accounts */ \"./src/api/common/accounts.ts\");\n/* harmony import */ var _common_addresses__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../common/addresses */ \"./src/api/common/addresses.ts\");\n/* harmony import */ var _common_helpers__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../common/helpers */ \"./src/api/common/helpers.ts\");\n/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../common/utils */ \"./src/api/common/utils.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../../errors */ \"./src/api/errors.ts\");\n/* harmony import */ var _address__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./address */ \"./src/api/blockchains/ton/address.ts\");\n/* harmony import */ var _auth__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./auth */ \"./src/api/blockchains/ton/auth.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./constants */ \"./src/api/blockchains/ton/constants.ts\");\n/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./tokens */ \"./src/api/blockchains/ton/tokens.ts\");\n/* harmony import */ var _wallet__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./wallet */ \"./src/api/blockchains/ton/wallet.ts\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst DEFAULT_EXPIRE_AT_TIMEOUT_SEC = 60; // 60 sec.\nconst GET_TRANSACTIONS_LIMIT = 50;\nconst GET_TRANSACTIONS_MAX_LIMIT = 100;\nconst WAIT_SEQNO_TIMEOUT = 40000; // 40 sec.\nconst WAIT_SEQNO_PAUSE = 5000; // 5 sec.\nconst WAIT_TRANSACTION_PAUSE = 500; // 0.5 sec.\n\nconst lastTransfers = {\n  mainnet: {},\n  testnet: {}\n};\nconst checkHasTransaction = (0,_util_withCacheAsync__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(async (network, address) => {\n  const transactions = await (0,_util_apiV3__WEBPACK_IMPORTED_MODULE_12__.fetchTransactions)(network, address, 1);\n  return Boolean(transactions.length);\n});\nasync function checkTransactionDraft(accountId, tokenSlug, toAddress, amount, data, stateInit, shouldEncrypt, isBase64Data) {\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_3__.parseAccountId)(accountId);\n  const result = {};\n  try {\n    const resolved = await (0,_address__WEBPACK_IMPORTED_MODULE_21__.resolveAddress)(network, toAddress);\n    if (resolved) {\n      result.addressName = resolved.domain;\n      toAddress = resolved.address;\n    } else {\n      return {\n        ...result,\n        error: _types__WEBPACK_IMPORTED_MODULE_1__.ApiTransactionDraftError.DomainNotResolved\n      };\n    }\n    const {\n      isValid,\n      isUserFriendly,\n      isTestOnly,\n      isBounceable\n    } = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_15__.parseAddress)(toAddress);\n    if (!isValid) {\n      return {\n        ...result,\n        error: _types__WEBPACK_IMPORTED_MODULE_1__.ApiTransactionDraftError.InvalidToAddress\n      };\n    }\n    const regex = /[+=/]/; // Temp check for `isUrlSafe`. Remove after TonWeb fixes the issue\n    const isUrlSafe = !regex.test(toAddress);\n    if (!isUserFriendly || !isUrlSafe || network === 'mainnet' && isTestOnly) {\n      return {\n        ...result,\n        error: _types__WEBPACK_IMPORTED_MODULE_1__.ApiTransactionDraftError.InvalidAddressFormat\n      };\n    }\n    const {\n      isInitialized,\n      isLedgerAllowed\n    } = await (0,_wallet__WEBPACK_IMPORTED_MODULE_25__.getContractInfo)(network, toAddress);\n    if (isBounceable && !isInitialized) {\n      result.isToAddressNew = !(await checkHasTransaction(network, toAddress));\n      if (tokenSlug === _config__WEBPACK_IMPORTED_MODULE_2__.TON_TOKEN_SLUG) {\n        // Force non-bounceable for non-initialized recipients\n        toAddress = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_15__.toBase64Address)(toAddress, false, network);\n      }\n    }\n    result.resolvedAddress = toAddress;\n    const addressInfo = await (0,_common_addresses__WEBPACK_IMPORTED_MODULE_17__.getAddressInfo)((0,_util_tonCore__WEBPACK_IMPORTED_MODULE_15__.toBase64Address)(toAddress, true));\n    if (addressInfo !== null && addressInfo !== void 0 && addressInfo.name) result.addressName = addressInfo.name;\n    if (addressInfo !== null && addressInfo !== void 0 && addressInfo.isScam) result.isScam = addressInfo.isScam;\n    if (amount < 0n) {\n      return {\n        ...result,\n        error: _types__WEBPACK_IMPORTED_MODULE_1__.ApiTransactionDraftError.InvalidAmount\n      };\n    }\n    const wallet = await (0,_wallet__WEBPACK_IMPORTED_MODULE_25__.pickAccountWallet)(accountId);\n    if (!wallet) {\n      return {\n        ...result,\n        error: _types__WEBPACK_IMPORTED_MODULE_1__.ApiCommonError.Unexpected\n      };\n    }\n    if (typeof data === 'string' && isBase64Data) {\n      data = (0,_common_utils__WEBPACK_IMPORTED_MODULE_19__.base64ToBytes)(data);\n    }\n    if (data && typeof data === 'string' && shouldEncrypt) {\n      const toPublicKey = await (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_15__.getWalletPublicKey)(network, toAddress);\n      if (!toPublicKey) {\n        return {\n          ...result,\n          error: _types__WEBPACK_IMPORTED_MODULE_1__.ApiTransactionDraftError.WalletNotInitialized\n        };\n      }\n    }\n    const account = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_16__.fetchStoredAccount)(accountId);\n    const isLedger = !!account.ledger;\n    if (isLedger && !isLedgerAllowed) {\n      return {\n        ...result,\n        error: _types__WEBPACK_IMPORTED_MODULE_1__.ApiTransactionDraftError.UnsupportedHardwareContract\n      };\n    }\n    if (data && typeof data === 'string' && !isBase64Data && !isLedger) {\n      data = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_15__.commentToBytes)(data);\n    }\n    if (tokenSlug === _config__WEBPACK_IMPORTED_MODULE_2__.TON_TOKEN_SLUG) {\n      if (data && isLedger && (typeof data !== 'string' || shouldEncrypt)) {\n        let error;\n        if (typeof data !== 'string') {\n          error = _types__WEBPACK_IMPORTED_MODULE_1__.ApiTransactionDraftError.UnsupportedHardwareOperation;\n        } else if (shouldEncrypt) {\n          error = _types__WEBPACK_IMPORTED_MODULE_1__.ApiTransactionDraftError.EncryptedDataNotSupported;\n        } else {\n          error = !(0,_util_stringFormat__WEBPACK_IMPORTED_MODULE_9__.isAscii)(data) ? _types__WEBPACK_IMPORTED_MODULE_1__.ApiTransactionDraftError.NonAsciiCommentForHardwareOperation : _types__WEBPACK_IMPORTED_MODULE_1__.ApiTransactionDraftError.TooLongCommentForHardwareOperation;\n        }\n        return {\n          ...result,\n          error\n        };\n      }\n      if (data instanceof Uint8Array) {\n        data = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_15__.packBytesAsSnake)(data);\n      }\n    } else {\n      const address = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_16__.fetchStoredAddress)(accountId);\n      const tokenAmount = amount;\n      let tokenWallet;\n      ({\n        tokenWallet,\n        amount,\n        toAddress,\n        payload: data\n      } = await (0,_tokens__WEBPACK_IMPORTED_MODULE_24__.buildTokenTransfer)(network, tokenSlug, address, toAddress, amount, data));\n      const tokenBalance = await tokenWallet.getJettonBalance();\n      if (tokenBalance < tokenAmount) {\n        return {\n          ...result,\n          error: _types__WEBPACK_IMPORTED_MODULE_1__.ApiTransactionDraftError.InsufficientBalance\n        };\n      }\n    }\n    const {\n      transaction\n    } = await signTransaction(network, wallet, toAddress, amount, data, stateInit);\n    const realFee = await calculateFee(network, wallet, transaction, account.isInitialized);\n    result.fee = (0,_util_bigint__WEBPACK_IMPORTED_MODULE_4__.bigintMultiplyToNumber)(realFee, _constants__WEBPACK_IMPORTED_MODULE_23__.FEE_FACTOR);\n    const balance = await (0,_wallet__WEBPACK_IMPORTED_MODULE_25__.getWalletBalance)(network, wallet);\n    if (balance < amount + realFee) {\n      return {\n        ...result,\n        error: _types__WEBPACK_IMPORTED_MODULE_1__.ApiTransactionDraftError.InsufficientBalance\n      };\n    }\n    return result;\n  } catch (err) {\n    return {\n      ...(0,_errors__WEBPACK_IMPORTED_MODULE_20__.handleServerError)(err),\n      ...result\n    };\n  }\n}\nasync function submitTransfer(accountId, password, tokenSlug, toAddress, amount, data, stateInit, shouldEncrypt, isBase64Data) {\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_3__.parseAccountId)(accountId);\n  try {\n    const [wallet, account, keyPair] = await Promise.all([(0,_wallet__WEBPACK_IMPORTED_MODULE_25__.pickAccountWallet)(accountId), (0,_common_accounts__WEBPACK_IMPORTED_MODULE_16__.fetchStoredAccount)(accountId), (0,_auth__WEBPACK_IMPORTED_MODULE_22__.fetchKeyPair)(accountId, password)]);\n    const {\n      address: fromAddress\n    } = account;\n    const {\n      publicKey,\n      secretKey\n    } = keyPair;\n    let encryptedComment;\n    if (typeof data === 'string') {\n      if (!data) {\n        data = undefined;\n      } else if (isBase64Data) {\n        data = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_15__.parseBase64)(data);\n      } else if (shouldEncrypt) {\n        const toPublicKey = await (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_15__.getWalletPublicKey)(network, toAddress);\n        data = await (0,_util_encryption__WEBPACK_IMPORTED_MODULE_13__.encryptMessageComment)(data, publicKey, toPublicKey, secretKey, fromAddress);\n        encryptedComment = Buffer.from(data.slice(4)).toString('base64');\n      } else {\n        data = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_15__.commentToBytes)(data);\n      }\n    }\n    if (tokenSlug === _config__WEBPACK_IMPORTED_MODULE_2__.TON_TOKEN_SLUG) {\n      if (data instanceof Uint8Array) {\n        data = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_15__.packBytesAsSnake)(data);\n      }\n    } else {\n      ({\n        amount,\n        toAddress,\n        payload: data\n      } = await (0,_tokens__WEBPACK_IMPORTED_MODULE_24__.buildTokenTransfer)(network, tokenSlug, fromAddress, toAddress, amount, data));\n    }\n    await waitLastTransfer(network, fromAddress);\n    const {\n      balance\n    } = await (0,_wallet__WEBPACK_IMPORTED_MODULE_25__.getWalletInfo)(network, wallet);\n    const {\n      seqno,\n      transaction\n    } = await signTransaction(network, wallet, toAddress, amount, data, stateInit, secretKey);\n    const fee = await calculateFee(network, wallet, transaction, account.isInitialized);\n    if (balance < amount + fee) {\n      return {\n        error: _types__WEBPACK_IMPORTED_MODULE_1__.ApiTransactionError.InsufficientBalance\n      };\n    }\n    await wallet.send(transaction);\n    updateLastTransfer(network, fromAddress, seqno);\n    return {\n      amount,\n      seqno,\n      encryptedComment,\n      toAddress\n    };\n  } catch (err) {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_7__.logDebugError)('submitTransfer', err);\n    return {\n      error: resolveTransactionError(err)\n    };\n  }\n}\nfunction resolveTransactionError(error) {\n  if (error instanceof _errors__WEBPACK_IMPORTED_MODULE_20__.ApiServerError) {\n    if (error.message.includes('exitcode=35,')) {\n      return _types__WEBPACK_IMPORTED_MODULE_1__.ApiTransactionError.IncorrectDeviceTime;\n    } else if (error.displayError) {\n      return error.displayError;\n    }\n  }\n  return _types__WEBPACK_IMPORTED_MODULE_1__.ApiTransactionError.UnsuccesfulTransfer;\n}\nasync function signTransaction(network, wallet, toAddress, amount, payload, stateInit) {\n  let privateKey = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : new Uint8Array(64);\n  const {\n    seqno\n  } = await (0,_wallet__WEBPACK_IMPORTED_MODULE_25__.getWalletInfo)(network, wallet);\n  if (payload instanceof Uint8Array) {\n    payload = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_15__.packBytesAsSnake)(payload, 0);\n  }\n  const init = stateInit ? {\n    code: stateInit.refs[0],\n    data: stateInit.refs[1]\n  } : undefined;\n  const transaction = wallet.createTransfer({\n    seqno,\n    secretKey: Buffer.from(privateKey),\n    messages: [(0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.internal)({\n      value: amount,\n      to: toAddress,\n      body: payload,\n      init,\n      bounce: (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_15__.parseAddress)(toAddress).isBounceable\n    })],\n    sendMode: _ton_core__WEBPACK_IMPORTED_MODULE_0__.SendMode.PAY_GAS_SEPARATELY + _ton_core__WEBPACK_IMPORTED_MODULE_0__.SendMode.IGNORE_ERRORS\n  });\n  return {\n    seqno,\n    transaction\n  };\n}\nasync function getAccountNewestTxId(accountId) {\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_3__.parseAccountId)(accountId);\n  const address = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_16__.fetchStoredAddress)(accountId);\n  return fetchNewestTxId(network, address);\n}\nasync function getAccountTransactionSlice(accountId, toTxId, fromTxId, limit) {\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_3__.parseAccountId)(accountId);\n  const address = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_16__.fetchStoredAddress)(accountId);\n  let transactions = await (0,_util_apiV3__WEBPACK_IMPORTED_MODULE_12__.fetchTransactions)(network, address, limit !== null && limit !== void 0 ? limit : GET_TRANSACTIONS_LIMIT, toTxId, fromTxId);\n  transactions = await Promise.all(transactions.map(transaction => (0,_util_metadata__WEBPACK_IMPORTED_MODULE_14__.parseWalletTransactionBody)(network, transaction)));\n  return transactions.map(updateTransactionType).map(_common_helpers__WEBPACK_IMPORTED_MODULE_18__.updateTransactionMetadata).map(omitExtraData).map(transactionToActivity);\n}\nasync function getMergedTransactionSlice(accountId, lastTxIds, limit) {\n  // eslint-disable-next-line prefer-const\n  let {\n    toncoin: lastTonTxId,\n    ...tokenLastTxIds\n  } = lastTxIds;\n  const tonTxs = await getAccountTransactionSlice(accountId, lastTonTxId, undefined, limit);\n  if (!tonTxs.length) {\n    return [];\n  }\n  lastTonTxId = tonTxs[tonTxs.length - 1].txId;\n  const lastTonTxLt = (0,_util__WEBPACK_IMPORTED_MODULE_11__.parseTxId)(lastTonTxId).lt;\n  const results = await Promise.all(Object.entries(tokenLastTxIds).map(_ref => {\n    let [slug, lastTxId] = _ref;\n    if (lastTxId && (0,_util__WEBPACK_IMPORTED_MODULE_11__.parseTxId)(lastTxId).lt < lastTonTxLt) {\n      return [];\n    }\n    return getTokenTransactionSlice(accountId, slug, lastTxId, lastTonTxId, GET_TRANSACTIONS_MAX_LIMIT);\n  }));\n  const allTxs = [...tonTxs, ...results.flat()];\n  allTxs.sort((a, b) => (0,_util_compareActivities__WEBPACK_IMPORTED_MODULE_5__.compareActivities)(a, b));\n  return allTxs;\n}\nasync function getTokenTransactionSlice(accountId, tokenSlug, toTxId, fromTxId, limit) {\n  if (tokenSlug === _config__WEBPACK_IMPORTED_MODULE_2__.TON_TOKEN_SLUG) {\n    return getAccountTransactionSlice(accountId, toTxId, fromTxId, limit);\n  }\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_3__.parseAccountId)(accountId);\n  const address = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_16__.fetchStoredAddress)(accountId);\n  const minterAddress = (0,_tokens__WEBPACK_IMPORTED_MODULE_24__.resolveTokenBySlug)(tokenSlug).minterAddress;\n  const tokenWalletAddress = await (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_15__.resolveTokenWalletAddress)(network, address, minterAddress);\n  const transactions = await (0,_util_apiV3__WEBPACK_IMPORTED_MODULE_12__.fetchTransactions)(network, tokenWalletAddress, limit !== null && limit !== void 0 ? limit : GET_TRANSACTIONS_LIMIT, toTxId, fromTxId);\n  return transactions.map(tx => (0,_tokens__WEBPACK_IMPORTED_MODULE_24__.parseTokenTransaction)(network, tx, tokenSlug, address)).filter(Boolean).map(_common_helpers__WEBPACK_IMPORTED_MODULE_18__.updateTransactionMetadata).map(omitExtraData).map(transactionToActivity);\n}\nfunction omitExtraData(tx) {\n  return (0,_util_iteratees__WEBPACK_IMPORTED_MODULE_6__.omit)(tx, ['extraData']);\n}\nfunction updateTransactionType(transaction) {\n  const {\n    comment,\n    amount,\n    extraData\n  } = transaction;\n  const fromAddress = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_15__.toBase64Address)(transaction.fromAddress, true);\n  const toAddress = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_15__.toBase64Address)(transaction.toAddress, true);\n  let type;\n  if ((0,_common_utils__WEBPACK_IMPORTED_MODULE_19__.isKnownStakingPool)(fromAddress) && amount > _config__WEBPACK_IMPORTED_MODULE_2__.ONE_TON) {\n    type = 'unstake';\n  } else if ((0,_common_utils__WEBPACK_IMPORTED_MODULE_19__.isKnownStakingPool)(toAddress)) {\n    if (comment === _constants__WEBPACK_IMPORTED_MODULE_23__.STAKE_COMMENT) {\n      type = 'stake';\n    } else if (comment === _constants__WEBPACK_IMPORTED_MODULE_23__.UNSTAKE_COMMENT) {\n      type = 'unstakeRequest';\n    }\n  } else if (extraData !== null && extraData !== void 0 && extraData.parsedPayload) {\n    const payload = extraData.parsedPayload;\n    if (payload.type === 'tokens:burn' && payload.isLiquidUnstakeRequest) {\n      type = 'unstakeRequest';\n    } else if (payload.type === 'liquid-staking:deposit') {\n      type = 'stake';\n    } else if (payload.type === 'liquid-staking:withdrawal' || payload.type === 'liquid-staking:withdrawal-nft') {\n      type = 'unstake';\n    }\n  }\n  return {\n    ...transaction,\n    type\n  };\n}\nfunction transactionToActivity(transaction) {\n  return {\n    ...transaction,\n    kind: 'transaction',\n    id: transaction.txId\n  };\n}\nasync function checkMultiTransactionDraft(accountId, messages) {\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_3__.parseAccountId)(accountId);\n  const result = {};\n  let totalAmount = 0n;\n  const account = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_16__.fetchStoredAccount)(accountId);\n  try {\n    for (const {\n      toAddress,\n      amount\n    } of messages) {\n      if (amount < 0n) {\n        return {\n          ...result,\n          error: _types__WEBPACK_IMPORTED_MODULE_1__.ApiTransactionDraftError.InvalidAmount\n        };\n      }\n      const isMainnet = network === 'mainnet';\n      const {\n        isValid,\n        isTestOnly\n      } = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_15__.parseAddress)(toAddress);\n      if (!isValid || isMainnet && isTestOnly) {\n        return {\n          ...result,\n          error: _types__WEBPACK_IMPORTED_MODULE_1__.ApiTransactionDraftError.InvalidToAddress\n        };\n      }\n      totalAmount += amount;\n    }\n    const wallet = await (0,_wallet__WEBPACK_IMPORTED_MODULE_25__.pickAccountWallet)(accountId);\n    if (!wallet) {\n      return {\n        ...result,\n        error: _types__WEBPACK_IMPORTED_MODULE_1__.ApiCommonError.Unexpected\n      };\n    }\n    const {\n      balance\n    } = await (0,_wallet__WEBPACK_IMPORTED_MODULE_25__.getWalletInfo)(network, wallet);\n    const {\n      transaction\n    } = await signMultiTransaction(network, wallet, messages);\n    const realFee = await calculateFee(network, wallet, transaction, account.isInitialized);\n    result.totalAmount = totalAmount;\n    result.fee = (0,_util_bigint__WEBPACK_IMPORTED_MODULE_4__.bigintMultiplyToNumber)(realFee, _constants__WEBPACK_IMPORTED_MODULE_23__.FEE_FACTOR);\n    if (balance < totalAmount + realFee) {\n      return {\n        ...result,\n        error: _types__WEBPACK_IMPORTED_MODULE_1__.ApiTransactionDraftError.InsufficientBalance\n      };\n    }\n    return result;\n  } catch (err) {\n    return (0,_errors__WEBPACK_IMPORTED_MODULE_20__.handleServerError)(err);\n  }\n}\nasync function submitMultiTransfer(accountId, password, messages, expireAt) {\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_3__.parseAccountId)(accountId);\n  try {\n    const [wallet, account, privateKey] = await Promise.all([(0,_wallet__WEBPACK_IMPORTED_MODULE_25__.pickAccountWallet)(accountId), (0,_common_accounts__WEBPACK_IMPORTED_MODULE_16__.fetchStoredAccount)(accountId), (0,_auth__WEBPACK_IMPORTED_MODULE_22__.fetchPrivateKey)(accountId, password)]);\n    const {\n      address: fromAddress\n    } = account;\n    let totalAmount = 0n;\n    messages.forEach(message => {\n      totalAmount += BigInt(message.amount);\n    });\n    await waitLastTransfer(network, fromAddress);\n    const {\n      balance\n    } = await (0,_wallet__WEBPACK_IMPORTED_MODULE_25__.getWalletInfo)(network, wallet);\n    const {\n      seqno,\n      transaction,\n      externalMessage\n    } = await signMultiTransaction(network, wallet, messages, privateKey, expireAt);\n    const boc = externalMessage.toBoc().toString('base64');\n    const fee = await calculateFee(network, wallet, transaction, account.isInitialized);\n    if (BigInt(balance) < BigInt(totalAmount) + BigInt(fee)) {\n      return {\n        error: _types__WEBPACK_IMPORTED_MODULE_1__.ApiTransactionError.InsufficientBalance\n      };\n    }\n    await wallet.send(transaction);\n    updateLastTransfer(network, fromAddress, seqno);\n    return {\n      seqno,\n      amount: totalAmount.toString(),\n      messages,\n      boc\n    };\n  } catch (err) {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_7__.logDebugError)('submitMultiTransfer', err);\n    return {\n      error: resolveTransactionError(err)\n    };\n  }\n}\nasync function signMultiTransaction(network, wallet, messages) {\n  let privateKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Uint8Array(64);\n  let expireAt = arguments.length > 4 ? arguments[4] : undefined;\n  const {\n    seqno\n  } = await (0,_wallet__WEBPACK_IMPORTED_MODULE_25__.getWalletInfo)(network, wallet);\n  if (!expireAt) {\n    expireAt = Math.round(Date.now() / 1000) + DEFAULT_EXPIRE_AT_TIMEOUT_SEC;\n  }\n  const preparedMessages = messages.map(message => {\n    const {\n      amount,\n      toAddress,\n      stateInit,\n      isBase64Payload\n    } = message;\n    let {\n      payload\n    } = message;\n    if (isBase64Payload && typeof payload === 'string') {\n      payload = _ton_core__WEBPACK_IMPORTED_MODULE_0__.Cell.fromBase64(payload);\n    }\n    const init = stateInit ? {\n      code: stateInit.refs[0],\n      data: stateInit.refs[1]\n    } : undefined;\n    return (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.internal)({\n      value: amount,\n      to: toAddress,\n      body: payload,\n      // TODO Fix Uint8Array type\n      bounce: (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_15__.parseAddress)(toAddress).isBounceable,\n      init\n    });\n  });\n  const transaction = wallet.createTransfer({\n    seqno,\n    secretKey: Buffer.from(privateKey),\n    messages: preparedMessages,\n    sendMode: _ton_core__WEBPACK_IMPORTED_MODULE_0__.SendMode.PAY_GAS_SEPARATELY + _ton_core__WEBPACK_IMPORTED_MODULE_0__.SendMode.IGNORE_ERRORS,\n    timeout: expireAt\n  });\n  const externalMessage = toExternalMessage(wallet, seqno, transaction);\n  return {\n    seqno,\n    transaction,\n    externalMessage\n  };\n}\nfunction toExternalMessage(contract, seqno, body) {\n  return (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.beginCell)().storeWritable((0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.storeMessage)((0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.external)({\n    to: contract.address,\n    init: seqno === 0 ? contract.init : undefined,\n    body\n  }))).endCell();\n}\nfunction updateLastTransfer(network, address, seqno) {\n  lastTransfers[network][address] = {\n    timestamp: Date.now(),\n    seqno\n  };\n}\nasync function waitLastTransfer(network, address) {\n  const lastTransfer = lastTransfers[network][address];\n  if (!lastTransfer) return;\n  const {\n    seqno,\n    timestamp\n  } = lastTransfer;\n  const waitUntil = timestamp + WAIT_SEQNO_TIMEOUT;\n  const result = await waitIncrementSeqno(network, address, seqno, waitUntil);\n  if (result) {\n    delete lastTransfers[network][address];\n  }\n}\nasync function waitIncrementSeqno(network, address, seqno, waitUntil) {\n  if (!waitUntil) {\n    waitUntil = Date.now() + WAIT_SEQNO_TIMEOUT;\n  }\n  while (Date.now() < waitUntil) {\n    try {\n      const {\n        seqno: currentSeqno\n      } = await (0,_wallet__WEBPACK_IMPORTED_MODULE_25__.getWalletInfo)(network, address);\n      if (currentSeqno > seqno) {\n        return true;\n      }\n      await (0,_util_schedulers__WEBPACK_IMPORTED_MODULE_8__.pause)(WAIT_SEQNO_PAUSE);\n    } catch (err) {\n      (0,_util_logs__WEBPACK_IMPORTED_MODULE_7__.logDebugError)('waitIncrementSeqno', err);\n    }\n  }\n  return false;\n}\nasync function calculateFee(network, wallet, transaction, isInitialized) {\n  // eslint-disable-next-line no-null/no-null\n  const {\n    code = null,\n    data = null\n  } = !isInitialized ? wallet.init : {};\n  const {\n    source_fees: fees\n  } = await (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_15__.getTonClient)(network).estimateExternalMessageFee(wallet.address, {\n    body: transaction,\n    initCode: code,\n    initData: data,\n    ignoreSignature: true\n  });\n  return BigInt(fees.in_fwd_fee + fees.storage_fee + fees.gas_fee + fees.fwd_fee);\n}\nasync function sendSignedMessage(accountId, message) {\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_3__.parseAccountId)(accountId);\n  const {\n    address: fromAddress,\n    publicKey,\n    version\n  } = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_16__.fetchStoredAccount)(accountId);\n  const wallet = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_15__.getTonWalletContract)(publicKey, version);\n  const client = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_15__.getTonClient)(network);\n  const contract = client.open(wallet);\n  const {\n    base64,\n    seqno\n  } = message;\n  await contract.send(_ton_core__WEBPACK_IMPORTED_MODULE_0__.Cell.fromBase64(base64));\n  updateLastTransfer(network, fromAddress, seqno);\n}\nasync function sendSignedMessages(accountId, messages) {\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_3__.parseAccountId)(accountId);\n  const {\n    address: fromAddress,\n    publicKey,\n    version\n  } = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_16__.fetchStoredAccount)(accountId);\n  const wallet = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_15__.getTonWalletContract)(publicKey, version);\n  const client = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_15__.getTonClient)(network);\n  const contract = client.open(wallet);\n  const attempts = _constants__WEBPACK_IMPORTED_MODULE_23__.ATTEMPTS + messages.length;\n  let index = 0;\n  let attempt = 0;\n  const firstExternalMessage = toExternalMessage(contract, messages[0].seqno, _ton_core__WEBPACK_IMPORTED_MODULE_0__.Cell.fromBase64(messages[0].base64));\n  while (index < messages.length && attempt < attempts) {\n    const {\n      base64,\n      seqno\n    } = messages[index];\n    try {\n      await waitLastTransfer(network, fromAddress);\n      await contract.send(_ton_core__WEBPACK_IMPORTED_MODULE_0__.Cell.fromBase64(base64));\n      updateLastTransfer(network, fromAddress, seqno);\n      index++;\n    } catch (err) {\n      (0,_util_logs__WEBPACK_IMPORTED_MODULE_7__.logDebugError)('sendSignedMessages', err);\n    }\n    attempt++;\n  }\n  return {\n    successNumber: index,\n    externalMessage: firstExternalMessage\n  };\n}\nasync function decryptComment(accountId, encryptedComment, fromAddress, password) {\n  const keyPair = await (0,_auth__WEBPACK_IMPORTED_MODULE_22__.fetchKeyPair)(accountId, password);\n  if (!keyPair) {\n    return undefined;\n  }\n  const {\n    secretKey,\n    publicKey\n  } = keyPair;\n  const buffer = Buffer.from(encryptedComment, 'base64');\n  return (0,_util_encryption__WEBPACK_IMPORTED_MODULE_13__.decryptMessageComment)(buffer, publicKey, secretKey, fromAddress);\n}\nasync function waitUntilTransactionAppears(network, address, txId) {\n  const {\n    lt\n  } = (0,_util__WEBPACK_IMPORTED_MODULE_11__.parseTxId)(txId);\n  if (lt === 0) {\n    return;\n  }\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const latestTxId = await (0,_util_apiV3__WEBPACK_IMPORTED_MODULE_12__.fetchLatestTxId)(network, address);\n    if (latestTxId && (0,_util__WEBPACK_IMPORTED_MODULE_11__.parseTxId)(latestTxId).lt >= lt) {\n      return;\n    }\n    await (0,_util_schedulers__WEBPACK_IMPORTED_MODULE_8__.pause)(WAIT_TRANSACTION_PAUSE);\n  }\n}\nasync function fetchNewestTxId(network, address) {\n  const transactions = await (0,_util_apiV3__WEBPACK_IMPORTED_MODULE_12__.fetchTransactions)(network, address, 1);\n  if (!transactions.length) {\n    return undefined;\n  }\n  return transactions[0].txId;\n}\nasync function fixTokenActivitiesAddressForm(network, activities) {\n  const tokenAddresses = new Set();\n  for (const activity of activities) {\n    if (activity.kind === 'transaction' && activity.slug !== _config__WEBPACK_IMPORTED_MODULE_2__.TON_TOKEN_SLUG) {\n      tokenAddresses.add(activity.fromAddress);\n      tokenAddresses.add(activity.toAddress);\n    }\n  }\n  if (!tokenAddresses.size) {\n    return;\n  }\n  const addressBook = await (0,_util_apiV3__WEBPACK_IMPORTED_MODULE_12__.fetchAddressBook)(network, Array.from(tokenAddresses));\n  for (const activity of activities) {\n    if (activity.kind === 'transaction' && activity.slug !== _config__WEBPACK_IMPORTED_MODULE_2__.TON_TOKEN_SLUG) {\n      activity.fromAddress = addressBook[activity.fromAddress].user_friendly;\n      activity.toAddress = addressBook[activity.toAddress].user_friendly;\n    }\n  }\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/blockchains/ton/transactions.ts?");

/***/ }),

/***/ "./src/api/blockchains/ton/util/TonClient.ts":
/*!***************************************************!*\
  !*** ./src/api/blockchains/ton/util/TonClient.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TonClient\": () => (/* binding */ TonClient)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ton_ton_dist_client_TonClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ton/ton/dist/client/TonClient */ \"./node_modules/@ton/ton/dist/client/TonClient.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../config */ \"./src/config.ts\");\n/* harmony import */ var _lib_axios_retry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../lib/axios-retry */ \"./src/lib/axios-retry/index.js\");\n/* harmony import */ var _lib_axios_retry__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lib_axios_retry__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _util_fetch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../util/fetch */ \"./src/util/fetch.ts\");\n/* harmony import */ var _util_logs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../util/logs */ \"./src/util/logs.ts\");\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\n\n\n_lib_axios_retry__WEBPACK_IMPORTED_MODULE_3___default()((axios__WEBPACK_IMPORTED_MODULE_0___default()), {\n  retries: _config__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_RETRIES,\n  retryDelay: retryCount => {\n    return retryCount * _config__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_ERROR_PAUSE;\n  },\n  onRetry: (retryNumber, _, requestConfig) => {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_5__.logDebug)(`Retry request #${retryNumber}:`, requestConfig.url);\n  }\n});\nclass TonClient extends _ton_ton_dist_client_TonClient__WEBPACK_IMPORTED_MODULE_1__.TonClient {\n  constructor(parameters) {\n    super(parameters);\n    _defineProperty(this, \"initParameters\", void 0);\n    this.initParameters = parameters;\n  }\n  getWalletInfo(address) {\n    return this.callRpc('getWalletInformation', {\n      address\n    });\n  }\n  getAddressInfo(address) {\n    return this.callRpc('getAddressInformation', {\n      address\n    });\n  }\n  callRpc(method, params) {\n    return this.sendRequest(this.parameters.endpoint, {\n      id: 1,\n      jsonrpc: '2.0',\n      method,\n      params\n    });\n  }\n  async sendRequest(apiUrl, request) {\n    const method = request.method;\n    const headers = {\n      ...this.initParameters.headers,\n      'Content-Type': 'application/json'\n    };\n    if (this.parameters.apiKey) {\n      headers['X-API-Key'] = this.parameters.apiKey;\n    }\n    const body = JSON.stringify(request);\n    const response = await (0,_util_fetch__WEBPACK_IMPORTED_MODULE_4__.fetchWithRetry)(apiUrl, {\n      method: 'POST',\n      body,\n      headers\n    }, {\n      conditionFn: (message, statusCode) => isNotTemporaryError(method, message, statusCode)\n    });\n    const data = await response.json();\n    return data.result;\n  }\n}\nfunction isNotTemporaryError(method, message, statusCode) {\n  return Boolean(statusCode === 422 || method === 'sendBoc' && (message === null || message === void 0 ? void 0 : message.includes('exitcode=')));\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/blockchains/ton/util/TonClient.ts?");

/***/ }),

/***/ "./src/api/blockchains/ton/util/apiV3.ts":
/*!***********************************************!*\
  !*** ./src/api/blockchains/ton/util/apiV3.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"fetchAddressBook\": () => (/* binding */ fetchAddressBook),\n/* harmony export */   \"fetchLatestTxId\": () => (/* binding */ fetchLatestTxId),\n/* harmony export */   \"fetchTransactions\": () => (/* binding */ fetchTransactions)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../config */ \"./src/config.ts\");\n/* harmony import */ var _util_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../util/fetch */ \"./src/util/fetch.ts\");\n/* harmony import */ var _util_iteratees__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../util/iteratees */ \"./src/util/iteratees.ts\");\n/* harmony import */ var _environment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../environment */ \"./src/api/environment.ts\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index */ \"./src/api/blockchains/ton/util/index.ts\");\n/* harmony import */ var _tonCore__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tonCore */ \"./src/api/blockchains/ton/util/tonCore.ts\");\n\n\n\n\n\n\nconst ADDRESS_BOOK_CHUNK_SIZE = 128;\nasync function fetchTransactions(network, address, limit, toTxId, fromTxId) {\n  const fromLt = fromTxId ? (0,_index__WEBPACK_IMPORTED_MODULE_4__.parseTxId)(fromTxId).lt.toString() : undefined;\n  const toLt = toTxId ? (0,_index__WEBPACK_IMPORTED_MODULE_4__.parseTxId)(toTxId).lt.toString() : undefined;\n  const data = await callApiV3(network, '/transactions', {\n    account: address,\n    limit,\n    start_lt: fromLt,\n    end_lt: toLt,\n    sort: 'desc'\n  });\n  let {\n    transactions: rawTransactions\n  } = data;\n  const {\n    address_book: addressBook\n  } = data;\n  if (!rawTransactions.length) {\n    return [];\n  }\n  if (limit > 1) {\n    var _rawTransactions$;\n    if (fromLt && rawTransactions[rawTransactions.length - 1].lt === fromLt) {\n      rawTransactions.pop();\n    }\n    if (toLt && ((_rawTransactions$ = rawTransactions[0]) === null || _rawTransactions$ === void 0 ? void 0 : _rawTransactions$.lt) === toLt) {\n      rawTransactions = rawTransactions.slice(1);\n    }\n  }\n  return rawTransactions.map(rawTx => parseRawTransaction(network, rawTx, addressBook)).flat();\n}\nfunction parseRawTransaction(network, rawTx, addressBook) {\n  const {\n    now,\n    lt,\n    hash,\n    total_fees: fee\n  } = rawTx;\n  const txId = (0,_index__WEBPACK_IMPORTED_MODULE_4__.stringifyTxId)({\n    lt,\n    hash\n  });\n  const timestamp = now * 1000;\n  const isIncoming = !!rawTx.in_msg.source;\n  const msgs = isIncoming ? [rawTx.in_msg] : rawTx.out_msgs;\n  if (!msgs.length) return [];\n  return msgs.map((msg, i) => {\n    const {\n      source,\n      destination,\n      value\n    } = msg;\n    const fromAddress = addressBook[source].user_friendly;\n    const toAddress = addressBook[destination].user_friendly;\n    const normalizedAddress = (0,_tonCore__WEBPACK_IMPORTED_MODULE_5__.toBase64Address)(isIncoming ? source : destination, true, network);\n    return {\n      txId: msgs.length > 1 ? `${txId}:${i + 1}` : txId,\n      timestamp,\n      isIncoming,\n      fromAddress,\n      toAddress,\n      amount: isIncoming ? BigInt(value) : -BigInt(value),\n      slug: _config__WEBPACK_IMPORTED_MODULE_0__.TON_TOKEN_SLUG,\n      fee: BigInt(fee),\n      normalizedAddress,\n      extraData: {\n        body: getRawBody(msg)\n      }\n    };\n  });\n}\nasync function fetchLatestTxId(network, address) {\n  const {\n    transactions\n  } = await callApiV3(network, '/transactions', {\n    account: address,\n    limit: 1,\n    sort: 'desc'\n  });\n  if (!transactions.length) {\n    return undefined;\n  }\n  const {\n    lt,\n    hash\n  } = transactions[0];\n  return (0,_index__WEBPACK_IMPORTED_MODULE_4__.stringifyTxId)({\n    lt,\n    hash\n  });\n}\nfunction getRawBody(msg) {\n  if (!msg.message_content) return undefined;\n  return msg.message_content.body;\n}\nasync function fetchAddressBook(network, addresses) {\n  const chunks = (0,_util_iteratees__WEBPACK_IMPORTED_MODULE_2__.split)(addresses, ADDRESS_BOOK_CHUNK_SIZE);\n  const results = await Promise.all(chunks.map(chunk => {\n    return callApiV3(network, '/addressBook', {\n      address: chunk\n    });\n  }));\n  return results.reduce((acc, value) => {\n    return Object.assign(acc, value);\n  }, {});\n}\nfunction callApiV3(network, path, data) {\n  const {\n    apiHeaders,\n    tonhttpapiMainnetKey,\n    tonhttpapiTestnetKey\n  } = (0,_environment__WEBPACK_IMPORTED_MODULE_3__.getEnvironment)();\n  const baseUrl = network === 'testnet' ? _config__WEBPACK_IMPORTED_MODULE_0__.TONHTTPAPI_V3_TESTNET_API_URL : _config__WEBPACK_IMPORTED_MODULE_0__.TONHTTPAPI_V3_MAINNET_API_URL;\n  const apiKey = network === 'testnet' ? tonhttpapiTestnetKey : tonhttpapiMainnetKey;\n  return (0,_util_fetch__WEBPACK_IMPORTED_MODULE_1__.fetchJson)(`${baseUrl}${path}`, data, {\n    headers: {\n      ...(apiKey && {\n        'X-Api-Key': apiKey\n      }),\n      ...apiHeaders\n    }\n  });\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/blockchains/ton/util/apiV3.ts?");

/***/ }),

/***/ "./src/api/blockchains/ton/util/dns.ts":
/*!*********************************************!*\
  !*** ./src/api/blockchains/ton/util/dns.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DnsCategory\": () => (/* binding */ DnsCategory),\n/* harmony export */   \"dnsResolve\": () => (/* binding */ dnsResolve)\n/* harmony export */ });\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ton/core */ \"./node_modules/@ton/core/dist/index.js\");\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ton_core__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/utils */ \"./src/api/common/utils.ts\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/* Source https://github.com/toncenter/tonweb/blob/master/src/contract/dns/DnsUtils.js */\n\n\n\nlet DnsCategory = /*#__PURE__*/function (DnsCategory) {\n  DnsCategory[\"DnsNextResolver\"] = \"dns_next_resolver\";\n  DnsCategory[\"Wallet\"] = \"wallet\";\n  DnsCategory[\"Site\"] = \"site\";\n  DnsCategory[\"BagId\"] = \"storage\";\n  return DnsCategory;\n}({});\nasync function categoryToBigInt(category) {\n  if (!category) return 0n; // all categories\n  const categoryBytes = new TextEncoder().encode(category);\n  const categoryHashHex = Buffer.from(await (0,_common_utils__WEBPACK_IMPORTED_MODULE_1__.sha256)(categoryBytes)).toString('hex');\n  return BigInt(`0x${categoryHashHex}`);\n}\nfunction parseSmartContractAddressImpl(cell, prefix0, prefix1) {\n  const slice = cell.asSlice();\n  const byte0 = slice.loadUint(8);\n  const byte1 = slice.loadUint(8);\n  if (byte0 !== prefix0 || byte1 !== prefix1) {\n    throw new Error('Invalid dns record value prefix');\n  }\n  return parseAddress(slice);\n}\nfunction parseSmartContractAddressRecord(cell) {\n  return parseSmartContractAddressImpl(cell, 0x9f, 0xd3);\n}\nfunction parseNextResolverRecord(cell) {\n  return parseSmartContractAddressImpl(cell, 0xba, 0x93);\n}\nfunction parseStorageBagIdRecord(cell) {\n  const slice = cell.asSlice();\n  const byte0 = slice.loadUint(8);\n  const byte1 = slice.loadUint(8);\n  if (byte0 !== 0x74 || byte1 !== 0x73) {\n    throw new Error('Invalid dns record value prefix');\n  }\n  const buffer = slice.loadBuffer(4);\n  return buffer.toString('hex');\n}\nfunction parseSiteRecord(cell) {\n  const slice = cell.asSlice();\n  const byte0 = slice.loadUint(8);\n  const byte1 = slice.loadUint(8);\n  if (byte0 === 0xad || byte1 === 0x01) {\n    return parseAdnlAddressRecord(cell);\n  } else {\n    return parseStorageBagIdRecord(cell);\n  }\n}\nfunction parseAdnlAddressRecord(cell) {\n  const slice = cell.asSlice();\n  const byte0 = slice.loadUint(8);\n  const byte1 = slice.loadUint(8);\n  if (byte0 !== 0xad || byte1 !== 0x01) {\n    throw new Error('Invalid dns record value prefix');\n  }\n  const buffer = slice.loadBuffer(4);\n  return buffer.toString('hex');\n}\nasync function dnsResolveImpl(client, dnsAddress, rawDomainBytes, category, oneStep) {\n  const len = rawDomainBytes.length * 8;\n  const domainCell = new _ton_core__WEBPACK_IMPORTED_MODULE_0__.Builder().storeBuffer(Buffer.from(rawDomainBytes)).asCell();\n  const categoryBN = await categoryToBigInt(category);\n  const {\n    stack\n  } = await client.callGetMethod(_ton_core__WEBPACK_IMPORTED_MODULE_0__.Address.parse(dnsAddress), 'dnsresolve', [{\n    type: 'slice',\n    cell: domainCell\n  }, {\n    type: 'int',\n    value: BigInt(categoryBN.toString())\n  }]);\n  const resultLen = stack.readNumber();\n  let cell;\n  try {\n    cell = stack.readCell();\n  } catch (err) {\n    // Do nothing\n  }\n  if (resultLen === 0) {\n    return undefined; // domain cannot be resolved\n  }\n  if (resultLen % 8 !== 0) {\n    throw new Error('domain split not at a component boundary');\n  }\n  // if (rawDomainBytes[resultLen] !== 0) {\n  //     throw new Error('domain split not at a component boundary');\n  // }\n  if (resultLen > len) {\n    throw new Error(`invalid response ${resultLen}/${len}`);\n  } else if (resultLen === len) {\n    if (category === DnsCategory.DnsNextResolver) {\n      return cell ? parseNextResolverRecord(cell) : undefined;\n    } else if (category === DnsCategory.Wallet) {\n      return cell ? parseSmartContractAddressRecord(cell) : undefined;\n    } else if (category === DnsCategory.Site) {\n      return cell ? parseSiteRecord(cell) : undefined;\n    } else if (category === DnsCategory.BagId) {\n      return cell ? parseStorageBagIdRecord(cell) : undefined;\n    } else {\n      return cell;\n    }\n  } else if (!cell) {\n    return undefined; // domain cannot be resolved\n  } else {\n    const nextAddress = parseNextResolverRecord(cell);\n    if (oneStep) {\n      if (category === DnsCategory.DnsNextResolver) {\n        return nextAddress;\n      } else {\n        return undefined;\n      }\n    } else {\n      return dnsResolveImpl(client, nextAddress.toString(), rawDomainBytes.slice(resultLen / 8), category, false);\n    }\n  }\n}\nfunction domainToBytes(domain) {\n  if (!domain || !domain.length) {\n    throw new Error('empty domain');\n  }\n  if (domain === '.') {\n    return new Uint8Array([0]);\n  }\n  domain = domain.toLowerCase();\n  for (let i = 0; i < domain.length; i++) {\n    if (domain.charCodeAt(i) <= 32) {\n      throw new Error('bytes in range 0..32 are not allowed in domain names');\n    }\n  }\n  for (let i = 0; i < domain.length; i++) {\n    const s = domain.substring(i, i + 1);\n    for (let c = 127; c <= 159; c++) {\n      // another control codes range\n      if (s === String.fromCharCode(c)) {\n        throw new Error('bytes in range 127..159 are not allowed in domain names');\n      }\n    }\n  }\n  const arr = domain.split('.');\n  arr.forEach(part => {\n    if (!part.length) {\n      throw new Error('domain name cannot have an empty component');\n    }\n  });\n  let rawDomain = `${arr.reverse().join('\\0')}\\0`;\n  if (rawDomain.length < 126) {\n    rawDomain = `\\0${rawDomain}`;\n  }\n  return new TextEncoder().encode(rawDomain);\n}\nfunction dnsResolve(client, rootDnsAddress, domain, category, oneStep) {\n  const rawDomainBytes = domainToBytes(domain);\n  return dnsResolveImpl(client, rootDnsAddress, rawDomainBytes, category, oneStep);\n}\nfunction parseAddress(slice) {\n  slice.loadUint(3);\n  let n = slice.loadUintBig(8);\n  if (n > 127n) {\n    // Maybe it's not necessary?\n    n -= 256n;\n  }\n  const hashPart = slice.loadUintBig(256);\n  if (`${n.toString(10)}:${hashPart.toString(16)}` === '0:0') {\n    return undefined;\n  }\n  const s = `${n.toString(10)}:${hashPart.toString(16).padStart(64, '0')}`;\n  return _ton_core__WEBPACK_IMPORTED_MODULE_0__.Address.parse(s);\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/blockchains/ton/util/dns.ts?");

/***/ }),

/***/ "./src/api/blockchains/ton/util/encryption.ts":
/*!****************************************************!*\
  !*** ./src/api/blockchains/ton/util/encryption.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"decryptData\": () => (/* binding */ decryptData),\n/* harmony export */   \"decryptMessageComment\": () => (/* binding */ decryptMessageComment),\n/* harmony export */   \"encryptData\": () => (/* binding */ encryptData),\n/* harmony export */   \"encryptMessageComment\": () => (/* binding */ encryptMessageComment)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants */ \"./src/api/blockchains/ton/constants.ts\");\n/* harmony import */ var _tonCore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tonCore */ \"./src/api/blockchains/ton/util/tonCore.ts\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n// This JS library implements TON message comment encryption and decryption for Web\n// Reference C++ code - SimpleEncryptionV2 - https://github.com/ton-blockchain/ton/blob/cc0eb453cb3bf69f92693160103d33112856c056/tonlib/tonlib/keys/SimpleEncryption.cpp#L110\n// Dependencies:\n// - TonWeb 0.0.60\n// - aes-js - 3.1.2 - https://github.com/ricmoo/aes-js/releases/tag/v3.1.2 - for aes-cbc without padding\n// - noble-ed25519 - 1.7.3 - // https://github.com/paulmillr/noble-ed25519/releases/tag/1.7.3 - for getSharedKey\n\n\n\nconst ed25519 = __webpack_require__(/*! ../../../../lib/noble-ed25519 */ \"./src/lib/noble-ed25519/index.js\");\nconst aesjs = __webpack_require__(/*! ../../../../lib/aes-js */ \"./src/lib/aes-js/index.js\");\nasync function hmacSha512(key, data) {\n  const hmacAlgo = {\n    name: 'HMAC',\n    hash: 'SHA-512'\n  };\n  const hmacKey = await crypto.subtle.importKey('raw', key, hmacAlgo, false, ['sign']);\n  const signature = await crypto.subtle.sign(hmacAlgo, hmacKey, data);\n  const result = new Uint8Array(signature);\n  if (result.length !== 512 / 8) throw new Error();\n  return result;\n}\nfunction getAesCbcState(hash) {\n  if (hash.length < 48) throw new Error();\n  const key = hash.slice(0, 32);\n  const iv = hash.slice(32, 32 + 16);\n\n  // Note that native crypto.subtle AES-CBC not suitable here because\n  // even if the data IS a multiple of 16 bytes, padding will still be added\n  // So we use aes-js\n\n  // eslint-disable-next-line new-cap\n  return new aesjs.ModeOfOperation.cbc(key, iv);\n}\nfunction getRandomPrefix(dataLength, minPadding) {\n  // eslint-disable-next-line no-bitwise\n  const prefixLength = (minPadding + 15 + dataLength & -16) - dataLength;\n  const prefix = crypto.getRandomValues(new Uint8Array(prefixLength));\n  prefix[0] = prefixLength;\n  if ((prefixLength + dataLength) % 16 !== 0) throw new Error();\n  return prefix;\n}\nfunction combineSecrets(a, b) {\n  return hmacSha512(a, b);\n}\nasync function encryptDataWithPrefix(data, sharedSecret, salt) {\n  if (data.length % 16 !== 0) throw new Error();\n  const dataHash = await combineSecrets(salt, data);\n  const msgKey = dataHash.slice(0, 16);\n  const res = new Uint8Array(data.length + 16);\n  res.set(msgKey, 0);\n  const cbcStateSecret = await combineSecrets(sharedSecret, msgKey);\n  const encrypted = (await getAesCbcState(cbcStateSecret)).encrypt(data);\n  res.set(encrypted, 16);\n  return res;\n}\nasync function encryptDataImpl(data, sharedSecret, salt) {\n  const prefix = await getRandomPrefix(data.length, 16);\n  const combined = new Uint8Array(prefix.length + data.length);\n  combined.set(prefix, 0);\n  combined.set(data, prefix.length);\n  return encryptDataWithPrefix(combined, sharedSecret, salt);\n}\nasync function encryptData(data, myPublicKey, theirPublicKey, privateKey, salt) {\n  const sharedSecret = await ed25519.getSharedSecret(privateKey, theirPublicKey);\n  const encrypted = await encryptDataImpl(data, sharedSecret, salt);\n  const prefixedEncrypted = new Uint8Array(myPublicKey.length + encrypted.length);\n  for (let i = 0; i < myPublicKey.length; i++) {\n    // eslint-disable-next-line no-bitwise\n    prefixedEncrypted[i] = theirPublicKey[i] ^ myPublicKey[i];\n  }\n  prefixedEncrypted.set(encrypted, myPublicKey.length);\n  return prefixedEncrypted;\n}\nasync function encryptMessageComment(comment, myPublicKey, theirPublicKey, myPrivateKey, senderAddress) {\n  if (!comment || !comment.length) throw new Error('empty comment');\n  if (myPrivateKey.length === 64) {\n    myPrivateKey = myPrivateKey.slice(0, 32); // convert nacl private key\n  }\n  const commentBytes = new TextEncoder().encode(comment);\n  const salt = new TextEncoder().encode((0,_tonCore__WEBPACK_IMPORTED_MODULE_1__.toBase64Address)(senderAddress, true));\n  const encryptedBytes = await encryptData(commentBytes, myPublicKey, theirPublicKey, myPrivateKey, salt);\n  const payload = new Uint8Array(encryptedBytes.length + 4);\n  const buffer = Buffer.alloc(4);\n  buffer.writeUInt32BE(_constants__WEBPACK_IMPORTED_MODULE_0__.OpCode.Encrypted);\n  payload.set(buffer, 0);\n  payload.set(encryptedBytes, 4);\n  return payload;\n}\nasync function doDecrypt(cbcStateSecret, msgKey, encryptedData, salt) {\n  const decryptedData = (await getAesCbcState(cbcStateSecret)).decrypt(encryptedData);\n  const dataHash = await combineSecrets(salt, decryptedData);\n  const gotMsgKey = dataHash.slice(0, 16);\n  if (msgKey.join(',') !== gotMsgKey.join(',')) {\n    throw new Error('Failed to decrypt: hash mismatch');\n  }\n  const prefixLength = decryptedData[0];\n  if (prefixLength > decryptedData.length || prefixLength < 16) {\n    throw new Error('Failed to decrypt: invalid prefix size');\n  }\n  return decryptedData.slice(prefixLength);\n}\nasync function decryptDataImpl(encryptedData, sharedSecret, salt) {\n  if (encryptedData.length < 16) throw new Error('Failed to decrypt: data is too small');\n  if (encryptedData.length % 16 !== 0) throw new Error('Failed to decrypt: data size is not divisible by 16');\n  const msgKey = encryptedData.slice(0, 16);\n  const data = encryptedData.slice(16);\n  const cbcStateSecret = await combineSecrets(sharedSecret, msgKey);\n  const res = await doDecrypt(cbcStateSecret, msgKey, data, salt);\n  return res;\n}\nasync function decryptData(data, publicKey, privateKey, salt) {\n  if (data.length < publicKey.length) {\n    throw new Error('Failed to decrypt: data is too small');\n  }\n  const theirPublicKey = new Uint8Array(publicKey.length);\n  for (let i = 0; i < publicKey.length; i++) {\n    // eslint-disable-next-line no-bitwise\n    theirPublicKey[i] = data[i] ^ publicKey[i];\n  }\n  const sharedSecret = await ed25519.getSharedSecret(privateKey, theirPublicKey);\n  const decrypted = await decryptDataImpl(data.slice(publicKey.length), sharedSecret, salt);\n  return decrypted;\n}\nasync function decryptMessageComment(encryptedData, myPublicKey, myPrivateKey, senderAddress) {\n  if (myPrivateKey.length === 64) {\n    myPrivateKey = myPrivateKey.slice(0, 32); // convert nacl private key\n  }\n  const salt = new TextEncoder().encode((0,_tonCore__WEBPACK_IMPORTED_MODULE_1__.toBase64Address)(senderAddress, true));\n  const decryptedBytes = await decryptData(encryptedData, myPublicKey, myPrivateKey, salt);\n  return new TextDecoder().decode(decryptedBytes);\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/blockchains/ton/util/encryption.ts?");

/***/ }),

/***/ "./src/api/blockchains/ton/util/index.ts":
/*!***********************************************!*\
  !*** ./src/api/blockchains/ton/util/index.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"buildTokenSlug\": () => (/* binding */ buildTokenSlug),\n/* harmony export */   \"cloneDeep\": () => (/* binding */ cloneDeep),\n/* harmony export */   \"parseTxId\": () => (/* binding */ parseTxId),\n/* harmony export */   \"stringifyTxId\": () => (/* binding */ stringifyTxId)\n/* harmony export */ });\n/* harmony import */ var _util_bigint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../util/bigint */ \"./src/util/bigint.ts\");\n\nfunction cloneDeep(value) {\n  return JSON.parse(JSON.stringify(value), _util_bigint__WEBPACK_IMPORTED_MODULE_0__.bigintReviver);\n}\nfunction stringifyTxId(_ref) {\n  let {\n    lt,\n    hash\n  } = _ref;\n  return `${lt}:${hash}`;\n}\nfunction parseTxId(txId) {\n  const [lt, hash] = txId.split(':');\n  return {\n    lt: Number(lt),\n    hash\n  };\n}\nfunction buildTokenSlug(minterAddress) {\n  const addressPart = minterAddress.replace(/[^a-z\\d]/gi, '').slice(0, 10);\n  return `ton-${addressPart}`.toLowerCase();\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/blockchains/ton/util/index.ts?");

/***/ }),

/***/ "./src/api/blockchains/ton/util/metadata.ts":
/*!**************************************************!*\
  !*** ./src/api/blockchains/ton/util/metadata.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"fetchJettonMetadata\": () => (/* binding */ fetchJettonMetadata),\n/* harmony export */   \"fetchJettonOffchainMetadata\": () => (/* binding */ fetchJettonOffchainMetadata),\n/* harmony export */   \"fixBase64ImageData\": () => (/* binding */ fixBase64ImageData),\n/* harmony export */   \"parseJettonOnchainMetadata\": () => (/* binding */ parseJettonOnchainMetadata),\n/* harmony export */   \"parseJettonWalletMsgBody\": () => (/* binding */ parseJettonWalletMsgBody),\n/* harmony export */   \"parsePayloadBase64\": () => (/* binding */ parsePayloadBase64),\n/* harmony export */   \"parsePayloadSlice\": () => (/* binding */ parsePayloadSlice),\n/* harmony export */   \"parseWalletTransactionBody\": () => (/* binding */ parseWalletTransactionBody),\n/* harmony export */   \"readSnakeBytes\": () => (/* binding */ readSnakeBytes)\n/* harmony export */ });\n/* harmony import */ var _ton_core_dist_boc_BitReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ton/core/dist/boc/BitReader */ \"./node_modules/@ton/core/dist/boc/BitReader.js\");\n/* harmony import */ var _ton_core_dist_boc_BitString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ton/core/dist/boc/BitString */ \"./node_modules/@ton/core/dist/boc/BitString.js\");\n/* harmony import */ var _ton_core_dist_boc_BitString__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_ton_core_dist_boc_BitString__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ton_core_dist_boc_Builder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ton/core/dist/boc/Builder */ \"./node_modules/@ton/core/dist/boc/Builder.js\");\n/* harmony import */ var _ton_core_dist_boc_Cell__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ton/core/dist/boc/Cell */ \"./node_modules/@ton/core/dist/boc/Cell.js\");\n/* harmony import */ var _ton_core_dist_boc_Cell__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_ton_core_dist_boc_Cell__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _ton_core_dist_boc_Slice__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ton/core/dist/boc/Slice */ \"./node_modules/@ton/core/dist/boc/Slice.js\");\n/* harmony import */ var _ton_core_dist_boc_Slice__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_ton_core_dist_boc_Slice__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _ton_core_dist_dict_Dictionary__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ton/core/dist/dict/Dictionary */ \"./node_modules/@ton/core/dist/dict/Dictionary.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../config */ \"./src/config.ts\");\n/* harmony import */ var _util_iteratees__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../util/iteratees */ \"./src/util/iteratees.ts\");\n/* harmony import */ var _util_logs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../../util/logs */ \"./src/util/logs.ts\");\n/* harmony import */ var _util_metadata__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../../util/metadata */ \"./src/util/metadata.ts\");\n/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../common/utils */ \"./src/api/common/utils.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../constants */ \"./src/api/blockchains/ton/constants.ts\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./index */ \"./src/api/blockchains/ton/util/index.ts\");\n/* harmony import */ var _tonapiio__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./tonapiio */ \"./src/api/blockchains/ton/util/tonapiio.ts\");\n/* harmony import */ var _tonCore__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./tonCore */ \"./src/api/blockchains/ton/util/tonCore.ts\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst OFFCHAIN_CONTENT_PREFIX = 0x01;\nconst SNAKE_PREFIX = 0x00;\nfunction parseJettonWalletMsgBody(network, body) {\n  if (!body) return undefined;\n  try {\n    let slice = _ton_core_dist_boc_Cell__WEBPACK_IMPORTED_MODULE_3__.Cell.fromBase64(body).beginParse();\n    const opCode = slice.loadUint(32);\n    const queryId = slice.loadUint(64);\n    if (opCode !== _constants__WEBPACK_IMPORTED_MODULE_11__.JettonOpCode.Transfer && opCode !== _constants__WEBPACK_IMPORTED_MODULE_11__.JettonOpCode.InternalTransfer) {\n      return undefined;\n    }\n    const jettonAmount = slice.loadCoins();\n    const address = slice.loadMaybeAddress();\n    const responseAddress = slice.loadMaybeAddress();\n    let forwardAmount;\n    let comment;\n    let encryptedComment;\n    if (responseAddress) {\n      if (opCode === _constants__WEBPACK_IMPORTED_MODULE_11__.JettonOpCode.Transfer) {\n        slice.loadBit();\n      }\n      forwardAmount = slice.loadCoins();\n      const isSeparateCell = slice.remainingBits && slice.loadBit();\n      if (isSeparateCell && slice.remainingRefs) {\n        slice = slice.loadRef().beginParse();\n      }\n      if (slice.remainingBits > 32) {\n        const forwardOpCode = slice.loadUint(32);\n        if (forwardOpCode === _constants__WEBPACK_IMPORTED_MODULE_11__.OpCode.Comment) {\n          const buffer = readSnakeBytes(slice);\n          comment = buffer.toString('utf-8');\n        } else if (forwardOpCode === _constants__WEBPACK_IMPORTED_MODULE_11__.OpCode.Encrypted) {\n          const buffer = readSnakeBytes(slice);\n          encryptedComment = buffer.toString('base64');\n        }\n      }\n    }\n    return {\n      operation: _constants__WEBPACK_IMPORTED_MODULE_11__.JettonOpCode[opCode],\n      queryId,\n      jettonAmount,\n      responseAddress,\n      address: address ? (0,_tonCore__WEBPACK_IMPORTED_MODULE_14__.toBase64Address)(address, undefined, network) : undefined,\n      forwardAmount,\n      comment,\n      encryptedComment\n    };\n  } catch (err) {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_8__.logDebugError)('parseJettonWalletMsgBody', err);\n  }\n  return undefined;\n}\nfunction fixBase64ImageData(data) {\n  const decodedData = (0,_common_utils__WEBPACK_IMPORTED_MODULE_10__.base64ToString)(data);\n  if (decodedData.includes('<svg')) {\n    return `data:image/svg+xml;base64,${data}`;\n  }\n  return `data:image/png;base64,${data}`;\n}\nconst dictSnakeBufferValue = {\n  parse: slice => {\n    const buffer = Buffer.from('');\n    const sliceToVal = (s, v, isFirst) => {\n      if (isFirst && s.loadUint(8) !== SNAKE_PREFIX) {\n        throw new Error('Only snake format is supported');\n      }\n      v = Buffer.concat([v, s.loadBuffer(s.remainingBits / 8)]);\n      if (s.remainingRefs === 1) {\n        v = sliceToVal(s.loadRef().beginParse(), v, false);\n      }\n      return v;\n    };\n    return sliceToVal(slice.loadRef().beginParse(), buffer, true);\n  },\n  serialize: () => {\n    // pass\n  }\n};\nconst jettonOnChainMetadataSpec = {\n  uri: 'ascii',\n  name: 'utf8',\n  description: 'utf8',\n  image: 'ascii',\n  symbol: 'utf8',\n  decimals: 'utf8'\n};\nasync function fetchJettonMetadata(network, address) {\n  const {\n    content\n  } = await (0,_tonCore__WEBPACK_IMPORTED_MODULE_14__.getJettonMinterData)(network, address);\n  let metadata;\n  const slice = content.asSlice();\n  const prefix = slice.loadUint(8);\n  if (prefix === OFFCHAIN_CONTENT_PREFIX) {\n    const bytes = readSnakeBytes(slice);\n    const contentUri = bytes.toString('utf-8');\n    metadata = await fetchJettonOffchainMetadata(contentUri);\n  } else {\n    // On-chain content\n    metadata = await parseJettonOnchainMetadata(slice);\n    if (metadata.uri) {\n      // Semi-chain content\n      const offchainMetadata = await fetchJettonOffchainMetadata(metadata.uri);\n      metadata = {\n        ...offchainMetadata,\n        ...metadata\n      };\n    }\n  }\n  return metadata;\n}\nasync function parseJettonOnchainMetadata(slice) {\n  const dict = slice.loadDict(_ton_core_dist_dict_Dictionary__WEBPACK_IMPORTED_MODULE_5__.Dictionary.Keys.Buffer(32), dictSnakeBufferValue);\n  const res = {};\n  for (const [key, value] of Object.entries(jettonOnChainMetadataSpec)) {\n    var _dict$get;\n    const sha256Key = Buffer.from(await (0,_common_utils__WEBPACK_IMPORTED_MODULE_10__.sha256)(Buffer.from(key, 'ascii')));\n    const val = (_dict$get = dict.get(sha256Key)) === null || _dict$get === void 0 ? void 0 : _dict$get.toString(value);\n    if (val) {\n      res[key] = val;\n    }\n  }\n  return res;\n}\nasync function fetchJettonOffchainMetadata(uri) {\n  const metadata = await (0,_util_metadata__WEBPACK_IMPORTED_MODULE_9__.fetchJsonMetadata)(uri);\n  return (0,_util_iteratees__WEBPACK_IMPORTED_MODULE_7__.pick)(metadata, ['name', 'description', 'symbol', 'decimals', 'image', 'image_data']);\n}\nasync function parseWalletTransactionBody(network, transaction) {\n  var _transaction$extraDat;\n  const body = (_transaction$extraDat = transaction.extraData) === null || _transaction$extraDat === void 0 ? void 0 : _transaction$extraDat.body;\n  if (!body || transaction.comment || transaction.encryptedComment) {\n    return transaction;\n  }\n  try {\n    const slice = dataToSlice(body);\n    if (slice.remainingBits > 32) {\n      const parsedPayload = await parsePayloadSlice(network, transaction.toAddress, slice);\n      transaction.extraData.parsedPayload = parsedPayload;\n      if ((parsedPayload === null || parsedPayload === void 0 ? void 0 : parsedPayload.type) === 'comment') {\n        transaction = {\n          ...transaction,\n          comment: parsedPayload.comment\n        };\n      } else if ((parsedPayload === null || parsedPayload === void 0 ? void 0 : parsedPayload.type) === 'encrypted-comment') {\n        transaction = {\n          ...transaction,\n          encryptedComment: parsedPayload.encryptedComment\n        };\n      }\n    }\n  } catch (err) {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_8__.logDebugError)('parseTransactionBody', err);\n  }\n  return transaction;\n}\nasync function parsePayloadBase64(network, toAddress, base64) {\n  var _await$parsePayloadSl;\n  const slice = dataToSlice(base64);\n  const result = {\n    type: 'unknown',\n    base64\n  };\n  if (!slice) return result;\n  return (_await$parsePayloadSl = await parsePayloadSlice(network, toAddress, slice)) !== null && _await$parsePayloadSl !== void 0 ? _await$parsePayloadSl : result;\n}\nasync function parsePayloadSlice(network, toAddress, slice) {\n  try {\n    const opCode = slice.loadUint(32);\n    if (opCode === _constants__WEBPACK_IMPORTED_MODULE_11__.OpCode.Comment) {\n      const buffer = readSnakeBytes(slice);\n      const comment = buffer.toString('utf-8');\n      return {\n        type: 'comment',\n        comment\n      };\n    } else if (opCode === _constants__WEBPACK_IMPORTED_MODULE_11__.OpCode.Encrypted) {\n      const buffer = readSnakeBytes(slice);\n      const encryptedComment = buffer.toString('base64');\n      return {\n        type: 'encrypted-comment',\n        encryptedComment\n      };\n    } else if (slice.remainingBits < 64) {\n      return undefined;\n    }\n    const queryId = slice.loadUintBig(64);\n    switch (opCode) {\n      case _constants__WEBPACK_IMPORTED_MODULE_11__.JettonOpCode.Transfer:\n        {\n          var _forwardPayload;\n          const minterAddress = await (0,_tonCore__WEBPACK_IMPORTED_MODULE_14__.resolveTokenMinterAddress)(network, toAddress);\n          const slug = (0,_index__WEBPACK_IMPORTED_MODULE_12__.buildTokenSlug)(minterAddress);\n          const amount = slice.loadCoins();\n          const destination = slice.loadAddress();\n          const responseDestination = slice.loadMaybeAddress();\n          if (!responseDestination) {\n            return {\n              type: 'tokens:transfer-non-standard',\n              queryId,\n              destination: (0,_tonCore__WEBPACK_IMPORTED_MODULE_14__.toBase64Address)(destination, undefined, network),\n              amount,\n              slug\n            };\n          }\n          const customPayload = slice.loadMaybeRef();\n          const forwardAmount = slice.loadCoins();\n          let forwardPayload = slice.loadMaybeRef();\n          if (!forwardPayload && slice.remainingBits) {\n            const builder = new _ton_core_dist_boc_Builder__WEBPACK_IMPORTED_MODULE_2__.Builder().storeBits(slice.loadBits(slice.remainingBits));\n            (0,_util_iteratees__WEBPACK_IMPORTED_MODULE_7__.range)(0, slice.remainingRefs).forEach(() => {\n              builder.storeRef(slice.loadRef());\n            });\n            forwardPayload = builder.endCell();\n          }\n          return {\n            type: 'tokens:transfer',\n            queryId,\n            amount,\n            destination: (0,_tonCore__WEBPACK_IMPORTED_MODULE_14__.toBase64Address)(destination, undefined, network),\n            responseDestination: (0,_tonCore__WEBPACK_IMPORTED_MODULE_14__.toBase64Address)(responseDestination, undefined, network),\n            customPayload: customPayload === null || customPayload === void 0 ? void 0 : customPayload.toBoc().toString('base64'),\n            forwardAmount,\n            forwardPayload: (_forwardPayload = forwardPayload) === null || _forwardPayload === void 0 ? void 0 : _forwardPayload.toBoc().toString('base64'),\n            slug\n          };\n        }\n      case _constants__WEBPACK_IMPORTED_MODULE_11__.NftOpCode.TransferOwnership:\n        {\n          var _forwardPayload2, _nft$metadata;\n          const newOwner = slice.loadAddress();\n          const responseDestination = slice.loadAddress();\n          const customPayload = slice.loadMaybeRef();\n          const forwardAmount = slice.loadCoins();\n          let forwardPayload = slice.loadMaybeRef();\n          if (!forwardPayload && slice.remainingBits) {\n            const builder = new _ton_core_dist_boc_Builder__WEBPACK_IMPORTED_MODULE_2__.Builder().storeBits(slice.loadBits(slice.remainingBits));\n            (0,_util_iteratees__WEBPACK_IMPORTED_MODULE_7__.range)(0, slice.remainingRefs).forEach(() => {\n              builder.storeRef(slice.loadRef());\n            });\n            forwardPayload = builder.endCell();\n          }\n          const nftAddress = toAddress;\n          const [nft] = await (0,_tonapiio__WEBPACK_IMPORTED_MODULE_13__.fetchNftItems)(network, [nftAddress]);\n          return {\n            type: 'nft:transfer',\n            queryId,\n            newOwner: (0,_tonCore__WEBPACK_IMPORTED_MODULE_14__.toBase64Address)(newOwner, undefined, network),\n            responseDestination: (0,_tonCore__WEBPACK_IMPORTED_MODULE_14__.toBase64Address)(responseDestination, undefined, network),\n            customPayload: customPayload === null || customPayload === void 0 ? void 0 : customPayload.toBoc().toString('base64'),\n            forwardAmount,\n            forwardPayload: (_forwardPayload2 = forwardPayload) === null || _forwardPayload2 === void 0 ? void 0 : _forwardPayload2.toBoc().toString('base64'),\n            nftAddress,\n            nftName: nft === null || nft === void 0 || (_nft$metadata = nft.metadata) === null || _nft$metadata === void 0 ? void 0 : _nft$metadata.name\n          };\n        }\n      case _constants__WEBPACK_IMPORTED_MODULE_11__.JettonOpCode.Burn:\n        {\n          const minterAddress = await (0,_tonCore__WEBPACK_IMPORTED_MODULE_14__.resolveTokenMinterAddress)(network, toAddress);\n          const slug = (0,_index__WEBPACK_IMPORTED_MODULE_12__.buildTokenSlug)(minterAddress);\n          const amount = slice.loadCoins();\n          const address = slice.loadAddress();\n          const customPayload = slice.loadMaybeRef();\n          const isLiquidUnstakeRequest = minterAddress === _config__WEBPACK_IMPORTED_MODULE_6__.LIQUID_JETTON;\n          return {\n            type: 'tokens:burn',\n            queryId,\n            amount,\n            address: (0,_tonCore__WEBPACK_IMPORTED_MODULE_14__.toBase64Address)(address, undefined, network),\n            customPayload: customPayload === null || customPayload === void 0 ? void 0 : customPayload.toBoc().toString('base64'),\n            slug,\n            isLiquidUnstakeRequest\n          };\n        }\n      case _constants__WEBPACK_IMPORTED_MODULE_11__.LiquidStakingOpCode.DistributedAsset:\n        {\n          return {\n            type: 'liquid-staking:withdrawal-nft',\n            queryId\n          };\n        }\n      case _constants__WEBPACK_IMPORTED_MODULE_11__.LiquidStakingOpCode.Withdrawal:\n        {\n          return {\n            type: 'liquid-staking:withdrawal',\n            queryId\n          };\n        }\n      case _constants__WEBPACK_IMPORTED_MODULE_11__.LiquidStakingOpCode.Deposit:\n        {\n          // const amount = slice.loadCoins();\n          return {\n            type: 'liquid-staking:deposit',\n            queryId\n          };\n        }\n    }\n  } catch (err) {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_8__.logDebugError)('parsePayload', err);\n  }\n  return undefined;\n}\nfunction dataToSlice(data) {\n  let buffer;\n  if (typeof data === 'string') {\n    buffer = Buffer.from(data, 'base64');\n  } else if (data instanceof Buffer) {\n    buffer = data;\n  } else {\n    buffer = Buffer.from(data);\n  }\n  try {\n    return _ton_core_dist_boc_Cell__WEBPACK_IMPORTED_MODULE_3__.Cell.fromBoc(buffer)[0].beginParse();\n  } catch (err) {\n    if ((err === null || err === void 0 ? void 0 : err.message) !== 'Invalid magic') {\n      throw err;\n    }\n  }\n  return new _ton_core_dist_boc_Slice__WEBPACK_IMPORTED_MODULE_4__.Slice(new _ton_core_dist_boc_BitReader__WEBPACK_IMPORTED_MODULE_0__.BitReader(new _ton_core_dist_boc_BitString__WEBPACK_IMPORTED_MODULE_1__.BitString(buffer, 0, buffer.length * 8)), []);\n}\nfunction readSnakeBytes(slice) {\n  let buffer = Buffer.alloc(0);\n  while (slice.remainingBits >= 8) {\n    buffer = Buffer.concat([buffer, slice.loadBuffer(slice.remainingBits / 8)]);\n    if (slice.remainingRefs) {\n      slice = slice.loadRef().beginParse();\n    } else {\n      break;\n    }\n  }\n  return buffer;\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/blockchains/ton/util/metadata.ts?");

/***/ }),

/***/ "./src/api/blockchains/ton/util/tonCore.ts":
/*!*************************************************!*\
  !*** ./src/api/blockchains/ton/util/tonCore.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"buildLiquidStakingDepositBody\": () => (/* binding */ buildLiquidStakingDepositBody),\n/* harmony export */   \"buildLiquidStakingWithdrawBody\": () => (/* binding */ buildLiquidStakingWithdrawBody),\n/* harmony export */   \"buildTokenTransferBody\": () => (/* binding */ buildTokenTransferBody),\n/* harmony export */   \"commentToBytes\": () => (/* binding */ commentToBytes),\n/* harmony export */   \"getIsRawAddress\": () => (/* binding */ getIsRawAddress),\n/* harmony export */   \"getJettonMinterData\": () => (/* binding */ getJettonMinterData),\n/* harmony export */   \"getTokenBalance\": () => (/* binding */ getTokenBalance),\n/* harmony export */   \"getTonClient\": () => (/* binding */ getTonClient),\n/* harmony export */   \"getTonWalletContract\": () => (/* binding */ getTonWalletContract),\n/* harmony export */   \"getWalletPublicKey\": () => (/* binding */ getWalletPublicKey),\n/* harmony export */   \"oneCellFromBoc\": () => (/* binding */ oneCellFromBoc),\n/* harmony export */   \"packBytesAsSnake\": () => (/* binding */ packBytesAsSnake),\n/* harmony export */   \"parseAddress\": () => (/* binding */ parseAddress),\n/* harmony export */   \"parseBase64\": () => (/* binding */ parseBase64),\n/* harmony export */   \"resolveTokenMinterAddress\": () => (/* binding */ resolveTokenMinterAddress),\n/* harmony export */   \"resolveTokenWalletAddress\": () => (/* binding */ resolveTokenWalletAddress),\n/* harmony export */   \"toBase64Address\": () => (/* binding */ toBase64Address),\n/* harmony export */   \"toRawAddress\": () => (/* binding */ toRawAddress),\n/* harmony export */   \"walletClassMap\": () => (/* binding */ walletClassMap)\n/* harmony export */ });\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ton/core */ \"./node_modules/@ton/core/dist/index.js\");\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ton_core__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ton_ton_dist_wallets_WalletContractV1R1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ton/ton/dist/wallets/WalletContractV1R1 */ \"./node_modules/@ton/ton/dist/wallets/WalletContractV1R1.js\");\n/* harmony import */ var _ton_ton_dist_wallets_WalletContractV1R2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ton/ton/dist/wallets/WalletContractV1R2 */ \"./node_modules/@ton/ton/dist/wallets/WalletContractV1R2.js\");\n/* harmony import */ var _ton_ton_dist_wallets_WalletContractV1R3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ton/ton/dist/wallets/WalletContractV1R3 */ \"./node_modules/@ton/ton/dist/wallets/WalletContractV1R3.js\");\n/* harmony import */ var _ton_ton_dist_wallets_WalletContractV2R1__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ton/ton/dist/wallets/WalletContractV2R1 */ \"./node_modules/@ton/ton/dist/wallets/WalletContractV2R1.js\");\n/* harmony import */ var _ton_ton_dist_wallets_WalletContractV2R2__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ton/ton/dist/wallets/WalletContractV2R2 */ \"./node_modules/@ton/ton/dist/wallets/WalletContractV2R2.js\");\n/* harmony import */ var _ton_ton_dist_wallets_WalletContractV3R1__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ton/ton/dist/wallets/WalletContractV3R1 */ \"./node_modules/@ton/ton/dist/wallets/WalletContractV3R1.js\");\n/* harmony import */ var _ton_ton_dist_wallets_WalletContractV3R2__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ton/ton/dist/wallets/WalletContractV3R2 */ \"./node_modules/@ton/ton/dist/wallets/WalletContractV3R2.js\");\n/* harmony import */ var _ton_ton_dist_wallets_WalletContractV4__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ton/ton/dist/wallets/WalletContractV4 */ \"./node_modules/@ton/ton/dist/wallets/WalletContractV4.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../types */ \"./src/api/types/index.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../../config */ \"./src/config.ts\");\n/* harmony import */ var _util_logs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../../../util/logs */ \"./src/util/logs.ts\");\n/* harmony import */ var _util_withCacheAsync__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../../../util/withCacheAsync */ \"./src/util/withCacheAsync.ts\");\n/* harmony import */ var _contracts_JettonMaster__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../contracts/JettonMaster */ \"./src/api/blockchains/ton/contracts/JettonMaster.ts\");\n/* harmony import */ var _contracts_JettonWallet__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../contracts/JettonWallet */ \"./src/api/blockchains/ton/contracts/JettonWallet.ts\");\n/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../../common/utils */ \"./src/api/common/utils.ts\");\n/* harmony import */ var _environment__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../../environment */ \"./src/api/environment.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../constants */ \"./src/api/blockchains/ton/constants.ts\");\n/* harmony import */ var _TonClient__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./TonClient */ \"./src/api/blockchains/ton/util/TonClient.ts\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(axios__WEBPACK_IMPORTED_MODULE_1___default().defaults.adapter) = (__webpack_require__(/*! ../../../../lib/axios-fetch-adapter */ \"./src/lib/axios-fetch-adapter/index.js\")[\"default\"]);\nconst TON_MAX_COMMENT_BYTES = 127;\nlet clientByNetwork;\nconst walletClassMap = {\n  simpleR1: _ton_ton_dist_wallets_WalletContractV1R1__WEBPACK_IMPORTED_MODULE_2__.WalletContractV1R1,\n  simpleR2: _ton_ton_dist_wallets_WalletContractV1R2__WEBPACK_IMPORTED_MODULE_3__.WalletContractV1R2,\n  simpleR3: _ton_ton_dist_wallets_WalletContractV1R3__WEBPACK_IMPORTED_MODULE_4__.WalletContractV1R3,\n  v2R1: _ton_ton_dist_wallets_WalletContractV2R1__WEBPACK_IMPORTED_MODULE_5__.WalletContractV2R1,\n  v2R2: _ton_ton_dist_wallets_WalletContractV2R2__WEBPACK_IMPORTED_MODULE_6__.WalletContractV2R2,\n  v3R1: _ton_ton_dist_wallets_WalletContractV3R1__WEBPACK_IMPORTED_MODULE_7__.WalletContractV3R1,\n  v3R2: _ton_ton_dist_wallets_WalletContractV3R2__WEBPACK_IMPORTED_MODULE_8__.WalletContractV3R2,\n  v4R2: _ton_ton_dist_wallets_WalletContractV4__WEBPACK_IMPORTED_MODULE_9__.WalletContractV4\n};\nfunction getTonClient() {\n  let network = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'mainnet';\n  if (!clientByNetwork) {\n    var tonClient = new _TonClient__WEBPACK_IMPORTED_MODULE_19__.TonClient({\n      endpoint: _config__WEBPACK_IMPORTED_MODULE_11__.TONHTTPAPI_MAINNET_URL,\n      timeout: _config__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_TIMEOUT,\n      apiKey: _config__WEBPACK_IMPORTED_MODULE_11__.TONHTTPAPI_MAINNET_API_KEY,\n      headers: (0,_environment__WEBPACK_IMPORTED_MODULE_17__.getEnvironment)().apiHeaders\n    });\n    clientByNetwork = {\n      mainnet: tonClient,\n      testnet: new _TonClient__WEBPACK_IMPORTED_MODULE_19__.TonClient({\n        endpoint: _config__WEBPACK_IMPORTED_MODULE_11__.TONHTTPAPI_TESTNET_URL,\n        timeout: _config__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_TIMEOUT,\n        apiKey: _config__WEBPACK_IMPORTED_MODULE_11__.TONHTTPAPI_TESTNET_API_KEY,\n        headers: (0,_environment__WEBPACK_IMPORTED_MODULE_17__.getEnvironment)().apiHeaders\n      })\n    };\n  }\n  return clientByNetwork[network];\n}\nfunction getTonWalletContract(publicKeyHex, version) {\n  const walletClass = walletClassMap[version];\n  if (!walletClass) {\n    throw new Error('Unsupported wallet contract version');\n  }\n  const publicKey = Buffer.from((0,_common_utils__WEBPACK_IMPORTED_MODULE_16__.hexToBytes)(publicKeyHex));\n  return walletClass.create({\n    workchain: _types__WEBPACK_IMPORTED_MODULE_10__.WORKCHAIN,\n    publicKey\n  });\n}\nconst resolveTokenWalletAddress = (0,_util_withCacheAsync__WEBPACK_IMPORTED_MODULE_13__[\"default\"])(async (network, address, minterAddress) => {\n  const minter = getTonClient(network).open(new _contracts_JettonMaster__WEBPACK_IMPORTED_MODULE_14__.JettonMinter(_ton_core__WEBPACK_IMPORTED_MODULE_0__.Address.parse(minterAddress)));\n  const walletAddress = await minter.getWalletAddress(_ton_core__WEBPACK_IMPORTED_MODULE_0__.Address.parse(address));\n  return toBase64Address(walletAddress, true, network);\n});\nconst resolveTokenMinterAddress = (0,_util_withCacheAsync__WEBPACK_IMPORTED_MODULE_13__[\"default\"])(async (network, tokenWalletAddress) => {\n  const tokenWallet = getTonClient(network).open(new _contracts_JettonWallet__WEBPACK_IMPORTED_MODULE_15__.JettonWallet(_ton_core__WEBPACK_IMPORTED_MODULE_0__.Address.parse(tokenWalletAddress)));\n  const data = await tokenWallet.getWalletData();\n  return toBase64Address(data.minter, true, network);\n});\nconst getWalletPublicKey = (0,_util_withCacheAsync__WEBPACK_IMPORTED_MODULE_13__[\"default\"])(async (network, address) => {\n  try {\n    const res = await getTonClient(network).callGetMethod(_ton_core__WEBPACK_IMPORTED_MODULE_0__.Address.parse(address), 'get_public_key');\n    const bigintKey = res.stack.readBigNumber();\n    const hex = bigintKey.toString(16).padStart(64, '0');\n    return (0,_common_utils__WEBPACK_IMPORTED_MODULE_16__.hexToBytes)(hex);\n  } catch (err) {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_12__.logDebugError)('getWalletPublicKey', err);\n    return undefined;\n  }\n});\nfunction getJettonMinterData(network, address) {\n  const contract = getTonClient(network).open(new _contracts_JettonMaster__WEBPACK_IMPORTED_MODULE_14__.JettonMinter(_ton_core__WEBPACK_IMPORTED_MODULE_0__.Address.parse(address)));\n  return contract.getJettonData();\n}\nfunction oneCellFromBoc(bytes) {\n  return _ton_core__WEBPACK_IMPORTED_MODULE_0__.Cell.fromBoc(Buffer.from(bytes));\n}\nfunction toBase64Address(address) {\n  let isBounceable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _constants__WEBPACK_IMPORTED_MODULE_18__.DEFAULT_IS_BOUNCEABLE;\n  let network = arguments.length > 2 ? arguments[2] : undefined;\n  if (typeof address === 'string') {\n    address = _ton_core__WEBPACK_IMPORTED_MODULE_0__.Address.parse(address);\n  }\n  return address.toString({\n    urlSafe: true,\n    bounceable: isBounceable,\n    testOnly: network === 'testnet'\n  });\n}\nfunction toRawAddress(address) {\n  if (typeof address === 'string') {\n    address = _ton_core__WEBPACK_IMPORTED_MODULE_0__.Address.parse(address);\n  }\n  return address.toRawString();\n}\nfunction buildTokenTransferBody(params) {\n  const {\n    queryId,\n    tokenAmount,\n    toAddress,\n    responseAddress,\n    forwardAmount\n  } = params;\n  let forwardPayload = params.forwardPayload;\n  let builder = new _ton_core__WEBPACK_IMPORTED_MODULE_0__.Builder().storeUint(_constants__WEBPACK_IMPORTED_MODULE_18__.JettonOpCode.Transfer, 32).storeUint(queryId || 0, 64).storeCoins(tokenAmount).storeAddress(_ton_core__WEBPACK_IMPORTED_MODULE_0__.Address.parse(toAddress)).storeAddress(_ton_core__WEBPACK_IMPORTED_MODULE_0__.Address.parse(responseAddress)).storeBit(false).storeCoins(forwardAmount !== null && forwardAmount !== void 0 ? forwardAmount : 0n);\n  if (forwardPayload instanceof Uint8Array) {\n    const freeBytes = Math.round(builder.availableBits / 8);\n    forwardPayload = packBytesAsSnake(forwardPayload, freeBytes);\n  }\n  if (!forwardPayload) {\n    builder.storeBit(false);\n  } else if (typeof forwardPayload === 'string') {\n    builder = builder.storeBit(false).storeUint(0, 32).storeBuffer(Buffer.from(forwardPayload));\n  } else if (forwardPayload instanceof Uint8Array) {\n    builder = builder.storeBit(false).storeBuffer(Buffer.from(forwardPayload));\n  } else {\n    builder = builder.storeBit(true).storeRef(forwardPayload);\n  }\n  return builder.endCell();\n}\nfunction parseBase64(base64) {\n  try {\n    return _ton_core__WEBPACK_IMPORTED_MODULE_0__.Cell.fromBase64(base64);\n  } catch (err) {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_12__.logDebugError)('parseBase64', err);\n    return Uint8Array.from(Buffer.from(base64, 'base64'));\n  }\n}\nfunction commentToBytes(comment) {\n  const buffer = Buffer.from(comment);\n  const bytes = new Uint8Array(buffer.length + 4);\n  const startBuffer = Buffer.alloc(4);\n  startBuffer.writeUInt32BE(_constants__WEBPACK_IMPORTED_MODULE_18__.OpCode.Comment);\n  bytes.set(startBuffer, 0);\n  bytes.set(buffer, 4);\n  return bytes;\n}\nfunction packBytesAsSnake(bytes) {\n  let maxBytes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TON_MAX_COMMENT_BYTES;\n  const buffer = Buffer.from(bytes);\n  if (buffer.length <= maxBytes) {\n    return bytes;\n  }\n  const mainBuilder = new _ton_core__WEBPACK_IMPORTED_MODULE_0__.Builder();\n  let prevBuilder;\n  let currentBuilder = mainBuilder;\n  for (const [i, byte] of buffer.entries()) {\n    if (currentBuilder.availableBits < 8) {\n      var _prevBuilder;\n      (_prevBuilder = prevBuilder) === null || _prevBuilder === void 0 || _prevBuilder.storeRef(currentBuilder);\n      prevBuilder = currentBuilder;\n      currentBuilder = new _ton_core__WEBPACK_IMPORTED_MODULE_0__.Builder();\n    }\n    currentBuilder = currentBuilder.storeUint(byte, 8);\n    if (i === buffer.length - 1) {\n      var _prevBuilder2;\n      (_prevBuilder2 = prevBuilder) === null || _prevBuilder2 === void 0 || _prevBuilder2.storeRef(currentBuilder);\n    }\n  }\n  return mainBuilder.asCell();\n}\nfunction buildLiquidStakingDepositBody(queryId) {\n  return new _ton_core__WEBPACK_IMPORTED_MODULE_0__.Builder().storeUint(_constants__WEBPACK_IMPORTED_MODULE_18__.LiquidStakingOpCode.Deposit, 32).storeUint(queryId || 0, 64).asCell();\n}\nfunction buildLiquidStakingWithdrawBody(options) {\n  const {\n    queryId,\n    amount,\n    responseAddress,\n    waitTillRoundEnd,\n    fillOrKill\n  } = options;\n  const customPayload = new _ton_core__WEBPACK_IMPORTED_MODULE_0__.Builder().storeUint(Number(waitTillRoundEnd), 1).storeUint(Number(fillOrKill), 1).asCell();\n  return new _ton_core__WEBPACK_IMPORTED_MODULE_0__.Builder().storeUint(_constants__WEBPACK_IMPORTED_MODULE_18__.JettonOpCode.Burn, 32).storeUint(queryId !== null && queryId !== void 0 ? queryId : 0, 64).storeCoins(amount).storeAddress(_ton_core__WEBPACK_IMPORTED_MODULE_0__.Address.parse(responseAddress)).storeBit(1).storeRef(customPayload).asCell();\n}\nfunction getTokenBalance(network, walletAddress) {\n  const tokenWallet = getTonClient(network).open(new _contracts_JettonWallet__WEBPACK_IMPORTED_MODULE_15__.JettonWallet(_ton_core__WEBPACK_IMPORTED_MODULE_0__.Address.parse(walletAddress)));\n  return tokenWallet.getJettonBalance();\n}\nfunction parseAddress(address) {\n  try {\n    if (_ton_core__WEBPACK_IMPORTED_MODULE_0__.Address.isRaw(address)) {\n      return {\n        address: _ton_core__WEBPACK_IMPORTED_MODULE_0__.Address.parseRaw(address),\n        isRaw: true,\n        isValid: true\n      };\n    } else if (_ton_core__WEBPACK_IMPORTED_MODULE_0__.Address.isFriendly(address)) {\n      return {\n        ..._ton_core__WEBPACK_IMPORTED_MODULE_0__.Address.parseFriendly(address),\n        isUserFriendly: true,\n        isValid: true\n      };\n    }\n  } catch (err) {\n    // Do nothing\n  }\n  return {\n    isValid: false\n  };\n}\nfunction getIsRawAddress(address) {\n  return Boolean(parseAddress(address).isRaw);\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/blockchains/ton/util/tonCore.ts?");

/***/ }),

/***/ "./src/api/blockchains/ton/util/tonapiio.ts":
/*!**************************************************!*\
  !*** ./src/api/blockchains/ton/util/tonapiio.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"fetchAccountEvents\": () => (/* binding */ fetchAccountEvents),\n/* harmony export */   \"fetchAccountNfts\": () => (/* binding */ fetchAccountNfts),\n/* harmony export */   \"fetchJettonBalances\": () => (/* binding */ fetchJettonBalances),\n/* harmony export */   \"fetchNftItems\": () => (/* binding */ fetchNftItems)\n/* harmony export */ });\n/* harmony import */ var tonapi_sdk_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tonapi-sdk-js */ \"./node_modules/tonapi-sdk-js/dist/index.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../config */ \"./src/config.ts\");\n/* harmony import */ var _util_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../util/fetch */ \"./src/util/fetch.ts\");\n/* harmony import */ var _environment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../environment */ \"./src/api/environment.ts\");\n\n\n\n\nconst MAX_LIMIT = 500;\nconst EVENTS_LIMIT = 100;\nlet apiByNetwork;\nfunction getApi(network) {\n  if (!apiByNetwork) {\n    const headers = {\n      ...(0,_environment__WEBPACK_IMPORTED_MODULE_3__.getEnvironment)().apiHeaders,\n      'Content-Type': 'application/json'\n    };\n    apiByNetwork = {\n      mainnet: new tonapi_sdk_js__WEBPACK_IMPORTED_MODULE_0__.Api(new tonapi_sdk_js__WEBPACK_IMPORTED_MODULE_0__.HttpClient({\n        baseUrl: _config__WEBPACK_IMPORTED_MODULE_1__.TONAPIIO_MAINNET_URL,\n        baseApiParams: {\n          headers\n        },\n        customFetch: _util_fetch__WEBPACK_IMPORTED_MODULE_2__.fetchWithRetry\n      })),\n      testnet: new tonapi_sdk_js__WEBPACK_IMPORTED_MODULE_0__.Api(new tonapi_sdk_js__WEBPACK_IMPORTED_MODULE_0__.HttpClient({\n        baseUrl: _config__WEBPACK_IMPORTED_MODULE_1__.TONAPIIO_TESTNET_URL,\n        baseApiParams: {\n          headers\n        },\n        customFetch: _util_fetch__WEBPACK_IMPORTED_MODULE_2__.fetchWithRetry\n      }))\n    };\n  }\n  return apiByNetwork[network];\n}\nasync function fetchJettonBalances(network, account) {\n  return (await getApi(network).accounts.getAccountJettonsBalances(account)).balances;\n}\nasync function fetchNftItems(network, addresses) {\n  return (await getApi(network).nft.getNftItemsByAddresses({\n    account_ids: addresses\n  })).nft_items;\n}\nasync function fetchAccountNfts(network, address, options) {\n  const {\n    collection,\n    offset,\n    limit\n  } = options !== null && options !== void 0 ? options : {};\n  return (await getApi(network).accounts.getAccountNftItems(address, {\n    offset: offset !== null && offset !== void 0 ? offset : 0,\n    limit: limit !== null && limit !== void 0 ? limit : MAX_LIMIT,\n    indirect_ownership: true,\n    collection\n  })).nft_items;\n}\nasync function fetchAccountEvents(network, address, fromSec, limit) {\n  return (await getApi(network).accounts.getAccountEvents(address, {\n    limit: limit !== null && limit !== void 0 ? limit : EVENTS_LIMIT,\n    start_date: fromSec\n  })).events;\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/blockchains/ton/util/tonapiio.ts?");

/***/ }),

/***/ "./src/api/blockchains/ton/wallet.ts":
/*!*******************************************!*\
  !*** ./src/api/blockchains/ton/wallet.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"buildWallet\": () => (/* binding */ buildWallet),\n/* harmony export */   \"getAccountBalance\": () => (/* binding */ getAccountBalance),\n/* harmony export */   \"getContractInfo\": () => (/* binding */ getContractInfo),\n/* harmony export */   \"getWalletBalance\": () => (/* binding */ getWalletBalance),\n/* harmony export */   \"getWalletInfo\": () => (/* binding */ getWalletInfo),\n/* harmony export */   \"getWalletSeqno\": () => (/* binding */ getWalletSeqno),\n/* harmony export */   \"getWalletStateInit\": () => (/* binding */ getWalletStateInit),\n/* harmony export */   \"getWalletVersionInfos\": () => (/* binding */ getWalletVersionInfos),\n/* harmony export */   \"getWalletVersions\": () => (/* binding */ getWalletVersions),\n/* harmony export */   \"isActiveSmartContract\": () => (/* binding */ isActiveSmartContract),\n/* harmony export */   \"isAddressInitialized\": () => (/* binding */ isAddressInitialized),\n/* harmony export */   \"pickAccountWallet\": () => (/* binding */ pickAccountWallet),\n/* harmony export */   \"pickBestWallet\": () => (/* binding */ pickBestWallet),\n/* harmony export */   \"pickWalletByAddress\": () => (/* binding */ pickWalletByAddress),\n/* harmony export */   \"publicKeyToAddress\": () => (/* binding */ publicKeyToAddress),\n/* harmony export */   \"resolveWalletVersion\": () => (/* binding */ resolveWalletVersion)\n/* harmony export */ });\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ton/core */ \"./node_modules/@ton/core/dist/index.js\");\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ton_core__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../types */ \"./src/api/types/index.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../config */ \"./src/config.ts\");\n/* harmony import */ var _util_account__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../util/account */ \"./src/util/account.ts\");\n/* harmony import */ var _util_iteratees__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../util/iteratees */ \"./src/util/iteratees.ts\");\n/* harmony import */ var _util_withCacheAsync__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../util/withCacheAsync */ \"./src/util/withCacheAsync.ts\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util */ \"./src/api/blockchains/ton/util/index.ts\");\n/* harmony import */ var _util_tonCore__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./util/tonCore */ \"./src/api/blockchains/ton/util/tonCore.ts\");\n/* harmony import */ var _common_accounts__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../common/accounts */ \"./src/api/common/accounts.ts\");\n/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../common/utils */ \"./src/api/common/utils.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./constants */ \"./src/api/blockchains/ton/constants.ts\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\n\n\n\n\n\n\n\n\n\nconst isAddressInitialized = (0,_util_withCacheAsync__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(async (network, walletOrAddress) => {\n  return (await getWalletInfo(network, walletOrAddress)).isInitialized;\n});\nconst isActiveSmartContract = (0,_util_withCacheAsync__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(async (network, address) => {\n  const {\n    isInitialized,\n    isWallet\n  } = await getWalletInfo(network, address);\n  return isInitialized ? !isWallet : undefined;\n}, value => value !== undefined);\nfunction publicKeyToAddress(network, publicKey, walletVersion) {\n  const wallet = buildWallet(network, publicKey, walletVersion);\n  return (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_7__.toBase64Address)(wallet.address, false, network);\n}\nfunction buildWallet(network, publicKey, walletVersion) {\n  const client = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_7__.getTonClient)(network);\n  const WalletClass = _util_tonCore__WEBPACK_IMPORTED_MODULE_7__.walletClassMap[walletVersion];\n  return client.open(WalletClass.create({\n    publicKey: Buffer.from(publicKey),\n    workchain: _types__WEBPACK_IMPORTED_MODULE_1__.WORKCHAIN\n  }));\n}\nasync function getWalletInfo(network, walletOrAddress) {\n  const address = typeof walletOrAddress === 'string' ? walletOrAddress : (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_7__.toBase64Address)(walletOrAddress.address, undefined, network);\n  const {\n    account_state: accountState,\n    wallet: isWallet,\n    seqno = 0,\n    balance,\n    last_transaction_id: {\n      lt,\n      hash\n    }\n  } = await (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_7__.getTonClient)(network).getWalletInfo(address);\n  return {\n    isInitialized: accountState === 'active',\n    isWallet,\n    seqno,\n    balance: BigInt(balance || '0'),\n    lastTxId: lt === '0' ? undefined : (0,_util__WEBPACK_IMPORTED_MODULE_6__.stringifyTxId)({\n      lt,\n      hash\n    })\n  };\n}\nasync function getContractInfo(network, address) {\n  const data = await (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_7__.getTonClient)(network).getAddressInfo(address);\n  const {\n    code,\n    state\n  } = data;\n  const codeHash = Buffer.from(await (0,_common_utils__WEBPACK_IMPORTED_MODULE_9__.sha256)((0,_common_utils__WEBPACK_IMPORTED_MODULE_9__.base64ToBytes)(code))).toString('hex');\n  const contractInfo = Object.values(_constants__WEBPACK_IMPORTED_MODULE_10__.KnownContracts).find(info => info.hash === codeHash);\n  const isInitialized = state === 'active';\n  const isWallet = state === 'active' ? (contractInfo === null || contractInfo === void 0 ? void 0 : contractInfo.type) === 'wallet' : undefined;\n  const isLedgerAllowed = Boolean(!isInitialized || (contractInfo === null || contractInfo === void 0 ? void 0 : contractInfo.isLedgerAllowed));\n  const isSwapAllowed = contractInfo === null || contractInfo === void 0 ? void 0 : contractInfo.isSwapAllowed;\n  return {\n    isInitialized,\n    isWallet,\n    isLedgerAllowed,\n    isSwapAllowed,\n    contractInfo,\n    codeHash\n  };\n}\nasync function getAccountBalance(accountId) {\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_3__.parseAccountId)(accountId);\n  const address = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_8__.fetchStoredAddress)(accountId);\n  return getWalletBalance(network, address);\n}\nasync function getWalletBalance(network, walletOrAddress) {\n  return (await getWalletInfo(network, walletOrAddress)).balance;\n}\nasync function getWalletSeqno(network, walletOrAddress) {\n  const {\n    seqno\n  } = await getWalletInfo(network, walletOrAddress);\n  return seqno || 0;\n}\nasync function pickBestWallet(network, publicKey) {\n  const allWallets = await getWalletVersionInfos(network, publicKey);\n  const withBiggestBalance = allWallets.reduce((best, current) => {\n    return best && best.balance > current.balance ? best : current;\n  }, undefined);\n  if (!withBiggestBalance || !withBiggestBalance.balance) {\n    const version = _config__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_WALLET_VERSION;\n    const wallet = buildWallet(network, publicKey, version);\n    return {\n      wallet,\n      version,\n      balance: 0n\n    };\n  }\n  return withBiggestBalance;\n}\nfunction getWalletVersionInfos(network, publicKey) {\n  let versions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _constants__WEBPACK_IMPORTED_MODULE_10__.ALL_WALLET_VERSIONS;\n  return Promise.all(versions.map(async version => {\n    const wallet = buildWallet(network, publicKey, version);\n    const address = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_7__.toBase64Address)(wallet.address, false, network);\n    const walletInfo = await getWalletInfo(network, wallet);\n    return {\n      wallet,\n      address,\n      version,\n      ...(0,_util_iteratees__WEBPACK_IMPORTED_MODULE_4__.pick)(walletInfo, ['isInitialized', 'balance', 'lastTxId'])\n    };\n  }));\n}\nfunction getWalletVersions(network, publicKey) {\n  let versions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _constants__WEBPACK_IMPORTED_MODULE_10__.ALL_WALLET_VERSIONS;\n  return versions.map(version => {\n    const wallet = buildWallet(network, publicKey, version);\n    const address = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_7__.toBase64Address)(wallet.address, false, network);\n    return {\n      wallet,\n      address,\n      version\n    };\n  });\n}\nasync function getWalletStateInit(accountId) {\n  const wallet = await pickAccountWallet(accountId);\n  return (0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.beginCell)().storeWritable((0,_ton_core__WEBPACK_IMPORTED_MODULE_0__.storeStateInit)(wallet.init)).endCell();\n}\nfunction pickWalletByAddress(network, publicKey, address) {\n  address = (0,_util_tonCore__WEBPACK_IMPORTED_MODULE_7__.toBase64Address)(address, false, network);\n  const allWallets = getWalletVersions(network, publicKey);\n  return allWallets.find(w => w.address === address);\n}\nasync function pickAccountWallet(accountId) {\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_3__.parseAccountId)(accountId);\n  const {\n    publicKey,\n    version\n  } = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_8__.fetchStoredAccount)(accountId);\n  const publicKeyBytes = (0,_common_utils__WEBPACK_IMPORTED_MODULE_9__.hexToBytes)(publicKey);\n  return buildWallet(network, publicKeyBytes, version);\n}\nfunction resolveWalletVersion(wallet) {\n  var _Object$entries$find;\n  return (_Object$entries$find = Object.entries(_util_tonCore__WEBPACK_IMPORTED_MODULE_7__.walletClassMap).find(_ref => {\n    let [, walletClass] = _ref;\n    return wallet instanceof walletClass;\n  })) === null || _Object$entries$find === void 0 ? void 0 : _Object$entries$find[0];\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/blockchains/ton/wallet.ts?");

/***/ }),

/***/ "./src/api/common/accounts.ts":
/*!************************************!*\
  !*** ./src/api/common/accounts.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"fetchStoredAccount\": () => (/* binding */ fetchStoredAccount),\n/* harmony export */   \"fetchStoredAccounts\": () => (/* binding */ fetchStoredAccounts),\n/* harmony export */   \"fetchStoredAddress\": () => (/* binding */ fetchStoredAddress),\n/* harmony export */   \"fetchStoredPublicKey\": () => (/* binding */ fetchStoredPublicKey),\n/* harmony export */   \"getAccountIdWithMnemonic\": () => (/* binding */ getAccountIdWithMnemonic),\n/* harmony export */   \"getAccountIds\": () => (/* binding */ getAccountIds),\n/* harmony export */   \"getAccountValue\": () => (/* binding */ getAccountValue),\n/* harmony export */   \"getCurrentAccountId\": () => (/* binding */ getCurrentAccountId),\n/* harmony export */   \"getCurrentAccountIdOrFail\": () => (/* binding */ getCurrentAccountIdOrFail),\n/* harmony export */   \"getCurrentNetwork\": () => (/* binding */ getCurrentNetwork),\n/* harmony export */   \"getNewAccountId\": () => (/* binding */ getNewAccountId),\n/* harmony export */   \"loginResolve\": () => (/* binding */ loginResolve),\n/* harmony export */   \"removeAccountValue\": () => (/* binding */ removeAccountValue),\n/* harmony export */   \"removeNetworkAccountsValue\": () => (/* binding */ removeNetworkAccountsValue),\n/* harmony export */   \"setAccountValue\": () => (/* binding */ setAccountValue),\n/* harmony export */   \"updateStoredAccount\": () => (/* binding */ updateStoredAccount),\n/* harmony export */   \"waitLogin\": () => (/* binding */ waitLogin)\n/* harmony export */ });\n/* harmony import */ var _util_account__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/account */ \"./src/util/account.ts\");\n/* harmony import */ var _storages__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../storages */ \"./src/api/storages/index.ts\");\n\n\nconst MIN_ACCOUNT_NUMBER = 0;\n\n// eslint-disable-next-line import/no-mutable-exports\nlet loginResolve;\nconst loginPromise = new Promise(resolve => {\n  loginResolve = resolve;\n});\nasync function getAccountIds() {\n  return Object.keys((await _storages__WEBPACK_IMPORTED_MODULE_1__.storage.getItem('accounts')) || {});\n}\nasync function getAccountIdWithMnemonic() {\n  var _Object$entries$find;\n  const byId = await fetchStoredAccounts();\n  return (_Object$entries$find = Object.entries(byId).find(_ref => {\n    let [, account] = _ref;\n    return !account.ledger;\n  })) === null || _Object$entries$find === void 0 ? void 0 : _Object$entries$find[0];\n}\nasync function getNewAccountId(network) {\n  const ids = (await getAccountIds()).map(accountId => (0,_util_account__WEBPACK_IMPORTED_MODULE_0__.parseAccountId)(accountId).id);\n  const id = ids.length === 0 ? MIN_ACCOUNT_NUMBER : Math.max(...ids) + 1;\n  return (0,_util_account__WEBPACK_IMPORTED_MODULE_0__.buildAccountId)({\n    id,\n    network,\n    blockchain: 'ton'\n  });\n}\nasync function fetchStoredPublicKey(accountId) {\n  return (await fetchStoredAccount(accountId)).publicKey;\n}\nasync function fetchStoredAddress(accountId) {\n  return (await fetchStoredAccount(accountId)).address;\n}\nfunction fetchStoredAccount(accountId) {\n  return getAccountValue(accountId, 'accounts');\n}\nfunction fetchStoredAccounts() {\n  return _storages__WEBPACK_IMPORTED_MODULE_1__.storage.getItem('accounts');\n}\nasync function updateStoredAccount(accountId, partial) {\n  const account = await fetchStoredAccount(accountId);\n  return setAccountValue(accountId, 'accounts', {\n    ...account,\n    ...partial\n  });\n}\nasync function getAccountValue(accountId, key) {\n  var _await$storage$getIte;\n  return (_await$storage$getIte = await _storages__WEBPACK_IMPORTED_MODULE_1__.storage.getItem(key)) === null || _await$storage$getIte === void 0 ? void 0 : _await$storage$getIte[accountId];\n}\nasync function removeAccountValue(accountId, key) {\n  const data = await _storages__WEBPACK_IMPORTED_MODULE_1__.storage.getItem(key);\n  if (!data) return;\n  const {\n    [accountId]: removedValue,\n    ...restData\n  } = data;\n  await _storages__WEBPACK_IMPORTED_MODULE_1__.storage.setItem(key, restData);\n}\nasync function setAccountValue(accountId, key, value) {\n  const data = await _storages__WEBPACK_IMPORTED_MODULE_1__.storage.getItem(key);\n  await _storages__WEBPACK_IMPORTED_MODULE_1__.storage.setItem(key, {\n    ...data,\n    [accountId]: value\n  });\n}\nasync function removeNetworkAccountsValue(network, key) {\n  const data = await _storages__WEBPACK_IMPORTED_MODULE_1__.storage.getItem(key);\n  if (!data) return;\n  for (const accountId of Object.keys(data)) {\n    if ((0,_util_account__WEBPACK_IMPORTED_MODULE_0__.parseAccountId)(accountId).network === network) {\n      delete data[accountId];\n    }\n  }\n  await _storages__WEBPACK_IMPORTED_MODULE_1__.storage.setItem(key, data);\n}\nasync function getCurrentNetwork() {\n  const accountId = await getCurrentAccountId();\n  if (!accountId) return undefined;\n  return (0,_util_account__WEBPACK_IMPORTED_MODULE_0__.parseAccountId)(accountId).network;\n}\nasync function getCurrentAccountIdOrFail() {\n  const accountId = await getCurrentAccountId();\n  if (!accountId) {\n    throw new Error('The user is not authorized in the wallet');\n  }\n  return accountId;\n}\nfunction getCurrentAccountId() {\n  return _storages__WEBPACK_IMPORTED_MODULE_1__.storage.getItem('currentAccountId');\n}\nfunction waitLogin() {\n  return loginPromise;\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/common/accounts.ts?");

/***/ }),

/***/ "./src/api/common/addresses.ts":
/*!*************************************!*\
  !*** ./src/api/common/addresses.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getAddressInfo\": () => (/* binding */ getAddressInfo),\n/* harmony export */   \"getKnownAddresses\": () => (/* binding */ getKnownAddresses),\n/* harmony export */   \"getScamMarkers\": () => (/* binding */ getScamMarkers),\n/* harmony export */   \"tryUpdateKnownAddresses\": () => (/* binding */ tryUpdateKnownAddresses)\n/* harmony export */ });\n/* harmony import */ var _util_iteratees__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/iteratees */ \"./src/util/iteratees.ts\");\n/* harmony import */ var _util_logs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/logs */ \"./src/util/logs.ts\");\n/* harmony import */ var _backend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./backend */ \"./src/api/common/backend.ts\");\n\n\n\nlet knownAddresses = {};\nlet scamMarkers = [];\nasync function tryUpdateKnownAddresses() {\n  try {\n    const data = await (0,_backend__WEBPACK_IMPORTED_MODULE_2__.callBackendGet)('/known-addresses');\n    knownAddresses = (0,_util_iteratees__WEBPACK_IMPORTED_MODULE_0__.mapValues)(data.knownAddresses, value => {\n      return typeof value === 'string' ? {\n        name: value\n      } : value;\n    });\n    scamMarkers = data.scamMarkers.map(x => new RegExp(x, 'i'));\n  } catch (err) {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_1__.logDebugError)('tryUpdateKnownAddresses', err);\n  }\n}\nfunction getKnownAddresses() {\n  return knownAddresses;\n}\nfunction getScamMarkers() {\n  return scamMarkers;\n}\nfunction getAddressInfo(address) {\n  return knownAddresses[address];\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/common/addresses.ts?");

/***/ }),

/***/ "./src/api/common/backend.ts":
/*!***********************************!*\
  !*** ./src/api/common/backend.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"callBackendGet\": () => (/* binding */ callBackendGet),\n/* harmony export */   \"callBackendPost\": () => (/* binding */ callBackendPost)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\n/* harmony import */ var _util_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/fetch */ \"./src/util/fetch.ts\");\n\n\nconst BAD_REQUEST_CODE = 400;\nasync function callBackendPost(path, data, options) {\n  const {\n    authToken,\n    isAllowBadRequest\n  } = options !== null && options !== void 0 ? options : {};\n  const response = await fetch(`${_config__WEBPACK_IMPORTED_MODULE_0__.BRILLIANT_API_BASE_URL}${path}`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      ...(authToken && {\n        'X-Auth-Token': authToken\n      })\n    },\n    body: JSON.stringify(data)\n  });\n  (0,_util_fetch__WEBPACK_IMPORTED_MODULE_1__.handleFetchErrors)(response, isAllowBadRequest ? [BAD_REQUEST_CODE] : undefined);\n  return response.json();\n}\nfunction callBackendGet(path, data, headers) {\n  const url = new URL(`${_config__WEBPACK_IMPORTED_MODULE_0__.BRILLIANT_API_BASE_URL}${path}`);\n  const header = {\n    'Origin': 'https://mytonwallet.app',\n    'Content-Type': 'application/json',\n    'X-App-Origin': 'https://mytonwallet.app'\n  };\n  return (0,_util_fetch__WEBPACK_IMPORTED_MODULE_1__.fetchJson)(url, data, {\n    headers: header\n  });\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/common/backend.ts?");

/***/ }),

/***/ "./src/api/common/cache.ts":
/*!*********************************!*\
  !*** ./src/api/common/cache.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getAccountCache\": () => (/* binding */ getAccountCache),\n/* harmony export */   \"getStakingCommonCache\": () => (/* binding */ getStakingCommonCache),\n/* harmony export */   \"setStakingCommonCache\": () => (/* binding */ setStakingCommonCache),\n/* harmony export */   \"updateAccountCache\": () => (/* binding */ updateAccountCache)\n/* harmony export */ });\nlet stakingCommonCache;\nconst accountCache = {};\nfunction getAccountCache(accountId, address) {\n  var _accountCache;\n  return (_accountCache = accountCache[`${accountId}:${address}`]) !== null && _accountCache !== void 0 ? _accountCache : {};\n}\nfunction updateAccountCache(accountId, address, partial) {\n  const key = `${accountId}:${address}`;\n  accountCache[key] = {\n    ...accountCache[key],\n    ...partial\n  };\n}\nfunction setStakingCommonCache(data) {\n  stakingCommonCache = data;\n}\nfunction getStakingCommonCache() {\n  return stakingCommonCache;\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/common/cache.ts?");

/***/ }),

/***/ "./src/api/common/dappPromises.ts":
/*!****************************************!*\
  !*** ./src/api/common/dappPromises.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createDappPromise\": () => (/* binding */ createDappPromise),\n/* harmony export */   \"rejectAllDappPromises\": () => (/* binding */ rejectAllDappPromises),\n/* harmony export */   \"rejectDappPromise\": () => (/* binding */ rejectDappPromise),\n/* harmony export */   \"resolveDappPromise\": () => (/* binding */ resolveDappPromise)\n/* harmony export */ });\n/* harmony import */ var _util_generateUniqueId__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/generateUniqueId */ \"./src/util/generateUniqueId.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors */ \"./src/api/errors.ts\");\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\nconst deferreds = new Map();\nclass Deferred {\n  constructor() {\n    _defineProperty(this, \"resolve\", void 0);\n    _defineProperty(this, \"reject\", void 0);\n    _defineProperty(this, \"promise\", new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    }));\n  }\n}\nfunction createDappPromise() {\n  let promiseId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0,_util_generateUniqueId__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n  const deferred = new Deferred();\n  deferreds.set(promiseId, deferred);\n  const {\n    promise\n  } = deferred;\n  return {\n    promiseId,\n    promise\n  };\n}\nfunction resolveDappPromise(promiseId, value) {\n  const deferred = deferreds.get(promiseId);\n  if (!deferred) {\n    return;\n  }\n  deferred.resolve(value);\n  deferreds.delete(promiseId);\n}\nfunction rejectDappPromise(promiseId) {\n  let reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Unknown rejection reason';\n  const deferred = deferreds.get(promiseId);\n  if (!deferred) {\n    return;\n  }\n  deferred.reject(new _errors__WEBPACK_IMPORTED_MODULE_1__.ApiUserRejectsError(reason));\n  deferreds.delete(promiseId);\n}\nfunction rejectAllDappPromises(message) {\n  Array.from(deferreds.keys()).forEach(id => {\n    rejectDappPromise(id, message);\n  });\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/common/dappPromises.ts?");

/***/ }),

/***/ "./src/api/common/helpers.ts":
/*!***********************************!*\
  !*** ./src/api/common/helpers.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"buildInternalAccountId\": () => (/* binding */ buildInternalAccountId),\n/* harmony export */   \"buildLocalTransaction\": () => (/* binding */ buildLocalTransaction),\n/* harmony export */   \"connectUpdater\": () => (/* binding */ connectUpdater),\n/* harmony export */   \"disconnectUpdater\": () => (/* binding */ disconnectUpdater),\n/* harmony export */   \"isUpdaterAlive\": () => (/* binding */ isUpdaterAlive),\n/* harmony export */   \"migrateStorage\": () => (/* binding */ migrateStorage),\n/* harmony export */   \"resolveBlockchainKey\": () => (/* binding */ resolveBlockchainKey),\n/* harmony export */   \"startStorageMigration\": () => (/* binding */ startStorageMigration),\n/* harmony export */   \"toInternalAccountId\": () => (/* binding */ toInternalAccountId),\n/* harmony export */   \"updateTransactionMetadata\": () => (/* binding */ updateTransactionMetadata),\n/* harmony export */   \"waitStorageMigration\": () => (/* binding */ waitStorageMigration)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\n/* harmony import */ var _util_account__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/account */ \"./src/util/account.ts\");\n/* harmony import */ var _blockchains_ton_util_tonCore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../blockchains/ton/util/tonCore */ \"./src/api/blockchains/ton/util/tonCore.ts\");\n/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../db */ \"./src/api/db.ts\");\n/* harmony import */ var _environment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../environment */ \"./src/api/environment.ts\");\n/* harmony import */ var _storages__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../storages */ \"./src/api/storages/index.ts\");\n/* harmony import */ var _addresses__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./addresses */ \"./src/api/common/addresses.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils */ \"./src/api/common/utils.ts\");\n\n\n\n\n\n\n\n\nlet localCounter = 0;\nconst getNextLocalId = () => `${Date.now()}|${localCounter++}`;\nconst actualStateVersion = 15;\nlet migrationEnsurePromise;\nfunction resolveBlockchainKey(accountId) {\n  return (0,_util_account__WEBPACK_IMPORTED_MODULE_1__.parseAccountId)(accountId).blockchain;\n}\nfunction toInternalAccountId(accountId) {\n  return buildInternalAccountId((0,_util_account__WEBPACK_IMPORTED_MODULE_1__.parseAccountId)(accountId));\n}\nfunction buildInternalAccountId(account) {\n  const {\n    id,\n    blockchain\n  } = account;\n  return `${id}-${blockchain}`;\n}\nfunction buildLocalTransaction(params, normalizedAddress) {\n  const {\n    amount,\n    ...restParams\n  } = params;\n  const transaction = updateTransactionMetadata({\n    ...restParams,\n    txId: getNextLocalId(),\n    timestamp: Date.now(),\n    isIncoming: false,\n    amount: -amount,\n    normalizedAddress,\n    extraData: {}\n  });\n  return {\n    ...transaction,\n    id: transaction.txId,\n    kind: 'transaction'\n  };\n}\nfunction updateTransactionMetadata(transaction) {\n  const {\n    normalizedAddress,\n    comment\n  } = transaction;\n  let {\n    metadata = {}\n  } = transaction;\n  const knownAddresses = (0,_addresses__WEBPACK_IMPORTED_MODULE_6__.getKnownAddresses)();\n  const scamMarkers = (0,_addresses__WEBPACK_IMPORTED_MODULE_6__.getScamMarkers)();\n  if (normalizedAddress in knownAddresses) {\n    metadata = {\n      ...metadata,\n      ...knownAddresses[normalizedAddress]\n    };\n  }\n  if (comment && scamMarkers.map(sm => sm.test(comment)).find(Boolean)) {\n    metadata.isScam = true;\n  }\n  return {\n    ...transaction,\n    metadata\n  };\n}\nlet currentOnUpdate;\nfunction connectUpdater(onUpdate) {\n  currentOnUpdate = onUpdate;\n}\nfunction disconnectUpdater() {\n  currentOnUpdate = undefined;\n}\nfunction isUpdaterAlive(onUpdate) {\n  return currentOnUpdate === onUpdate;\n}\nfunction startStorageMigration(onUpdate, ton) {\n  migrationEnsurePromise = migrateStorage(onUpdate, ton);\n  return migrationEnsurePromise;\n}\nfunction waitStorageMigration() {\n  return migrationEnsurePromise;\n}\nasync function migrateStorage(onUpdate, ton) {\n  let version = Number(await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.getItem('stateVersion', true));\n  if (version === actualStateVersion) {\n    return;\n  }\n\n  // if (IS_CAPACITOR && !version) {\n  //   if (await storage.getItem('accounts' as StorageKey, true)) {\n  //     // Fix broken version\n  //     version = 10;\n  //   } else {\n  //     // Prepare for migration to secure storage\n  //     const idbVersion = await idbStorage.getItem('stateVersion');\n  //     if (idbVersion) {\n  //       version = Number(idbVersion);\n  //     }\n  //   }\n  // }\n  //\n  // // Migration to chrome.storage\n  // if (IS_EXTENSION && !version && !(await storage.getItem('addresses' as StorageKey))) {\n  //   version = await idbStorage.getItem('stateVersion');\n  //\n  //   if (version) {\n  //     // Switching from IndexedDB to `chrome.storage.local`\n  //     const idbData = await idbStorage.getAll!();\n  //     await storage.setMany!(idbData);\n  //   }\n  // }\n\n  if (!version) {\n    await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.setItem('stateVersion', actualStateVersion);\n    return;\n  }\n\n  // First version (v1)\n  if (!version) {\n    // Support multi-accounts\n    const mnemonicEncrypted = await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.getItem('mnemonicEncrypted');\n    if (mnemonicEncrypted) {\n      await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.setItem('mnemonicsEncrypted', JSON.stringify({\n        [_config__WEBPACK_IMPORTED_MODULE_0__.MAIN_ACCOUNT_ID]: mnemonicEncrypted\n      }));\n      await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.removeItem('mnemonicEncrypted');\n    }\n\n    // Change accountId format ('0' -> '0-ton', '1-ton-mainnet' -> '1-ton')\n    if (!mnemonicEncrypted) {\n      for (const field of ['mnemonicsEncrypted', 'addresses', 'publicKeys']) {\n        const raw = await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.getItem(field);\n        if (!raw) continue;\n        const oldItem = JSON.parse(raw);\n        const newItem = Object.entries(oldItem).reduce((prevValue, _ref) => {\n          let [accountId, data] = _ref;\n          prevValue[toInternalAccountId(accountId)] = data;\n          return prevValue;\n        }, {});\n        await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.setItem(field, JSON.stringify(newItem));\n      }\n    }\n    version = 1;\n    await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.setItem('stateVersion', version);\n  }\n  if (version === 1) {\n    const addresses = await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.getItem('addresses');\n    if (addresses && addresses.includes('-undefined')) {\n      for (const field of ['mnemonicsEncrypted', 'addresses', 'publicKeys']) {\n        const newValue = (await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.getItem(field)).replace('-undefined', '-ton');\n        await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.setItem(field, newValue);\n      }\n    }\n    version = 2;\n    await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.setItem('stateVersion', version);\n  }\n  if (version >= 2 && version <= 4) {\n    for (const key of ['addresses', 'mnemonicsEncrypted', 'publicKeys', 'dapps']) {\n      const rawData = await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.getItem(key);\n      if (typeof rawData === 'string') {\n        await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.setItem(key, JSON.parse(rawData));\n      }\n    }\n    version = 5;\n    await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.setItem('stateVersion', version);\n  }\n  if (version === 5) {\n    const dapps = await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.getItem('dapps');\n    if (dapps) {\n      for (const accountDapps of Object.values(dapps)) {\n        for (const dapp of Object.values(accountDapps)) {\n          dapp.connectedAt = 1;\n        }\n      }\n      await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.setItem('dapps', dapps);\n    }\n    version = 6;\n    await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.setItem('stateVersion', version);\n  }\n  if (version === 6) {\n    for (const key of ['addresses', 'mnemonicsEncrypted', 'publicKeys', 'accounts', 'dapps']) {\n      let data = await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.getItem(key);\n      if (!data) continue;\n      data = Object.entries(data).reduce((byAccountId, _ref2) => {\n        let [internalAccountId, accountData] = _ref2;\n        const parsed = (0,_util_account__WEBPACK_IMPORTED_MODULE_1__.parseAccountId)(internalAccountId);\n        const mainnetAccountId = (0,_util_account__WEBPACK_IMPORTED_MODULE_1__.buildAccountId)({\n          ...parsed,\n          network: 'mainnet'\n        });\n        const testnetAccountId = (0,_util_account__WEBPACK_IMPORTED_MODULE_1__.buildAccountId)({\n          ...parsed,\n          network: 'testnet'\n        });\n        return {\n          ...byAccountId,\n          [mainnetAccountId]: accountData,\n          [testnetAccountId]: accountData\n        };\n      }, {});\n      await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.setItem(key, data);\n    }\n    version = 7;\n    await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.setItem('stateVersion', version);\n  }\n  if (version === 7) {\n    const addresses = await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.getItem('addresses');\n    if (addresses) {\n      var _await$storage$getIte;\n      const publicKeys = await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.getItem('publicKeys');\n      const accounts = (_await$storage$getIte = await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.getItem('accounts')) !== null && _await$storage$getIte !== void 0 ? _await$storage$getIte : {};\n      for (const [accountId, oldAddress] of Object.entries(addresses)) {\n        const newAddress = (0,_blockchains_ton_util_tonCore__WEBPACK_IMPORTED_MODULE_2__.toBase64Address)(oldAddress, false);\n        accounts[accountId] = {\n          ...accounts[accountId],\n          address: newAddress,\n          publicKey: publicKeys[accountId]\n        };\n        onUpdate({\n          type: 'updateAccount',\n          accountId,\n          partial: {\n            address: newAddress\n          }\n        });\n      }\n      await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.setItem('accounts', accounts);\n      await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.removeItem('addresses');\n      await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.removeItem('publicKeys');\n    }\n    version = 8;\n    await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.setItem('stateVersion', version);\n  }\n  if (version === 8) {\n    if ((0,_environment__WEBPACK_IMPORTED_MODULE_4__.getEnvironment)().isSseSupported) {\n      const dapps = await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.getItem('dapps');\n      if (dapps) {\n        const items = [];\n        for (const accountDapps of Object.values(dapps)) {\n          for (const dapp of Object.values(accountDapps)) {\n            var _dapp$sse;\n            if ((_dapp$sse = dapp.sse) !== null && _dapp$sse !== void 0 && _dapp$sse.appClientId) {\n              var _dapp$sse2;\n              items.push({\n                clientId: (_dapp$sse2 = dapp.sse) === null || _dapp$sse2 === void 0 ? void 0 : _dapp$sse2.appClientId\n              });\n            }\n          }\n        }\n        if (items.length) {\n          await _db__WEBPACK_IMPORTED_MODULE_3__.apiDb.sseConnections.bulkPut(items);\n        }\n      }\n    }\n    version = 9;\n    await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.setItem('stateVersion', version);\n  }\n  if (version === 9) {\n    // if (IS_CAPACITOR) {\n    //   const data = await idbStorage.getAll!();\n    //\n    //   for (const [key, value] of Object.entries(data)) {\n    //     await capacitorStorage.setItem(key as StorageKey, value);\n    //     const newValue = await capacitorStorage.getItem(key as StorageKey, true);\n    //\n    //     if (!areDeepEqual(value, newValue)) {\n    //       throw new Error('Migration error!');\n    //     }\n    //   }\n    //   await idbStorage.clear();\n    // }\n\n    version = 10;\n    await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.setItem('stateVersion', version);\n  }\n  if (version === 10 || version === 11 || version === 12) {\n    const accounts = await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.getItem('accounts', true);\n    if (accounts) {\n      for (const account of Object.values(accounts)) {\n        const {\n          publicKey,\n          address,\n          version: walletVersion\n        } = account;\n        if (walletVersion) continue;\n        const publicKeyBytes = (0,_utils__WEBPACK_IMPORTED_MODULE_7__.hexToBytes)(publicKey);\n        const walletInfo = ton.pickWalletByAddress('mainnet', publicKeyBytes, address);\n        account.version = walletInfo.version;\n      }\n      await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.setItem('accounts', accounts);\n    }\n    version = 13;\n    await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.setItem('stateVersion', version);\n  }\n  if (version === 13) {\n    const accounts = await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.getItem('accounts', true);\n    if (accounts) {\n      for (const [accountId, account] of Object.entries(accounts)) {\n        const {\n          network\n        } = (0,_util_account__WEBPACK_IMPORTED_MODULE_1__.parseAccountId)(accountId);\n        if (network === 'testnet') {\n          account.address = (0,_blockchains_ton_util_tonCore__WEBPACK_IMPORTED_MODULE_2__.toBase64Address)(account.address, false, network);\n          onUpdate({\n            type: 'updateAccount',\n            accountId,\n            partial: {\n              address: account.address\n            }\n          });\n        }\n      }\n      await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.setItem('accounts', accounts);\n    }\n  }\n  if (version === 14) {\n    // if (getEnvironment().isIosApp) {\n    //   const keys = await capacitorStorage.getKeys();\n    //\n    //   if (keys?.length) {\n    //     for (const key of keys) {\n    //       const value = await capacitorStorage.getItem(key as StorageKey, true);\n    //       await capacitorStorage.removeItem(key as StorageKey);\n    //       await capacitorStorage.setItem(key as StorageKey, value);\n    //     }\n    //   }\n    // }\n\n    version = 15;\n    await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.setItem('stateVersion', version);\n  }\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/common/helpers.ts?");

/***/ }),

/***/ "./src/api/common/txCallbacks.ts":
/*!***************************************!*\
  !*** ./src/api/common/txCallbacks.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"txCallbacks\": () => (/* binding */ txCallbacks),\n/* harmony export */   \"whenTxComplete\": () => (/* binding */ whenTxComplete)\n/* harmony export */ });\n/* harmony import */ var _util_callbacks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/callbacks */ \"./src/util/callbacks.ts\");\n\nconst txCallbacks = (0,_util_callbacks__WEBPACK_IMPORTED_MODULE_0__.createCallbackManager)();\nfunction whenTxComplete(normalizedAddress, amount) {\n  return new Promise(resolve => {\n    txCallbacks.addCallback(function callback(transaction) {\n      if (transaction.normalizedAddress === normalizedAddress && transaction.amount === -amount) {\n        txCallbacks.removeCallback(callback);\n        resolve({\n          result: true,\n          transaction\n        });\n      }\n    });\n  });\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/common/txCallbacks.ts?");

/***/ }),

/***/ "./src/api/common/utils.ts":
/*!*********************************!*\
  !*** ./src/api/common/utils.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"base64ToBytes\": () => (/* binding */ base64ToBytes),\n/* harmony export */   \"base64ToString\": () => (/* binding */ base64ToString),\n/* harmony export */   \"bytesToBase64\": () => (/* binding */ bytesToBase64),\n/* harmony export */   \"bytesToHex\": () => (/* binding */ bytesToHex),\n/* harmony export */   \"hexToBytes\": () => (/* binding */ hexToBytes),\n/* harmony export */   \"isKnownStakingPool\": () => (/* binding */ isKnownStakingPool),\n/* harmony export */   \"sha256\": () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\nfunction sha256(bytes) {\n  return crypto.subtle.digest('SHA-256', bytes);\n}\nfunction bytesToHex(bytes) {\n  return Buffer.from(bytes).toString('hex');\n}\nfunction hexToBytes(hex) {\n  return Uint8Array.from(Buffer.from(hex, 'hex'));\n}\nfunction bytesToBase64(bytes) {\n  return Buffer.from(bytes).toString('base64');\n}\nfunction base64ToBytes(base64) {\n  return Uint8Array.from(Buffer.from(base64, 'base64'));\n}\nfunction base64ToString(base64) {\n  return Buffer.from(base64, 'base64').toString('utf-8');\n}\nfunction isKnownStakingPool(address) {\n  return _config__WEBPACK_IMPORTED_MODULE_0__.STAKING_POOLS.some(poolPart => address.endsWith(poolPart));\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/common/utils.ts?");

/***/ }),

/***/ "./src/api/db.ts":
/*!***********************!*\
  !*** ./src/api/db.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ApiDb\": () => (/* binding */ ApiDb),\n/* harmony export */   \"apiDb\": () => (/* binding */ apiDb)\n/* harmony export */ });\n/* harmony import */ var _lib_dexie_dexie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/dexie/dexie */ \"./src/lib/dexie/dexie.js\");\n/* harmony import */ var _lib_dexie_dexie__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib_dexie_dexie__WEBPACK_IMPORTED_MODULE_0__);\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar Table = (_lib_dexie_dexie__WEBPACK_IMPORTED_MODULE_0___default().Table);\nconst DB_NANE = 'tables';\nclass ApiDb extends (_lib_dexie_dexie__WEBPACK_IMPORTED_MODULE_0___default()) {\n  constructor() {\n    super(DB_NANE);\n    _defineProperty(this, \"nfts\", void 0);\n    _defineProperty(this, \"sseConnections\", void 0);\n    this.version(1).stores({\n      nfts: '[accountId+address], accountId, address, collectionAddress'\n    });\n    this.version(2).stores({\n      sseConnections: '&clientId'\n    });\n  }\n}\nconst apiDb = new ApiDb();\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/db.ts?");

/***/ }),

/***/ "./src/api/environment.ts":
/*!********************************!*\
  !*** ./src/api/environment.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getEnvironment\": () => (/* binding */ getEnvironment),\n/* harmony export */   \"setEnvironment\": () => (/* binding */ setEnvironment)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ \"./src/config.ts\");\n/*\n * This module is to be used instead of /src/util/environment.ts\n * when `window` is not available (e.g. in a web worker).\n */\n\n\nlet environment;\nfunction setEnvironment(args) {\n  var _self;\n  environment = {\n    ...args,\n    isDappSupported: false,\n    isSseSupported: false,\n    // eslint-disable-next-line no-restricted-globals\n    apiHeaders: {\n      'X-App-Origin': (_self = self) === null || _self === void 0 ? void 0 : _self.origin\n    },\n    tonhttpapiMainnetKey: args.isElectron ? _config__WEBPACK_IMPORTED_MODULE_0__.ELECTRON_TONHTTPAPI_MAINNET_API_KEY : _config__WEBPACK_IMPORTED_MODULE_0__.TONHTTPAPI_MAINNET_API_KEY,\n    tonhttpapiTestnetKey: args.isElectron ? _config__WEBPACK_IMPORTED_MODULE_0__.ELECTRON_TONHTTPAPI_TESTNET_API_KEY : _config__WEBPACK_IMPORTED_MODULE_0__.TONHTTPAPI_TESTNET_API_KEY\n  };\n  return environment;\n}\nfunction getEnvironment() {\n  return environment;\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/environment.ts?");

/***/ }),

/***/ "./src/api/errors.ts":
/*!***************************!*\
  !*** ./src/api/errors.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ApiBaseError\": () => (/* binding */ ApiBaseError),\n/* harmony export */   \"ApiServerError\": () => (/* binding */ ApiServerError),\n/* harmony export */   \"ApiUserRejectsError\": () => (/* binding */ ApiUserRejectsError),\n/* harmony export */   \"handleServerError\": () => (/* binding */ handleServerError),\n/* harmony export */   \"maybeApiErrors\": () => (/* binding */ maybeApiErrors)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./src/api/types/index.ts\");\n// eslint-disable-next-line max-classes-per-file\n\n\nclass ApiBaseError extends Error {\n  constructor(message, displayError) {\n    super(message);\n    this.displayError = displayError;\n    this.name = this.constructor.name;\n  }\n}\nclass ApiUserRejectsError extends ApiBaseError {\n  constructor() {\n    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Canceled by the user';\n    super(message);\n  }\n}\nclass ApiServerError extends ApiBaseError {\n  constructor(message, statusCode) {\n    super(message, _types__WEBPACK_IMPORTED_MODULE_0__.ApiCommonError.ServerError);\n    this.statusCode = statusCode;\n  }\n}\nfunction maybeApiErrors(fn) {\n  return async function () {\n    try {\n      return await fn(...arguments);\n    } catch (err) {\n      return handleServerError(err);\n    }\n  };\n}\nfunction handleServerError(err) {\n  if (err instanceof ApiServerError) {\n    return {\n      error: err.displayError\n    };\n  }\n  throw err;\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/errors.ts?");

/***/ }),

/***/ "./src/api/hooks.ts":
/*!**************************!*\
  !*** ./src/api/hooks.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addHooks\": () => (/* binding */ addHooks),\n/* harmony export */   \"callHook\": () => (/* binding */ callHook)\n/* harmony export */ });\n/* harmony import */ var _util_logs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/logs */ \"./src/util/logs.ts\");\n\nconst hooks = {};\nfunction addHooks(partial) {\n  for (const [name, hook] of Object.entries(partial)) {\n    var _hooks$name;\n    hooks[name] = ((_hooks$name = hooks[name]) !== null && _hooks$name !== void 0 ? _hooks$name : []).concat([hook]);\n  }\n}\nasync function callHook(name) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  for (const hook of (_hooks$name2 = hooks[name]) !== null && _hooks$name2 !== void 0 ? _hooks$name2 : []) {\n    var _hooks$name2;\n    try {\n      // @ts-ignore\n      await hook(...args);\n    } catch (err) {\n      (0,_util_logs__WEBPACK_IMPORTED_MODULE_0__.logDebugError)(`callHooks:${name}`, err);\n    }\n  }\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/hooks.ts?");

/***/ }),

/***/ "./src/api/methods/accounts.ts":
/*!*************************************!*\
  !*** ./src/api/methods/accounts.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"activateAccount\": () => (/* binding */ activateAccount),\n/* harmony export */   \"deactivateAllAccounts\": () => (/* binding */ deactivateAllAccounts),\n/* harmony export */   \"deactivateCurrentAccount\": () => (/* binding */ deactivateCurrentAccount),\n/* harmony export */   \"fetchAccount\": () => (/* binding */ fetchAccount),\n/* harmony export */   \"getActiveAccountId\": () => (/* binding */ getActiveAccountId),\n/* harmony export */   \"isAccountActive\": () => (/* binding */ isAccountActive)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\n/* harmony import */ var _util_account__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/account */ \"./src/util/account.ts\");\n/* harmony import */ var _common_accounts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/accounts */ \"./src/api/common/accounts.ts\");\n/* harmony import */ var _common_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/helpers */ \"./src/api/common/helpers.ts\");\n/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../hooks */ \"./src/api/hooks.ts\");\n/* harmony import */ var _storages__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../storages */ \"./src/api/storages/index.ts\");\n/* harmony import */ var _dapps__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dapps */ \"./src/api/methods/dapps.ts\");\n/* harmony import */ var _polling__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./polling */ \"./src/api/methods/polling.ts\");\n\n\n\n\n\n\n\n\nlet activeAccountId;\nasync function activateAccount(accountId, newestTxIds) {\n  await (0,_common_helpers__WEBPACK_IMPORTED_MODULE_3__.waitStorageMigration)();\n  const prevAccountId = activeAccountId;\n  const isFirstLogin = !prevAccountId;\n  activeAccountId = accountId;\n  await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.setItem('currentAccountId', accountId);\n  (0,_common_accounts__WEBPACK_IMPORTED_MODULE_2__.loginResolve)();\n  if (_config__WEBPACK_IMPORTED_MODULE_0__.IS_EXTENSION) {\n    if (prevAccountId && (0,_util_account__WEBPACK_IMPORTED_MODULE_1__.parseAccountId)(prevAccountId).network !== (0,_util_account__WEBPACK_IMPORTED_MODULE_1__.parseAccountId)(accountId).network) {\n      (0,_dapps__WEBPACK_IMPORTED_MODULE_6__.deactivateAllDapps)();\n    }\n    (0,_hooks__WEBPACK_IMPORTED_MODULE_4__.callHook)('onFirstLogin');\n    (0,_dapps__WEBPACK_IMPORTED_MODULE_6__.onActiveDappAccountUpdated)(accountId);\n  }\n  if (isFirstLogin) {\n    (0,_polling__WEBPACK_IMPORTED_MODULE_7__.sendUpdateTokens)();\n  }\n  void (0,_polling__WEBPACK_IMPORTED_MODULE_7__.setupBalanceBasedPolling)(accountId, newestTxIds);\n  void (0,_polling__WEBPACK_IMPORTED_MODULE_7__.setupStakingPolling)(accountId);\n  void (0,_polling__WEBPACK_IMPORTED_MODULE_7__.setupSwapPolling)(accountId);\n  void (0,_polling__WEBPACK_IMPORTED_MODULE_7__.setupWalletVersionsPolling)(accountId);\n}\nfunction deactivateAllAccounts() {\n  deactivateCurrentAccount();\n  activeAccountId = undefined;\n  if (_config__WEBPACK_IMPORTED_MODULE_0__.IS_EXTENSION) {\n    (0,_dapps__WEBPACK_IMPORTED_MODULE_6__.deactivateAllDapps)();\n    (0,_hooks__WEBPACK_IMPORTED_MODULE_4__.callHook)('onFullLogout');\n  }\n}\nfunction deactivateCurrentAccount() {\n  if (_config__WEBPACK_IMPORTED_MODULE_0__.IS_EXTENSION) {\n    (0,_dapps__WEBPACK_IMPORTED_MODULE_6__.deactivateAccountDapp)(activeAccountId);\n  }\n}\nfunction isAccountActive(accountId) {\n  return activeAccountId === accountId;\n}\nfunction fetchAccount(accountId) {\n  return (0,_common_accounts__WEBPACK_IMPORTED_MODULE_2__.fetchStoredAccount)(accountId);\n}\nfunction getActiveAccountId() {\n  return activeAccountId;\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/methods/accounts.ts?");

/***/ }),

/***/ "./src/api/methods/auth.ts":
/*!*********************************!*\
  !*** ./src/api/methods/auth.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"changePassword\": () => (/* binding */ changePassword),\n/* harmony export */   \"createWallet\": () => (/* binding */ createWallet),\n/* harmony export */   \"generateMnemonic\": () => (/* binding */ generateMnemonic),\n/* harmony export */   \"importMnemonic\": () => (/* binding */ importMnemonic),\n/* harmony export */   \"importNewWalletVersion\": () => (/* binding */ importNewWalletVersion),\n/* harmony export */   \"removeAccount\": () => (/* binding */ removeAccount),\n/* harmony export */   \"removeNetworkAccounts\": () => (/* binding */ removeNetworkAccounts),\n/* harmony export */   \"resetAccounts\": () => (/* binding */ resetAccounts),\n/* harmony export */   \"validateMnemonic\": () => (/* binding */ validateMnemonic)\n/* harmony export */ });\n/* harmony import */ var _blockchains_ton_util_tonCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../blockchains/ton/util/tonCore */ \"./src/api/blockchains/ton/util/tonCore.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types */ \"./src/api/types/index.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\n/* harmony import */ var _util_account__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/account */ \"./src/util/account.ts\");\n/* harmony import */ var _blockchains__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../blockchains */ \"./src/api/blockchains/index.ts\");\n/* harmony import */ var _common_accounts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/accounts */ \"./src/api/common/accounts.ts\");\n/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/utils */ \"./src/api/common/utils.ts\");\n/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../db */ \"./src/api/db.ts\");\n/* harmony import */ var _environment__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../environment */ \"./src/api/environment.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../errors */ \"./src/api/errors.ts\");\n/* harmony import */ var _storages__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../storages */ \"./src/api/storages/index.ts\");\n/* harmony import */ var _accounts__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./accounts */ \"./src/api/methods/accounts.ts\");\n/* harmony import */ var _dapps__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./dapps */ \"./src/api/methods/dapps.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction generateMnemonic() {\n  return _blockchains__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ton.generateMnemonic();\n}\nasync function createWallet(network, mnemonic, password) {\n  const {\n    mnemonicToSeed,\n    seedToKeyPair,\n    publicKeyToAddress\n  } = _blockchains__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ton;\n  if (!(await validateMnemonic(mnemonic))) {\n    throw new Error('Invalid mnemonic');\n  }\n  const seedBase64 = await mnemonicToSeed(mnemonic);\n  const {\n    publicKey\n  } = seedToKeyPair(seedBase64);\n  const version = _config__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_WALLET_VERSION;\n  const address = publicKeyToAddress(network, publicKey, version);\n  const accountId = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_5__.getNewAccountId)(network);\n  const result = await storeAccount(accountId, mnemonic, password, {\n    address,\n    publicKey: (0,_common_utils__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(publicKey),\n    version\n  });\n  if ('error' in result) {\n    return result;\n  }\n  void (0,_accounts__WEBPACK_IMPORTED_MODULE_11__.activateAccount)(accountId);\n  return {\n    accountId,\n    address\n  };\n}\nfunction validateMnemonic(mnemonic) {\n  return _blockchains__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ton.validateMnemonic(mnemonic);\n}\nasync function importMnemonic(network, mnemonic, password) {\n  const {\n    mnemonicToSeed,\n    seedToKeyPair,\n    pickBestWallet\n  } = _blockchains__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ton;\n  if (!(await validateMnemonic(mnemonic))) {\n    throw new Error('Invalid mnemonic');\n  }\n  const seedBase64 = await mnemonicToSeed(mnemonic);\n  const {\n    publicKey\n  } = seedToKeyPair(seedBase64);\n  let wallet;\n  let version;\n  try {\n    ({\n      wallet,\n      version\n    } = await pickBestWallet(network, publicKey));\n  } catch (err) {\n    return (0,_errors__WEBPACK_IMPORTED_MODULE_9__.handleServerError)(err);\n  }\n  const address = (0,_blockchains_ton_util_tonCore__WEBPACK_IMPORTED_MODULE_0__.toBase64Address)(wallet.address, false, network);\n  const accountId = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_5__.getNewAccountId)(network);\n  const result = await storeAccount(accountId, mnemonic, password, {\n    publicKey: (0,_common_utils__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(publicKey),\n    address,\n    version\n  });\n  if ('error' in result) {\n    return result;\n  }\n  void (0,_accounts__WEBPACK_IMPORTED_MODULE_11__.activateAccount)(accountId);\n  return {\n    accountId,\n    address\n  };\n}\nasync function importNewWalletVersion(accountId, version) {\n  const {\n    publicKeyToAddress\n  } = _blockchains__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ton;\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_3__.parseAccountId)(accountId);\n  const account = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_5__.fetchStoredAccount)(accountId);\n  const mnemonicEncrypted = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_5__.getAccountValue)(accountId, 'mnemonicsEncrypted');\n  const publicKey = (0,_common_utils__WEBPACK_IMPORTED_MODULE_6__.hexToBytes)(account.publicKey);\n  const newAddress = publicKeyToAddress(network, publicKey, version);\n  const newAccountId = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_5__.getNewAccountId)(network);\n  const newAccount = {\n    address: newAddress,\n    publicKey: account.publicKey,\n    version\n  };\n  await Promise.all([(0,_common_accounts__WEBPACK_IMPORTED_MODULE_5__.setAccountValue)(newAccountId, 'mnemonicsEncrypted', mnemonicEncrypted), (0,_common_accounts__WEBPACK_IMPORTED_MODULE_5__.setAccountValue)(newAccountId, 'accounts', newAccount)]);\n  void (0,_accounts__WEBPACK_IMPORTED_MODULE_11__.activateAccount)(newAccountId);\n  return {\n    accountId: newAccountId,\n    address: newAddress\n  };\n}\nasync function storeAccount(accountId, mnemonic, password, account) {\n  const mnemonicEncrypted = await _blockchains__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ton.encryptMnemonic(mnemonic, password);\n\n  // This is a defensive approach against potential corrupted encryption reported by some users\n  const decryptedMnemonic = await _blockchains__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ton.decryptMnemonic(mnemonicEncrypted, password).catch(() => undefined);\n  if (!password || !decryptedMnemonic) {\n    return {\n      error: _types__WEBPACK_IMPORTED_MODULE_1__.ApiCommonError.DebugError\n    };\n  }\n  await Promise.all([(0,_common_accounts__WEBPACK_IMPORTED_MODULE_5__.setAccountValue)(accountId, 'mnemonicsEncrypted', mnemonicEncrypted), (0,_common_accounts__WEBPACK_IMPORTED_MODULE_5__.setAccountValue)(accountId, 'accounts', account)]);\n  return {};\n}\nasync function removeNetworkAccounts(network) {\n  (0,_accounts__WEBPACK_IMPORTED_MODULE_11__.deactivateAllAccounts)();\n  await Promise.all([(0,_common_accounts__WEBPACK_IMPORTED_MODULE_5__.removeNetworkAccountsValue)(network, 'mnemonicsEncrypted'), (0,_common_accounts__WEBPACK_IMPORTED_MODULE_5__.removeNetworkAccountsValue)(network, 'accounts'), (0,_environment__WEBPACK_IMPORTED_MODULE_8__.getEnvironment)().isDappSupported && (0,_dapps__WEBPACK_IMPORTED_MODULE_12__.removeNetworkDapps)(network)]);\n}\nasync function resetAccounts() {\n  (0,_accounts__WEBPACK_IMPORTED_MODULE_11__.deactivateAllAccounts)();\n  await Promise.all([_storages__WEBPACK_IMPORTED_MODULE_10__.storage.removeItem('mnemonicsEncrypted'), _storages__WEBPACK_IMPORTED_MODULE_10__.storage.removeItem('accounts'), _storages__WEBPACK_IMPORTED_MODULE_10__.storage.removeItem('currentAccountId'), (0,_environment__WEBPACK_IMPORTED_MODULE_8__.getEnvironment)().isDappSupported && (0,_dapps__WEBPACK_IMPORTED_MODULE_12__.removeAllDapps)(), _db__WEBPACK_IMPORTED_MODULE_7__.apiDb.nfts.clear()]);\n}\nasync function removeAccount(accountId, nextAccountId, newestTxIds) {\n  await Promise.all([(0,_common_accounts__WEBPACK_IMPORTED_MODULE_5__.removeAccountValue)(accountId, 'mnemonicsEncrypted'), (0,_common_accounts__WEBPACK_IMPORTED_MODULE_5__.removeAccountValue)(accountId, 'accounts'), (0,_environment__WEBPACK_IMPORTED_MODULE_8__.getEnvironment)().isDappSupported && (0,_dapps__WEBPACK_IMPORTED_MODULE_12__.removeAccountDapps)(accountId), _db__WEBPACK_IMPORTED_MODULE_7__.apiDb.nfts.where({\n    accountId\n  }).delete()]);\n  (0,_accounts__WEBPACK_IMPORTED_MODULE_11__.deactivateCurrentAccount)();\n  await (0,_accounts__WEBPACK_IMPORTED_MODULE_11__.activateAccount)(nextAccountId, newestTxIds);\n}\nasync function changePassword(oldPassword, password) {\n  for (const accountId of await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_5__.getAccountIds)()) {\n    const mnemonic = await _blockchains__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ton.fetchMnemonic(accountId, oldPassword);\n    if (!mnemonic) {\n      throw new Error('Incorrect password');\n    }\n    const encryptedMnemonic = await _blockchains__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ton.encryptMnemonic(mnemonic, password);\n    await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_5__.setAccountValue)(accountId, 'mnemonicsEncrypted', encryptedMnemonic);\n  }\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/methods/auth.ts?");

/***/ }),

/***/ "./src/api/methods/dapps.ts":
/*!**********************************!*\
  !*** ./src/api/methods/dapps.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"activateDapp\": () => (/* binding */ activateDapp),\n/* harmony export */   \"addDapp\": () => (/* binding */ addDapp),\n/* harmony export */   \"deactivateAccountDapp\": () => (/* binding */ deactivateAccountDapp),\n/* harmony export */   \"deactivateAllDapps\": () => (/* binding */ deactivateAllDapps),\n/* harmony export */   \"deactivateDapp\": () => (/* binding */ deactivateDapp),\n/* harmony export */   \"deleteAllDapps\": () => (/* binding */ deleteAllDapps),\n/* harmony export */   \"deleteDapp\": () => (/* binding */ deleteDapp),\n/* harmony export */   \"fetchDappCatalog\": () => (/* binding */ fetchDappCatalog),\n/* harmony export */   \"findActiveDappAccount\": () => (/* binding */ findActiveDappAccount),\n/* harmony export */   \"findLastConnectedAccount\": () => (/* binding */ findLastConnectedAccount),\n/* harmony export */   \"getActiveDapp\": () => (/* binding */ getActiveDapp),\n/* harmony export */   \"getDapp\": () => (/* binding */ getDapp),\n/* harmony export */   \"getDapps\": () => (/* binding */ getDapps),\n/* harmony export */   \"getDappsByOrigin\": () => (/* binding */ getDappsByOrigin),\n/* harmony export */   \"getDappsState\": () => (/* binding */ getDappsState),\n/* harmony export */   \"getSseLastEventId\": () => (/* binding */ getSseLastEventId),\n/* harmony export */   \"initDapps\": () => (/* binding */ initDapps),\n/* harmony export */   \"isDappActive\": () => (/* binding */ isDappActive),\n/* harmony export */   \"onActiveDappAccountUpdated\": () => (/* binding */ onActiveDappAccountUpdated),\n/* harmony export */   \"removeAccountDapps\": () => (/* binding */ removeAccountDapps),\n/* harmony export */   \"removeAllDapps\": () => (/* binding */ removeAllDapps),\n/* harmony export */   \"removeNetworkDapps\": () => (/* binding */ removeNetworkDapps),\n/* harmony export */   \"setSseLastEventId\": () => (/* binding */ setSseLastEventId),\n/* harmony export */   \"updateDapp\": () => (/* binding */ updateDapp)\n/* harmony export */ });\n/* harmony import */ var _util_account__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/account */ \"./src/util/account.ts\");\n/* harmony import */ var _common_accounts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/accounts */ \"./src/api/common/accounts.ts\");\n/* harmony import */ var _common_backend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/backend */ \"./src/api/common/backend.ts\");\n/* harmony import */ var _common_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/helpers */ \"./src/api/common/helpers.ts\");\n/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../hooks */ \"./src/api/hooks.ts\");\n/* harmony import */ var _storages__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../storages */ \"./src/api/storages/index.ts\");\n\n\n\n\n\n\nconst activeDappByAccountId = {};\nlet onUpdate;\nfunction initDapps(_onUpdate) {\n  onUpdate = _onUpdate;\n}\nfunction onActiveDappAccountUpdated(accountId) {\n  const activeDappOrigin = getActiveDapp(accountId);\n  onUpdate({\n    type: 'updateActiveDapp',\n    accountId,\n    origin: activeDappOrigin\n  });\n}\nfunction activateDapp(accountId, origin) {\n  const oldAccountId = findActiveDappAccount(origin);\n  activeDappByAccountId[accountId] = origin;\n\n  // The method can be called in headless mode (tonConnect:reconnect)\n  if (!onUpdate || !(0,_common_helpers__WEBPACK_IMPORTED_MODULE_3__.isUpdaterAlive)(onUpdate)) {\n    return;\n  }\n  if (oldAccountId) {\n    onUpdate({\n      type: 'updateActiveDapp',\n      accountId: oldAccountId\n    });\n  }\n  onUpdate({\n    type: 'updateActiveDapp',\n    accountId,\n    origin\n  });\n}\nfunction getActiveDapp(accountId) {\n  return activeDappByAccountId[accountId];\n}\nfunction deactivateDapp(origin) {\n  const accountId = findActiveDappAccount(origin);\n  if (!accountId) {\n    return false;\n  }\n  deactivateAccountDapp(accountId);\n  return true;\n}\nfunction findActiveDappAccount(origin) {\n  return Object.keys(activeDappByAccountId).find(acc => origin === activeDappByAccountId[acc]);\n}\nfunction deactivateAccountDapp(accountId) {\n  const activeOrigin = activeDappByAccountId[accountId];\n  if (!activeOrigin) {\n    return false;\n  }\n  delete activeDappByAccountId[accountId];\n  if (onUpdate && (0,_common_helpers__WEBPACK_IMPORTED_MODULE_3__.isUpdaterAlive)(onUpdate)) {\n    onUpdate({\n      type: 'updateActiveDapp',\n      accountId\n    });\n  }\n  return true;\n}\nfunction deactivateAllDapps() {\n  for (const [accountId, value] of Object.entries(activeDappByAccountId)) {\n    if (!value) {\n      continue;\n    }\n    delete activeDappByAccountId[accountId];\n    onUpdate({\n      type: 'updateActiveDapp',\n      accountId\n    });\n  }\n}\nfunction isDappActive(accountId, origin) {\n  return activeDappByAccountId[accountId] === origin;\n}\nasync function updateDapp(accountId, origin, updater) {\n  const dapp = await getDapp(accountId, origin);\n  await addDapp(accountId, updater(dapp));\n}\nasync function getDapp(accountId, origin) {\n  return (await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_1__.getAccountValue)(accountId, 'dapps'))[origin];\n}\nasync function addDapp(accountId, dapp) {\n  const dapps = await getDappsByOrigin(accountId);\n  dapps[dapp.origin] = dapp;\n  await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_1__.setAccountValue)(accountId, 'dapps', dapps);\n}\nasync function deleteDapp(accountId, origin, dontNotifyDapp) {\n  const dapps = await getDappsByOrigin(accountId);\n  if (!(origin in dapps)) {\n    return false;\n  }\n  if (isDappActive(accountId, origin)) {\n    deactivateAccountDapp(accountId);\n  }\n  delete dapps[origin];\n  await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_1__.setAccountValue)(accountId, 'dapps', dapps);\n  if (onUpdate && (0,_common_helpers__WEBPACK_IMPORTED_MODULE_3__.isUpdaterAlive)(onUpdate)) {\n    onUpdate({\n      type: 'dappDisconnect',\n      accountId,\n      origin\n    });\n  }\n  if (!dontNotifyDapp) {\n    await (0,_hooks__WEBPACK_IMPORTED_MODULE_4__.callHook)('onDappDisconnected', accountId, origin);\n  }\n  await (0,_hooks__WEBPACK_IMPORTED_MODULE_4__.callHook)('onDappsChanged');\n  return true;\n}\nasync function deleteAllDapps(accountId) {\n  deactivateAccountDapp(accountId);\n  const origins = Object.keys(await getDappsByOrigin(accountId));\n  await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_1__.setAccountValue)(accountId, 'dapps', {});\n  origins.forEach(origin => {\n    onUpdate({\n      type: 'dappDisconnect',\n      accountId,\n      origin\n    });\n    (0,_hooks__WEBPACK_IMPORTED_MODULE_4__.callHook)('onDappDisconnected', accountId, origin);\n  });\n  await (0,_hooks__WEBPACK_IMPORTED_MODULE_4__.callHook)('onDappsChanged');\n}\nasync function getDapps(accountId) {\n  return Object.values(await getDappsByOrigin(accountId));\n}\nasync function getDappsByOrigin(accountId) {\n  return (await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_1__.getAccountValue)(accountId, 'dapps')) || {};\n}\nasync function findLastConnectedAccount(network, origin) {\n  const dapps = (await getDappsState()) || {};\n  let connectedAt = 0;\n  let lastConnectedAccountId;\n  Object.entries(dapps).forEach(_ref => {\n    let [accountId, byOrigin] = _ref;\n    if (!(origin in byOrigin)) return;\n    if (byOrigin[origin].connectedAt > connectedAt) {\n      connectedAt = byOrigin[origin].connectedAt;\n      lastConnectedAccountId = accountId;\n    }\n  });\n  if (!lastConnectedAccountId) {\n    return undefined;\n  }\n  return (0,_util_account__WEBPACK_IMPORTED_MODULE_0__.buildAccountId)({\n    ...(0,_util_account__WEBPACK_IMPORTED_MODULE_0__.parseAccountId)(lastConnectedAccountId),\n    network\n  });\n}\nfunction getDappsState() {\n  return _storages__WEBPACK_IMPORTED_MODULE_5__.storage.getItem('dapps');\n}\nasync function removeAccountDapps(accountId) {\n  await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_1__.removeAccountValue)(accountId, 'dapps');\n  (0,_hooks__WEBPACK_IMPORTED_MODULE_4__.callHook)('onDappsChanged');\n}\nasync function removeAllDapps() {\n  await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.removeItem('dapps');\n  await (0,_hooks__WEBPACK_IMPORTED_MODULE_4__.callHook)('onDappsChanged');\n}\nfunction removeNetworkDapps(network) {\n  return (0,_common_accounts__WEBPACK_IMPORTED_MODULE_1__.removeNetworkAccountsValue)(network, 'dapps');\n}\nfunction getSseLastEventId() {\n  return _storages__WEBPACK_IMPORTED_MODULE_5__.storage.getItem('sseLastEventId');\n}\nfunction setSseLastEventId(lastEventId) {\n  return _storages__WEBPACK_IMPORTED_MODULE_5__.storage.setItem('sseLastEventId', lastEventId);\n}\nfunction fetchDappCatalog() {\n  return (0,_common_backend__WEBPACK_IMPORTED_MODULE_2__.callBackendGet)('/dapp/catalog');\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/methods/dapps.ts?");

/***/ }),

/***/ "./src/api/methods/index.ts":
/*!**********************************!*\
  !*** ./src/api/methods/index.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"activateAccount\": () => (/* reexport safe */ _accounts__WEBPACK_IMPORTED_MODULE_5__.activateAccount),\n/* harmony export */   \"buildTokenSlug\": () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_7__.buildTokenSlug),\n/* harmony export */   \"cancelDappRequest\": () => (/* reexport safe */ _wallet__WEBPACK_IMPORTED_MODULE_1__.cancelDappRequest),\n/* harmony export */   \"changePassword\": () => (/* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_0__.changePassword),\n/* harmony export */   \"checkApiAvailability\": () => (/* reexport safe */ _other__WEBPACK_IMPORTED_MODULE_11__.checkApiAvailability),\n/* harmony export */   \"checkStakeDraft\": () => (/* reexport safe */ _staking__WEBPACK_IMPORTED_MODULE_6__.checkStakeDraft),\n/* harmony export */   \"checkTransactionDraft\": () => (/* reexport safe */ _transactions__WEBPACK_IMPORTED_MODULE_2__.checkTransactionDraft),\n/* harmony export */   \"checkUnstakeDraft\": () => (/* reexport safe */ _staking__WEBPACK_IMPORTED_MODULE_6__.checkUnstakeDraft),\n/* harmony export */   \"confirmDappRequest\": () => (/* reexport safe */ _wallet__WEBPACK_IMPORTED_MODULE_1__.confirmDappRequest),\n/* harmony export */   \"confirmDappRequestConnect\": () => (/* reexport safe */ _wallet__WEBPACK_IMPORTED_MODULE_1__.confirmDappRequestConnect),\n/* harmony export */   \"createLocalTransaction\": () => (/* reexport safe */ _transactions__WEBPACK_IMPORTED_MODULE_2__.createLocalTransaction),\n/* harmony export */   \"createWallet\": () => (/* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_0__.createWallet),\n/* harmony export */   \"deactivateAllAccounts\": () => (/* reexport safe */ _accounts__WEBPACK_IMPORTED_MODULE_5__.deactivateAllAccounts),\n/* harmony export */   \"deactivateCurrentAccount\": () => (/* reexport safe */ _accounts__WEBPACK_IMPORTED_MODULE_5__.deactivateCurrentAccount),\n/* harmony export */   \"deactivateDapp\": () => (/* reexport safe */ _dapps__WEBPACK_IMPORTED_MODULE_8__.deactivateDapp),\n/* harmony export */   \"decryptComment\": () => (/* reexport safe */ _transactions__WEBPACK_IMPORTED_MODULE_2__.decryptComment),\n/* harmony export */   \"deleteAllDapps\": () => (/* reexport safe */ _dapps__WEBPACK_IMPORTED_MODULE_8__.deleteAllDapps),\n/* harmony export */   \"deleteDapp\": () => (/* reexport safe */ _dapps__WEBPACK_IMPORTED_MODULE_8__.deleteDapp),\n/* harmony export */   \"fetchAccount\": () => (/* reexport safe */ _accounts__WEBPACK_IMPORTED_MODULE_5__.fetchAccount),\n/* harmony export */   \"fetchAccountConfigForDebugPurposesOnly\": () => (/* reexport safe */ _other__WEBPACK_IMPORTED_MODULE_11__.fetchAccountConfigForDebugPurposesOnly),\n/* harmony export */   \"fetchAddress\": () => (/* reexport safe */ _wallet__WEBPACK_IMPORTED_MODULE_1__.fetchAddress),\n/* harmony export */   \"fetchAllActivitySlice\": () => (/* reexport safe */ _transactions__WEBPACK_IMPORTED_MODULE_2__.fetchAllActivitySlice),\n/* harmony export */   \"fetchBackendStakingState\": () => (/* reexport safe */ _staking__WEBPACK_IMPORTED_MODULE_6__.fetchBackendStakingState),\n/* harmony export */   \"fetchDappCatalog\": () => (/* reexport safe */ _dapps__WEBPACK_IMPORTED_MODULE_8__.fetchDappCatalog),\n/* harmony export */   \"fetchNfts\": () => (/* reexport safe */ _nfts__WEBPACK_IMPORTED_MODULE_3__.fetchNfts),\n/* harmony export */   \"fetchPriceHistory\": () => (/* reexport safe */ _prices__WEBPACK_IMPORTED_MODULE_12__.fetchPriceHistory),\n/* harmony export */   \"fetchToken\": () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_7__.fetchToken),\n/* harmony export */   \"fetchTokenActivitySlice\": () => (/* reexport safe */ _transactions__WEBPACK_IMPORTED_MODULE_2__.fetchTokenActivitySlice),\n/* harmony export */   \"fetchTokenBalances\": () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_7__.fetchTokenBalances),\n/* harmony export */   \"fetchTokenBalancesByAddress\": () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_7__.fetchTokenBalancesByAddress),\n/* harmony export */   \"generateMnemonic\": () => (/* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_0__.generateMnemonic),\n/* harmony export */   \"getActiveAccountId\": () => (/* reexport safe */ _accounts__WEBPACK_IMPORTED_MODULE_5__.getActiveAccountId),\n/* harmony export */   \"getActiveDapp\": () => (/* reexport safe */ _dapps__WEBPACK_IMPORTED_MODULE_8__.getActiveDapp),\n/* harmony export */   \"getBackendAuthToken\": () => (/* reexport safe */ _other__WEBPACK_IMPORTED_MODULE_11__.getBackendAuthToken),\n/* harmony export */   \"getBackendStakingState\": () => (/* reexport safe */ _staking__WEBPACK_IMPORTED_MODULE_6__.getBackendStakingState),\n/* harmony export */   \"getBaseCurrency\": () => (/* reexport safe */ _prices__WEBPACK_IMPORTED_MODULE_12__.getBaseCurrency),\n/* harmony export */   \"getClientId\": () => (/* reexport safe */ _other__WEBPACK_IMPORTED_MODULE_11__.getClientId),\n/* harmony export */   \"getDapps\": () => (/* reexport safe */ _dapps__WEBPACK_IMPORTED_MODULE_8__.getDapps),\n/* harmony export */   \"getDappsByOrigin\": () => (/* reexport safe */ _dapps__WEBPACK_IMPORTED_MODULE_8__.getDappsByOrigin),\n/* harmony export */   \"getMnemonic\": () => (/* reexport safe */ _wallet__WEBPACK_IMPORTED_MODULE_1__.getMnemonic),\n/* harmony export */   \"getMnemonicWordList\": () => (/* reexport safe */ _wallet__WEBPACK_IMPORTED_MODULE_1__.getMnemonicWordList),\n/* harmony export */   \"getStakingHistory\": () => (/* reexport safe */ _staking__WEBPACK_IMPORTED_MODULE_6__.getStakingHistory),\n/* harmony export */   \"getWalletBalance\": () => (/* reexport safe */ _wallet__WEBPACK_IMPORTED_MODULE_1__.getWalletBalance),\n/* harmony export */   \"getWalletSeqno\": () => (/* reexport safe */ _wallet__WEBPACK_IMPORTED_MODULE_1__.getWalletSeqno),\n/* harmony export */   \"importMnemonic\": () => (/* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_0__.importMnemonic),\n/* harmony export */   \"importNewWalletVersion\": () => (/* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_0__.importNewWalletVersion),\n/* harmony export */   \"initDapps\": () => (/* reexport safe */ _dapps__WEBPACK_IMPORTED_MODULE_8__.initDapps),\n/* harmony export */   \"initNfts\": () => (/* reexport safe */ _nfts__WEBPACK_IMPORTED_MODULE_3__.initNfts),\n/* harmony export */   \"initPolling\": () => (/* reexport safe */ _polling__WEBPACK_IMPORTED_MODULE_4__.initPolling),\n/* harmony export */   \"initStaking\": () => (/* reexport safe */ _staking__WEBPACK_IMPORTED_MODULE_6__.initStaking),\n/* harmony export */   \"initSwap\": () => (/* reexport safe */ _swap__WEBPACK_IMPORTED_MODULE_10__.initSwap),\n/* harmony export */   \"initTransactions\": () => (/* reexport safe */ _transactions__WEBPACK_IMPORTED_MODULE_2__.initTransactions),\n/* harmony export */   \"isAccountActive\": () => (/* reexport safe */ _accounts__WEBPACK_IMPORTED_MODULE_5__.isAccountActive),\n/* harmony export */   \"isWalletInitialized\": () => (/* reexport safe */ _wallet__WEBPACK_IMPORTED_MODULE_1__.isWalletInitialized),\n/* harmony export */   \"onStakingChangeExpected\": () => (/* reexport safe */ _staking__WEBPACK_IMPORTED_MODULE_6__.onStakingChangeExpected),\n/* harmony export */   \"ping\": () => (/* reexport safe */ _other__WEBPACK_IMPORTED_MODULE_11__.ping),\n/* harmony export */   \"processNftUpdates\": () => (/* reexport safe */ _nfts__WEBPACK_IMPORTED_MODULE_3__.processNftUpdates),\n/* harmony export */   \"removeAccount\": () => (/* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_0__.removeAccount),\n/* harmony export */   \"removeNetworkAccounts\": () => (/* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_0__.removeNetworkAccounts),\n/* harmony export */   \"resetAccounts\": () => (/* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_0__.resetAccounts),\n/* harmony export */   \"resolveDataPreloadPromise\": () => (/* reexport safe */ _preload__WEBPACK_IMPORTED_MODULE_13__.resolveDataPreloadPromise),\n/* harmony export */   \"resolveTokenBySlug\": () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_7__.resolveTokenBySlug),\n/* harmony export */   \"resolveTokenMinterAddress\": () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_7__.resolveTokenMinterAddress),\n/* harmony export */   \"resolveTokenWalletAddress\": () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_7__.resolveTokenWalletAddress),\n/* harmony export */   \"sendSignedTransferMessage\": () => (/* reexport safe */ _transactions__WEBPACK_IMPORTED_MODULE_2__.sendSignedTransferMessage),\n/* harmony export */   \"sendSignedTransferMessages\": () => (/* reexport safe */ _transactions__WEBPACK_IMPORTED_MODULE_2__.sendSignedTransferMessages),\n/* harmony export */   \"sendUpdateTokens\": () => (/* reexport safe */ _polling__WEBPACK_IMPORTED_MODULE_4__.sendUpdateTokens),\n/* harmony export */   \"setBaseCurrency\": () => (/* reexport safe */ _prices__WEBPACK_IMPORTED_MODULE_12__.setBaseCurrency),\n/* harmony export */   \"setIsAppFocused\": () => (/* reexport safe */ _other__WEBPACK_IMPORTED_MODULE_11__.setIsAppFocused),\n/* harmony export */   \"setupBackendPolling\": () => (/* reexport safe */ _polling__WEBPACK_IMPORTED_MODULE_4__.setupBackendPolling),\n/* harmony export */   \"setupBalanceBasedPolling\": () => (/* reexport safe */ _polling__WEBPACK_IMPORTED_MODULE_4__.setupBalanceBasedPolling),\n/* harmony export */   \"setupLongBackendPolling\": () => (/* reexport safe */ _polling__WEBPACK_IMPORTED_MODULE_4__.setupLongBackendPolling),\n/* harmony export */   \"setupStakingPolling\": () => (/* reexport safe */ _polling__WEBPACK_IMPORTED_MODULE_4__.setupStakingPolling),\n/* harmony export */   \"setupSwapPolling\": () => (/* reexport safe */ _polling__WEBPACK_IMPORTED_MODULE_4__.setupSwapPolling),\n/* harmony export */   \"setupWalletVersionsPolling\": () => (/* reexport safe */ _polling__WEBPACK_IMPORTED_MODULE_4__.setupWalletVersionsPolling),\n/* harmony export */   \"startSseConnection\": () => (/* reexport safe */ _tonConnect_sse__WEBPACK_IMPORTED_MODULE_9__.startSseConnection),\n/* harmony export */   \"submitStake\": () => (/* reexport safe */ _staking__WEBPACK_IMPORTED_MODULE_6__.submitStake),\n/* harmony export */   \"submitTransfer\": () => (/* reexport safe */ _transactions__WEBPACK_IMPORTED_MODULE_2__.submitTransfer),\n/* harmony export */   \"submitUnstake\": () => (/* reexport safe */ _staking__WEBPACK_IMPORTED_MODULE_6__.submitUnstake),\n/* harmony export */   \"swapBuild\": () => (/* reexport safe */ _swap__WEBPACK_IMPORTED_MODULE_10__.swapBuild),\n/* harmony export */   \"swapBuildTransfer\": () => (/* reexport safe */ _swap__WEBPACK_IMPORTED_MODULE_10__.swapBuildTransfer),\n/* harmony export */   \"swapCexCreateTransaction\": () => (/* reexport safe */ _swap__WEBPACK_IMPORTED_MODULE_10__.swapCexCreateTransaction),\n/* harmony export */   \"swapCexEstimate\": () => (/* reexport safe */ _swap__WEBPACK_IMPORTED_MODULE_10__.swapCexEstimate),\n/* harmony export */   \"swapCexValidateAddress\": () => (/* reexport safe */ _swap__WEBPACK_IMPORTED_MODULE_10__.swapCexValidateAddress),\n/* harmony export */   \"swapEstimate\": () => (/* reexport safe */ _swap__WEBPACK_IMPORTED_MODULE_10__.swapEstimate),\n/* harmony export */   \"swapGetAssets\": () => (/* reexport safe */ _swap__WEBPACK_IMPORTED_MODULE_10__.swapGetAssets),\n/* harmony export */   \"swapGetHistory\": () => (/* reexport safe */ _swap__WEBPACK_IMPORTED_MODULE_10__.swapGetHistory),\n/* harmony export */   \"swapGetHistoryByRanges\": () => (/* reexport safe */ _swap__WEBPACK_IMPORTED_MODULE_10__.swapGetHistoryByRanges),\n/* harmony export */   \"swapGetHistoryItem\": () => (/* reexport safe */ _swap__WEBPACK_IMPORTED_MODULE_10__.swapGetHistoryItem),\n/* harmony export */   \"swapGetPairs\": () => (/* reexport safe */ _swap__WEBPACK_IMPORTED_MODULE_10__.swapGetPairs),\n/* harmony export */   \"swapGetTonCurrencies\": () => (/* reexport safe */ _swap__WEBPACK_IMPORTED_MODULE_10__.swapGetTonCurrencies),\n/* harmony export */   \"swapItemToActivity\": () => (/* reexport safe */ _swap__WEBPACK_IMPORTED_MODULE_10__.swapItemToActivity),\n/* harmony export */   \"swapReplaceTransactions\": () => (/* reexport safe */ _swap__WEBPACK_IMPORTED_MODULE_10__.swapReplaceTransactions),\n/* harmony export */   \"swapReplaceTransactionsByRanges\": () => (/* reexport safe */ _swap__WEBPACK_IMPORTED_MODULE_10__.swapReplaceTransactionsByRanges),\n/* harmony export */   \"swapSubmit\": () => (/* reexport safe */ _swap__WEBPACK_IMPORTED_MODULE_10__.swapSubmit),\n/* harmony export */   \"tryLoadSwapTokens\": () => (/* reexport safe */ _polling__WEBPACK_IMPORTED_MODULE_4__.tryLoadSwapTokens),\n/* harmony export */   \"tryUpdateConfig\": () => (/* reexport safe */ _polling__WEBPACK_IMPORTED_MODULE_4__.tryUpdateConfig),\n/* harmony export */   \"tryUpdatePrices\": () => (/* reexport safe */ _polling__WEBPACK_IMPORTED_MODULE_4__.tryUpdatePrices),\n/* harmony export */   \"tryUpdateStakingCommonData\": () => (/* reexport safe */ _staking__WEBPACK_IMPORTED_MODULE_6__.tryUpdateStakingCommonData),\n/* harmony export */   \"tryUpdateTokens\": () => (/* reexport safe */ _polling__WEBPACK_IMPORTED_MODULE_4__.tryUpdateTokens),\n/* harmony export */   \"updateNfts\": () => (/* reexport safe */ _nfts__WEBPACK_IMPORTED_MODULE_3__.updateNfts),\n/* harmony export */   \"validateMnemonic\": () => (/* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_0__.validateMnemonic),\n/* harmony export */   \"verifyPassword\": () => (/* reexport safe */ _wallet__WEBPACK_IMPORTED_MODULE_1__.verifyPassword),\n/* harmony export */   \"waitDataPreload\": () => (/* reexport safe */ _preload__WEBPACK_IMPORTED_MODULE_13__.waitDataPreload),\n/* harmony export */   \"waitLastTransfer\": () => (/* reexport safe */ _transactions__WEBPACK_IMPORTED_MODULE_2__.waitLastTransfer)\n/* harmony export */ });\n/* harmony import */ var _auth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./auth */ \"./src/api/methods/auth.ts\");\n/* harmony import */ var _wallet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wallet */ \"./src/api/methods/wallet.ts\");\n/* harmony import */ var _transactions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transactions */ \"./src/api/methods/transactions.ts\");\n/* harmony import */ var _nfts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nfts */ \"./src/api/methods/nfts.ts\");\n/* harmony import */ var _polling__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./polling */ \"./src/api/methods/polling.ts\");\n/* harmony import */ var _accounts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./accounts */ \"./src/api/methods/accounts.ts\");\n/* harmony import */ var _staking__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./staking */ \"./src/api/methods/staking.ts\");\n/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tokens */ \"./src/api/methods/tokens.ts\");\n/* harmony import */ var _dapps__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./dapps */ \"./src/api/methods/dapps.ts\");\n/* harmony import */ var _tonConnect_sse__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../tonConnect/sse */ \"./src/api/tonConnect/sse.ts\");\n/* harmony import */ var _swap__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./swap */ \"./src/api/methods/swap.ts\");\n/* harmony import */ var _other__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./other */ \"./src/api/methods/other.ts\");\n/* harmony import */ var _prices__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./prices */ \"./src/api/methods/prices.ts\");\n/* harmony import */ var _preload__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./preload */ \"./src/api/methods/preload.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/methods/index.ts?");

/***/ }),

/***/ "./src/api/methods/init.ts":
/*!*********************************!*\
  !*** ./src/api/methods/init.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ init)\n/* harmony export */ });\n/* harmony import */ var _blockchains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../blockchains */ \"./src/api/blockchains/index.ts\");\n/* harmony import */ var _common_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/helpers */ \"./src/api/common/helpers.ts\");\n/* harmony import */ var _environment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../environment */ \"./src/api/environment.ts\");\n/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../hooks */ \"./src/api/hooks.ts\");\n/* harmony import */ var _tonConnect__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tonConnect */ \"./src/api/tonConnect/index.ts\");\n/* harmony import */ var _tonConnect_sse__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tonConnect/sse */ \"./src/api/tonConnect/sse.ts\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./index */ \"./src/api/methods/index.ts\");\n\n\n\n\n\n\n\n(0,_hooks__WEBPACK_IMPORTED_MODULE_3__.addHooks)({\n  onDappDisconnected: _tonConnect_sse__WEBPACK_IMPORTED_MODULE_5__.sendSseDisconnect,\n  onDappsChanged: _tonConnect_sse__WEBPACK_IMPORTED_MODULE_5__.resetupSseConnection,\n  onSwapCreated: _index__WEBPACK_IMPORTED_MODULE_6__.setupSwapPolling\n});\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nasync function init(onUpdate, args) {\n  (0,_common_helpers__WEBPACK_IMPORTED_MODULE_1__.connectUpdater)(onUpdate);\n  const environment = (0,_environment__WEBPACK_IMPORTED_MODULE_2__.setEnvironment)(args);\n  _index__WEBPACK_IMPORTED_MODULE_6__.initPolling(onUpdate, _index__WEBPACK_IMPORTED_MODULE_6__.isAccountActive);\n  _index__WEBPACK_IMPORTED_MODULE_6__.initTransactions(onUpdate);\n  _index__WEBPACK_IMPORTED_MODULE_6__.initStaking();\n  _index__WEBPACK_IMPORTED_MODULE_6__.initSwap(onUpdate);\n  _index__WEBPACK_IMPORTED_MODULE_6__.initNfts(onUpdate);\n  if (environment.isDappSupported) {\n    _index__WEBPACK_IMPORTED_MODULE_6__.initDapps(onUpdate);\n    _tonConnect__WEBPACK_IMPORTED_MODULE_4__.initTonConnect(onUpdate);\n  }\n  if (environment.isSseSupported) {\n    _tonConnect_sse__WEBPACK_IMPORTED_MODULE_5__.initSse(onUpdate);\n  }\n  await (0,_common_helpers__WEBPACK_IMPORTED_MODULE_1__.startStorageMigration)(onUpdate, _blockchains__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ton);\n  if (environment.isSseSupported) {\n    void _tonConnect_sse__WEBPACK_IMPORTED_MODULE_5__.resetupSseConnection();\n  }\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/methods/init.ts?");

/***/ }),

/***/ "./src/api/methods/nfts.ts":
/*!*********************************!*\
  !*** ./src/api/methods/nfts.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"fetchNfts\": () => (/* binding */ fetchNfts),\n/* harmony export */   \"initNfts\": () => (/* binding */ initNfts),\n/* harmony export */   \"processNftUpdates\": () => (/* binding */ processNftUpdates),\n/* harmony export */   \"updateNfts\": () => (/* binding */ updateNfts)\n/* harmony export */ });\n/* harmony import */ var _blockchains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../blockchains */ \"./src/api/blockchains/index.ts\");\n/* harmony import */ var _common_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/helpers */ \"./src/api/common/helpers.ts\");\n/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../db */ \"./src/api/db.ts\");\n\n\n\nlet onUpdate;\nfunction initNfts(_onUpdate) {\n  onUpdate = _onUpdate;\n}\nfunction fetchNfts(accountId) {\n  const blockchain = _blockchains__WEBPACK_IMPORTED_MODULE_0__[\"default\"][(0,_common_helpers__WEBPACK_IMPORTED_MODULE_1__.resolveBlockchainKey)(accountId)];\n  return blockchain.getAccountNfts(accountId);\n}\nasync function processNftUpdates(accountId, updates) {\n  updates.filter(update => !(update.type === 'nftReceived' && update.nft.isHidden)).forEach(onUpdate);\n  for (const update of updates) {\n    if (update.type === 'nftSent') {\n      const key = [accountId, update.nftAddress];\n      await _db__WEBPACK_IMPORTED_MODULE_2__.apiDb.nfts[\"delete\"](key);\n    } else if (update.type === 'nftReceived') {\n      const dbNft = convertToDbEntity(accountId, update.nft);\n      await _db__WEBPACK_IMPORTED_MODULE_2__.apiDb.nfts.put(dbNft);\n    } else if (update.type === 'nftPutUpForSale') {\n      const key = [accountId, update.nftAddress];\n      await _db__WEBPACK_IMPORTED_MODULE_2__.apiDb.nfts.update(key, {\n        isOnSale: true\n      });\n    }\n  }\n}\nasync function updateNfts(accountId, nfts) {\n  const visibleNfts = nfts.filter(nft => !nft.isHidden);\n  onUpdate({\n    type: 'updateNfts',\n    accountId,\n    nfts: visibleNfts\n  });\n  const dbNfts = nfts.map(nft => convertToDbEntity(accountId, nft));\n  await _db__WEBPACK_IMPORTED_MODULE_2__.apiDb.nfts.where({\n    accountId\n  }).delete();\n  await _db__WEBPACK_IMPORTED_MODULE_2__.apiDb.nfts.bulkPut(dbNfts);\n}\nfunction convertToDbEntity(accountId, nft) {\n  var _nft$collectionAddres;\n  return {\n    ...nft,\n    collectionAddress: (_nft$collectionAddres = nft.collectionAddress) !== null && _nft$collectionAddres !== void 0 ? _nft$collectionAddres : '',\n    accountId\n  };\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/methods/nfts.ts?");

/***/ }),

/***/ "./src/api/methods/other.ts":
/*!**********************************!*\
  !*** ./src/api/methods/other.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"checkApiAvailability\": () => (/* binding */ checkApiAvailability),\n/* harmony export */   \"fetchAccountConfigForDebugPurposesOnly\": () => (/* binding */ fetchAccountConfigForDebugPurposesOnly),\n/* harmony export */   \"getBackendAuthToken\": () => (/* binding */ getBackendAuthToken),\n/* harmony export */   \"getClientId\": () => (/* binding */ getClientId),\n/* harmony export */   \"ping\": () => (/* binding */ ping),\n/* harmony export */   \"setIsAppFocused\": () => (/* reexport safe */ _util_pauseOrFocus__WEBPACK_IMPORTED_MODULE_2__.setIsAppFocused)\n/* harmony export */ });\n/* harmony import */ var tweetnacl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tweetnacl */ \"./node_modules/tweetnacl/nacl-fast.js\");\n/* harmony import */ var tweetnacl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tweetnacl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _util_account__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/account */ \"./src/util/account.ts\");\n/* harmony import */ var _util_pauseOrFocus__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/pauseOrFocus */ \"./src/util/pauseOrFocus.ts\");\n/* harmony import */ var _blockchains__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../blockchains */ \"./src/api/blockchains/index.ts\");\n/* harmony import */ var _common_accounts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/accounts */ \"./src/api/common/accounts.ts\");\n/* harmony import */ var _storages__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../storages */ \"./src/api/storages/index.ts\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\n\n\n\n\nconst SIGN_MESSAGE = Buffer.from('MyTonWallet_AuthToken_n6i0k4w8pb');\nlet clientId;\nfunction checkApiAvailability(options) {\n  let network;\n  let blockchainKey;\n  if ('network' in options) {\n    ({\n      network,\n      blockchainKey\n    } = options);\n  } else {\n    ({\n      network,\n      blockchain: blockchainKey\n    } = (0,_util_account__WEBPACK_IMPORTED_MODULE_1__.parseAccountId)(options.accountId));\n  }\n  const blockchain = _blockchains__WEBPACK_IMPORTED_MODULE_3__[\"default\"][blockchainKey];\n  return blockchain.checkApiAvailability(network);\n}\nasync function getBackendAuthToken(accountId, password) {\n  const account = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_4__.fetchStoredAccount)(accountId);\n  let authToken = account.authToken;\n  if (!authToken) {\n    const privateKey = await _blockchains__WEBPACK_IMPORTED_MODULE_3__[\"default\"].ton.fetchPrivateKey(accountId, password);\n    const signature = tweetnacl__WEBPACK_IMPORTED_MODULE_0___default().sign.detached(SIGN_MESSAGE, privateKey);\n    authToken = Buffer.from(signature).toString('base64');\n    await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_4__.updateStoredAccount)(accountId, {\n      authToken\n    });\n  }\n  if (!account.isInitialized) {\n    authToken += `:${account.publicKey}`;\n  }\n  return authToken;\n}\nasync function getClientId() {\n  clientId = await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.getItem('clientId');\n  if (!clientId) {\n    clientId = Buffer.from((0,tweetnacl__WEBPACK_IMPORTED_MODULE_0__.randomBytes)(10)).toString('hex');\n    await _storages__WEBPACK_IMPORTED_MODULE_5__.storage.setItem('clientId', clientId);\n  }\n  return clientId;\n}\nasync function fetchAccountConfigForDebugPurposesOnly() {\n  try {\n    const [accounts, mnemonicsEncrypted] = await Promise.all([(0,_common_accounts__WEBPACK_IMPORTED_MODULE_4__.fetchStoredAccounts)(), _storages__WEBPACK_IMPORTED_MODULE_5__.storage.getItem('mnemonicsEncrypted')]);\n    return JSON.stringify({\n      accounts,\n      mnemonicsEncrypted\n    });\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.error(err);\n    return undefined;\n  }\n}\nfunction ping() {\n  return true;\n}\n\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/methods/other.ts?");

/***/ }),

/***/ "./src/api/methods/polling.ts":
/*!************************************!*\
  !*** ./src/api/methods/polling.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"initPolling\": () => (/* binding */ initPolling),\n/* harmony export */   \"sendUpdateTokens\": () => (/* binding */ sendUpdateTokens),\n/* harmony export */   \"setupBackendPolling\": () => (/* binding */ setupBackendPolling),\n/* harmony export */   \"setupBalanceBasedPolling\": () => (/* binding */ setupBalanceBasedPolling),\n/* harmony export */   \"setupLongBackendPolling\": () => (/* binding */ setupLongBackendPolling),\n/* harmony export */   \"setupStakingPolling\": () => (/* binding */ setupStakingPolling),\n/* harmony export */   \"setupSwapPolling\": () => (/* binding */ setupSwapPolling),\n/* harmony export */   \"setupWalletVersionsPolling\": () => (/* binding */ setupWalletVersionsPolling),\n/* harmony export */   \"tryLoadSwapTokens\": () => (/* binding */ tryLoadSwapTokens),\n/* harmony export */   \"tryUpdateConfig\": () => (/* binding */ tryUpdateConfig),\n/* harmony export */   \"tryUpdatePrices\": () => (/* binding */ tryUpdatePrices),\n/* harmony export */   \"tryUpdateTokens\": () => (/* binding */ tryUpdateTokens)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\n/* harmony import */ var _util_account__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/account */ \"./src/util/account.ts\");\n/* harmony import */ var _util_areDeepEqual__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/areDeepEqual */ \"./src/util/areDeepEqual.ts\");\n/* harmony import */ var _util_compareActivities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/compareActivities */ \"./src/util/compareActivities.ts\");\n/* harmony import */ var _util_iteratees__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/iteratees */ \"./src/util/iteratees.ts\");\n/* harmony import */ var _util_logs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/logs */ \"./src/util/logs.ts\");\n/* harmony import */ var _util_pauseOrFocus__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/pauseOrFocus */ \"./src/util/pauseOrFocus.ts\");\n/* harmony import */ var _blockchains__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../blockchains */ \"./src/api/blockchains/index.ts\");\n/* harmony import */ var _blockchains_ton_tokens__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../blockchains/ton/tokens */ \"./src/api/blockchains/ton/tokens.ts\");\n/* harmony import */ var _common_accounts__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../common/accounts */ \"./src/api/common/accounts.ts\");\n/* harmony import */ var _common_addresses__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../common/addresses */ \"./src/api/common/addresses.ts\");\n/* harmony import */ var _common_backend__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../common/backend */ \"./src/api/common/backend.ts\");\n/* harmony import */ var _common_cache__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../common/cache */ \"./src/api/common/cache.ts\");\n/* harmony import */ var _common_helpers__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../common/helpers */ \"./src/api/common/helpers.ts\");\n/* harmony import */ var _common_txCallbacks__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../common/txCallbacks */ \"./src/api/common/txCallbacks.ts\");\n/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../common/utils */ \"./src/api/common/utils.ts\");\n/* harmony import */ var _nfts__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./nfts */ \"./src/api/methods/nfts.ts\");\n/* harmony import */ var _preload__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./preload */ \"./src/api/methods/preload.ts\");\n/* harmony import */ var _prices__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./prices */ \"./src/api/methods/prices.ts\");\n/* harmony import */ var _staking__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./staking */ \"./src/api/methods/staking.ts\");\n/* harmony import */ var _swap__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./swap */ \"./src/api/methods/swap.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst SEC = 1000;\nconst BALANCE_BASED_INTERVAL = 1.1 * SEC;\nconst BALANCE_BASED_INTERVAL_WHEN_NOT_FOCUSED = 10 * SEC;\nconst STAKING_INTERVAL = 1.1 * SEC;\nconst STAKING_INTERVAL_WHEN_NOT_FOCUSED = 10 * SEC;\nconst BACKEND_INTERVAL = 30 * SEC;\nconst LONG_BACKEND_INTERVAL = 60 * SEC;\nconst NFT_FULL_INTERVAL = 60 * SEC;\nconst SWAP_POLLING_INTERVAL = 3 * SEC;\nconst SWAP_POLLING_INTERVAL_WHEN_NOT_FOCUSED = 10 * SEC;\nconst SWAP_FINISHED_STATUSES = new Set(['failed', 'completed', 'expired']);\nconst VERSIONS_INTERVAL = 5 * 60 * SEC;\nconst VERSIONS_INTERVAL_WHEN_NOT_FOCUSED = 15 * 60 * SEC;\nconst FIRST_TRANSACTIONS_LIMIT = 50;\nconst DOUBLE_CHECK_TOKENS_PAUSE = 30 * SEC;\nlet onUpdate;\nlet isAccountActive;\nconst prices = {\n  baseCurrency: _config__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_PRICE_CURRENCY,\n  bySlug: {}\n};\nlet swapPollingAccountId;\nconst lastBalanceCache = {};\nasync function initPolling(_onUpdate, _isAccountActive) {\n  onUpdate = _onUpdate;\n  isAccountActive = _isAccountActive;\n  await tryUpdatePrices();\n  Promise.all([(0,_common_addresses__WEBPACK_IMPORTED_MODULE_10__.tryUpdateKnownAddresses)(), tryUpdateTokens(_onUpdate), tryLoadSwapTokens(_onUpdate), (0,_staking__WEBPACK_IMPORTED_MODULE_19__.tryUpdateStakingCommonData)()]).then(() => (0,_preload__WEBPACK_IMPORTED_MODULE_17__.resolveDataPreloadPromise)());\n  void tryUpdateConfig(_onUpdate);\n  void setupBackendPolling();\n  void setupLongBackendPolling();\n}\nfunction registerNewTokens(tokenBalances) {\n  const tokens = (0,_blockchains_ton_tokens__WEBPACK_IMPORTED_MODULE_8__.getKnownTokens)();\n  let areNewTokensFound = false;\n  for (const {\n    token\n  } of tokenBalances.filter(Boolean)) {\n    if (token.slug in tokens) continue;\n    areNewTokensFound = true;\n    tokens[token.slug] = {\n      ...token,\n      quote: prices.bySlug[token.slug] || {\n        price: 0.0,\n        priceUsd: 0.0,\n        percentChange24h: 0.0\n      }\n    };\n  }\n  if (areNewTokensFound) {\n    sendUpdateTokens();\n  }\n}\nasync function setupBalanceBasedPolling(accountId) {\n  let newestTxIds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const blockchain = _blockchains__WEBPACK_IMPORTED_MODULE_7__[\"default\"][(0,_common_helpers__WEBPACK_IMPORTED_MODULE_13__.resolveBlockchainKey)(accountId)];\n  delete lastBalanceCache[accountId];\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_1__.parseAccountId)(accountId);\n  const account = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_9__.fetchStoredAccount)(accountId);\n  const {\n    address\n  } = account;\n  let {\n    isInitialized\n  } = account;\n  let nftFromSec = Math.round(Date.now() / 1000);\n  let nftUpdates;\n  let lastNftFullUpdate = 0;\n  let doubleCheckTokensTime;\n  let tokenBalances;\n  const localOnUpdate = onUpdate;\n  while (isAlive(localOnUpdate, accountId)) {\n    try {\n      const walletInfo = await blockchain.getWalletInfo(network, address);\n      if (!isAlive(localOnUpdate, accountId)) return;\n      const {\n        balance,\n        lastTxId\n      } = walletInfo !== null && walletInfo !== void 0 ? walletInfo : {};\n      if (Date.now() - lastNftFullUpdate > NFT_FULL_INTERVAL) {\n        const nfts = await blockchain.getAccountNfts(accountId).catch(logAndRescue);\n        lastNftFullUpdate = Date.now();\n        if (!isAlive(localOnUpdate, accountId)) return;\n        if (nfts) {\n          nftFromSec = Math.round(Date.now() / 1000);\n          if (!isAlive(localOnUpdate, accountId)) return;\n          void (0,_nfts__WEBPACK_IMPORTED_MODULE_16__.updateNfts)(accountId, nfts);\n        }\n      }\n\n      // Process TON balance\n      const cache = lastBalanceCache[accountId];\n      const changedTokenSlugs = [];\n      const isTonBalanceChanged = balance !== undefined && balance !== (cache === null || cache === void 0 ? void 0 : cache.balance);\n      const balancesToUpdate = {};\n      if (isTonBalanceChanged) {\n        balancesToUpdate[_config__WEBPACK_IMPORTED_MODULE_0__.TON_TOKEN_SLUG] = balance;\n        lastBalanceCache[accountId] = {\n          ...lastBalanceCache[accountId],\n          balance\n        };\n      }\n\n      // Fetch and process token balances\n      if (isTonBalanceChanged || doubleCheckTokensTime && doubleCheckTokensTime < Date.now()) {\n        doubleCheckTokensTime = isTonBalanceChanged ? Date.now() + DOUBLE_CHECK_TOKENS_PAUSE : undefined;\n        tokenBalances = await blockchain.getAccountTokenBalances(accountId).catch(logAndRescue);\n        if (!isAlive(localOnUpdate, accountId)) return;\n        if (tokenBalances) {\n          registerNewTokens(tokenBalances);\n          tokenBalances.forEach(_ref => {\n            let {\n              slug,\n              balance: tokenBalance\n            } = _ref;\n            const cachedBalance = (cache === null || cache === void 0 ? void 0 : cache.tokenBalances) && cache.tokenBalances[slug];\n            if (cachedBalance === tokenBalance) return;\n            changedTokenSlugs.push(slug);\n            balancesToUpdate[slug] = tokenBalance;\n          });\n          lastBalanceCache[accountId] = {\n            ...lastBalanceCache[accountId],\n            tokenBalances: Object.fromEntries(tokenBalances.map(_ref2 => {\n              let {\n                slug,\n                balance: tokenBalance\n              } = _ref2;\n              return [slug, tokenBalance];\n            }))\n          };\n        }\n        if (Object.keys(balancesToUpdate).length > 0) {\n          onUpdate({\n            type: 'updateBalances',\n            accountId,\n            balancesToUpdate\n          });\n        }\n      }\n\n      // Fetch transactions for tokens with a changed balance\n      if (isTonBalanceChanged || changedTokenSlugs.length) {\n        if (lastTxId) {\n          await blockchain.waitUntilTransactionAppears(network, address, lastTxId);\n        }\n        const newTxIds = await processNewActivities(accountId, newestTxIds, changedTokenSlugs, tokenBalances);\n        newestTxIds = {\n          ...newestTxIds,\n          ...newTxIds\n        };\n      }\n\n      // Fetch NFT updates\n      if (isTonBalanceChanged) {\n        const nftResult = await blockchain.getNftUpdates(accountId, nftFromSec).catch(logAndRescue);\n        if (!isAlive(localOnUpdate, accountId)) return;\n        if (nftResult) {\n          [nftFromSec, nftUpdates] = nftResult;\n          void (0,_nfts__WEBPACK_IMPORTED_MODULE_16__.processNftUpdates)(accountId, nftUpdates);\n        }\n      }\n      if (isTonBalanceChanged && !isInitialized && (await blockchain.isAddressInitialized(network, address))) {\n        isInitialized = true;\n        await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_9__.updateStoredAccount)(accountId, {\n          isInitialized\n        });\n      }\n    } catch (err) {\n      (0,_util_logs__WEBPACK_IMPORTED_MODULE_5__.logDebugError)('setupBalanceBasedPolling', err);\n    }\n    await (0,_util_pauseOrFocus__WEBPACK_IMPORTED_MODULE_6__.pauseOrFocus)(BALANCE_BASED_INTERVAL, BALANCE_BASED_INTERVAL_WHEN_NOT_FOCUSED);\n  }\n}\nasync function setupStakingPolling(accountId) {\n  const {\n    blockchain: blockchainKey,\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_1__.parseAccountId)(accountId);\n  const blockchain = _blockchains__WEBPACK_IMPORTED_MODULE_7__[\"default\"][blockchainKey];\n  if (network !== 'mainnet') {\n    return;\n  }\n  const localOnUpdate = onUpdate;\n  let lastState;\n  while (isAlive(localOnUpdate, accountId)) {\n    try {\n      const stakingCommonData = (0,_common_cache__WEBPACK_IMPORTED_MODULE_12__.getStakingCommonCache)();\n      const backendStakingState = await (0,_staking__WEBPACK_IMPORTED_MODULE_19__.getBackendStakingState)(accountId);\n      const stakingState = await blockchain.getStakingState(accountId, backendStakingState);\n      if (!isAlive(localOnUpdate, accountId)) return;\n      const state = {\n        stakingCommonData,\n        backendStakingState,\n        stakingState\n      };\n      if (!(0,_util_areDeepEqual__WEBPACK_IMPORTED_MODULE_2__.areDeepEqual)(state, lastState)) {\n        lastState = state;\n        onUpdate({\n          type: 'updateStaking',\n          accountId,\n          ...state\n        });\n      }\n    } catch (err) {\n      (0,_util_logs__WEBPACK_IMPORTED_MODULE_5__.logDebugError)('setupStakingPolling', err);\n    }\n    await (0,_util_pauseOrFocus__WEBPACK_IMPORTED_MODULE_6__.pauseOrFocus)(STAKING_INTERVAL, STAKING_INTERVAL_WHEN_NOT_FOCUSED);\n  }\n}\nasync function processNewActivities(accountId, newestTxIds, tokenSlugs, tokenBalances) {\n  const {\n    network,\n    blockchain\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_1__.parseAccountId)(accountId);\n  const activeBlockchain = _blockchains__WEBPACK_IMPORTED_MODULE_7__[\"default\"][blockchain];\n  const chunks = [];\n  const result = [];\n\n  // Process TON transactions first\n  {\n    const slug = _config__WEBPACK_IMPORTED_MODULE_0__.TON_TOKEN_SLUG;\n    let newestTxId = newestTxIds[slug];\n    const transactions = await activeBlockchain.getTokenTransactionSlice(accountId, slug, undefined, newestTxId, FIRST_TRANSACTIONS_LIMIT);\n    if (transactions.length) {\n      newestTxId = transactions[0].txId;\n      chunks.push(transactions);\n    }\n    result.push([slug, newestTxId]);\n\n    // Find affected token wallets\n    const tokenBalanceByAddress = (0,_util_iteratees__WEBPACK_IMPORTED_MODULE_4__.buildCollectionByKey)(tokenBalances !== null && tokenBalances !== void 0 ? tokenBalances : [], 'jettonWallet');\n    transactions.forEach(_ref3 => {\n      let {\n        isIncoming,\n        toAddress,\n        fromAddress\n      } = _ref3;\n      const address = isIncoming ? fromAddress : toAddress;\n      const tokenBalance = tokenBalanceByAddress[address];\n      if (tokenBalance && !tokenSlugs.includes(tokenBalance.slug)) {\n        tokenSlugs = tokenSlugs.concat([tokenBalance.slug]);\n      }\n    });\n  }\n\n  // Process token transactions\n  await Promise.all(tokenSlugs.map(async slug => {\n    let newestTxId = newestTxIds[slug];\n    const transactions = await activeBlockchain.getTokenTransactionSlice(accountId, slug, undefined, newestTxId, FIRST_TRANSACTIONS_LIMIT);\n    if (transactions.length) {\n      newestTxId = transactions[0].txId;\n      chunks.push(transactions);\n    }\n    result.push([slug, newestTxId]);\n  }));\n  const allTransactions = chunks.flat().sort((a, b) => (0,_util_compareActivities__WEBPACK_IMPORTED_MODULE_3__.compareActivities)(a, b));\n  const isFirstRun = !Object.keys(newestTxIds).length;\n  const activities = await (0,_swap__WEBPACK_IMPORTED_MODULE_20__.swapReplaceTransactionsByRanges)(accountId, allTransactions, chunks, isFirstRun);\n  allTransactions.sort((a, b) => (0,_util_compareActivities__WEBPACK_IMPORTED_MODULE_3__.compareActivities)(a, b, true));\n  allTransactions.forEach(transaction => {\n    _common_txCallbacks__WEBPACK_IMPORTED_MODULE_14__.txCallbacks.runCallbacks(transaction);\n  });\n  await activeBlockchain.fixTokenActivitiesAddressForm(network, activities);\n  onUpdate({\n    type: 'newActivities',\n    activities,\n    accountId\n  });\n  return Object.fromEntries(result);\n}\nasync function setupBackendPolling() {\n  const localOnUpdate = onUpdate;\n  while ((0,_common_helpers__WEBPACK_IMPORTED_MODULE_13__.isUpdaterAlive)(localOnUpdate)) {\n    await (0,_util_pauseOrFocus__WEBPACK_IMPORTED_MODULE_6__.pauseOrFocus)(BACKEND_INTERVAL);\n    if (!(0,_common_helpers__WEBPACK_IMPORTED_MODULE_13__.isUpdaterAlive)(localOnUpdate)) return;\n    try {\n      await tryUpdatePrices(localOnUpdate);\n      await tryUpdateTokens(localOnUpdate);\n    } catch (err) {\n      (0,_util_logs__WEBPACK_IMPORTED_MODULE_5__.logDebugError)('setupBackendPolling', err);\n    }\n  }\n}\nasync function setupLongBackendPolling() {\n  const localOnUpdate = onUpdate;\n  while ((0,_common_helpers__WEBPACK_IMPORTED_MODULE_13__.isUpdaterAlive)(localOnUpdate)) {\n    await (0,_util_pauseOrFocus__WEBPACK_IMPORTED_MODULE_6__.pauseOrFocus)(LONG_BACKEND_INTERVAL);\n    await Promise.all([(0,_common_addresses__WEBPACK_IMPORTED_MODULE_10__.tryUpdateKnownAddresses)(), (0,_staking__WEBPACK_IMPORTED_MODULE_19__.tryUpdateStakingCommonData)(), tryUpdateConfig(localOnUpdate)]);\n  }\n}\nasync function tryUpdatePrices(localOnUpdate) {\n  if (!localOnUpdate) {\n    localOnUpdate = onUpdate;\n  }\n  try {\n    const baseCurrency = await (0,_prices__WEBPACK_IMPORTED_MODULE_18__.getBaseCurrency)();\n    const pricesData = await (0,_common_backend__WEBPACK_IMPORTED_MODULE_11__.callBackendGet)('/prices/current', {\n      base: baseCurrency\n    });\n    if (!(0,_common_helpers__WEBPACK_IMPORTED_MODULE_13__.isUpdaterAlive)(localOnUpdate)) return;\n    prices.bySlug = (0,_util_iteratees__WEBPACK_IMPORTED_MODULE_4__.buildCollectionByKey)(Object.values(pricesData), 'slug');\n    prices.baseCurrency = baseCurrency;\n  } catch (err) {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_5__.logDebugError)('tryUpdatePrices', err);\n  }\n}\nasync function tryUpdateTokens(localOnUpdate) {\n  if (!localOnUpdate) {\n    localOnUpdate = onUpdate;\n  }\n  try {\n    const tokens = await (0,_common_backend__WEBPACK_IMPORTED_MODULE_11__.callBackendGet)('/known-tokens');\n    if (!(0,_common_helpers__WEBPACK_IMPORTED_MODULE_13__.isUpdaterAlive)(localOnUpdate)) return;\n    (0,_blockchains_ton_tokens__WEBPACK_IMPORTED_MODULE_8__.addKnownTokens)(tokens);\n    sendUpdateTokens();\n  } catch (err) {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_5__.logDebugError)('tryUpdateTokens', err);\n  }\n}\nasync function tryLoadSwapTokens(localOnUpdate) {\n  if (!localOnUpdate) {\n    localOnUpdate = onUpdate;\n  }\n  try {\n    const assets = await (0,_swap__WEBPACK_IMPORTED_MODULE_20__.swapGetAssets)();\n    if (!(0,_common_helpers__WEBPACK_IMPORTED_MODULE_13__.isUpdaterAlive)(localOnUpdate)) return;\n    const tokens = assets.reduce((acc, asset) => {\n      var _asset$contract, _prices$bySlug$asset$, _prices$bySlug$asset$2;\n      acc[asset.slug] = {\n        ...asset,\n        contract: (_asset$contract = asset.contract) !== null && _asset$contract !== void 0 ? _asset$contract : asset.slug,\n        price: (_prices$bySlug$asset$ = (_prices$bySlug$asset$2 = prices.bySlug[asset.slug]) === null || _prices$bySlug$asset$2 === void 0 ? void 0 : _prices$bySlug$asset$2.price) !== null && _prices$bySlug$asset$ !== void 0 ? _prices$bySlug$asset$ : 0\n      };\n      return acc;\n    }, {});\n    onUpdate({\n      type: 'updateSwapTokens',\n      tokens\n    });\n  } catch (err) {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_5__.logDebugError)('tryLoadSwapTokens', err);\n  }\n}\nasync function tryUpdateConfig(localOnUpdate) {\n  try {\n    const {\n      isLimited,\n      isCopyStorageEnabled = false\n    } = await (0,_common_backend__WEBPACK_IMPORTED_MODULE_11__.callBackendGet)('/utils/get-config');\n    if (!(0,_common_helpers__WEBPACK_IMPORTED_MODULE_13__.isUpdaterAlive)(localOnUpdate)) return;\n    onUpdate({\n      type: 'updateConfig',\n      isLimited,\n      isCopyStorageEnabled\n    });\n  } catch (err) {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_5__.logDebugError)('tryUpdateRegion', err);\n  }\n}\nfunction sendUpdateTokens() {\n  const tokens = (0,_blockchains_ton_tokens__WEBPACK_IMPORTED_MODULE_8__.getKnownTokens)();\n  Object.values(tokens).forEach(token => {\n    if (token.slug in prices.bySlug) {\n      token.quote = prices.bySlug[token.slug];\n    }\n  });\n  onUpdate({\n    type: 'updateTokens',\n    tokens,\n    baseCurrency: prices.baseCurrency\n  });\n}\nasync function setupSwapPolling(accountId) {\n  if (swapPollingAccountId === accountId) return; // Double launch is not allowed\n  swapPollingAccountId = accountId;\n  const {\n    address,\n    lastFinishedSwapTimestamp\n  } = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_9__.fetchStoredAccount)(accountId);\n  let fromTimestamp = lastFinishedSwapTimestamp !== null && lastFinishedSwapTimestamp !== void 0 ? lastFinishedSwapTimestamp : await getActualLastFinishedSwapTimestamp(accountId, address);\n  const localOnUpdate = onUpdate;\n  const swapById = {};\n  while (isAlive(localOnUpdate, accountId)) {\n    try {\n      const swaps = await (0,_swap__WEBPACK_IMPORTED_MODULE_20__.swapGetHistory)(address, {\n        fromTimestamp\n      });\n      if (!isAlive(localOnUpdate, accountId)) break;\n      if (!swaps.length) break;\n      swaps.reverse();\n      let isLastFinishedSwapUpdated = false;\n      let isPrevFinished = true;\n      for (const swap of swaps) {\n        var _swapById$swap$id2;\n        if (swap.cex) {\n          var _swapById$swap$id;\n          if (swap.cex.status === ((_swapById$swap$id = swapById[swap.id]) === null || _swapById$swap$id === void 0 ? void 0 : _swapById$swap$id.cex.status)) {\n            continue;\n          }\n        } else if (swap.status === ((_swapById$swap$id2 = swapById[swap.id]) === null || _swapById$swap$id2 === void 0 ? void 0 : _swapById$swap$id2.status)) {\n          continue;\n        }\n        swapById[swap.id] = swap;\n        const isFinished = SWAP_FINISHED_STATUSES.has(swap.status);\n        if (isFinished && isPrevFinished) {\n          fromTimestamp = swap.timestamp;\n          isLastFinishedSwapUpdated = true;\n        }\n        isPrevFinished = isFinished;\n        if (!swap.cex && swap.status !== 'completed') {\n          // Completed onchain swaps are processed in swapReplaceTransactions\n          onUpdate({\n            type: 'newActivities',\n            accountId,\n            activities: [(0,_swap__WEBPACK_IMPORTED_MODULE_20__.swapItemToActivity)(swap)]\n          });\n        }\n      }\n      if (isLastFinishedSwapUpdated) {\n        await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_9__.updateStoredAccount)(accountId, {\n          lastFinishedSwapTimestamp: fromTimestamp\n        });\n      }\n    } catch (err) {\n      (0,_util_logs__WEBPACK_IMPORTED_MODULE_5__.logDebugError)('setupSwapPolling', err);\n    }\n    await (0,_util_pauseOrFocus__WEBPACK_IMPORTED_MODULE_6__.pauseOrFocus)(SWAP_POLLING_INTERVAL, SWAP_POLLING_INTERVAL_WHEN_NOT_FOCUSED);\n  }\n  if (accountId === swapPollingAccountId) {\n    swapPollingAccountId = undefined;\n  }\n}\nfunction isAlive(localOnUpdate, accountId) {\n  return (0,_common_helpers__WEBPACK_IMPORTED_MODULE_13__.isUpdaterAlive)(localOnUpdate) && isAccountActive(accountId);\n}\nasync function getActualLastFinishedSwapTimestamp(accountId, address) {\n  const swaps = await (0,_swap__WEBPACK_IMPORTED_MODULE_20__.swapGetHistory)(address, {});\n  swaps.reverse();\n  let timestamp = Date.now();\n  for (const swap of swaps) {\n    if (SWAP_FINISHED_STATUSES.has(swap.status)) {\n      timestamp = swap.timestamp;\n    } else {\n      break;\n    }\n  }\n  await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_9__.updateStoredAccount)(accountId, {\n    lastFinishedSwapTimestamp: timestamp\n  });\n  return timestamp;\n}\nfunction logAndRescue(err) {\n  (0,_util_logs__WEBPACK_IMPORTED_MODULE_5__.logDebugError)('Polling error', err);\n  return undefined;\n}\nasync function setupWalletVersionsPolling(accountId) {\n  const {\n    ton\n  } = _blockchains__WEBPACK_IMPORTED_MODULE_7__[\"default\"];\n  const localOnUpdate = onUpdate;\n  const {\n    publicKey,\n    version\n  } = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_9__.fetchStoredAccount)(accountId);\n  const publicKeyBytes = (0,_common_utils__WEBPACK_IMPORTED_MODULE_15__.hexToBytes)(publicKey);\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_1__.parseAccountId)(accountId);\n  const versions = _config__WEBPACK_IMPORTED_MODULE_0__.POPULAR_WALLET_VERSIONS.filter(value => value !== version);\n  let lastResult;\n  while (isAlive(localOnUpdate, accountId)) {\n    try {\n      const versionInfos = (await ton.getWalletVersionInfos(network, publicKeyBytes, versions)).filter(_ref4 => {\n        let {\n          lastTxId\n        } = _ref4;\n        return !!lastTxId;\n      });\n      const filteredVersions = versionInfos.map(_ref5 => {\n        let {\n          wallet,\n          ...rest\n        } = _ref5;\n        return rest;\n      });\n      if (!isAlive(localOnUpdate, accountId)) return;\n      if (!(0,_util_areDeepEqual__WEBPACK_IMPORTED_MODULE_2__.areDeepEqual)(versionInfos, lastResult)) {\n        lastResult = versionInfos;\n        onUpdate({\n          type: 'updateWalletVersions',\n          accountId,\n          currentVersion: version,\n          versions: filteredVersions\n        });\n      }\n    } catch (err) {\n      (0,_util_logs__WEBPACK_IMPORTED_MODULE_5__.logDebugError)('setupWalletVersionsPolling', err);\n    }\n    await (0,_util_pauseOrFocus__WEBPACK_IMPORTED_MODULE_6__.pauseOrFocus)(VERSIONS_INTERVAL, VERSIONS_INTERVAL_WHEN_NOT_FOCUSED);\n  }\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/methods/polling.ts?");

/***/ }),

/***/ "./src/api/methods/preload.ts":
/*!************************************!*\
  !*** ./src/api/methods/preload.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"resolveDataPreloadPromise\": () => (/* binding */ resolveDataPreloadPromise),\n/* harmony export */   \"waitDataPreload\": () => (/* binding */ waitDataPreload)\n/* harmony export */ });\nlet resolvePromise;\nconst preloadPromise = new Promise(resolve => {\n  resolvePromise = resolve;\n});\nfunction resolveDataPreloadPromise() {\n  resolvePromise();\n}\nasync function waitDataPreload() {\n  await preloadPromise;\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/methods/preload.ts?");

/***/ }),

/***/ "./src/api/methods/prices.ts":
/*!***********************************!*\
  !*** ./src/api/methods/prices.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"fetchPriceHistory\": () => (/* binding */ fetchPriceHistory),\n/* harmony export */   \"getBaseCurrency\": () => (/* binding */ getBaseCurrency),\n/* harmony export */   \"setBaseCurrency\": () => (/* binding */ setBaseCurrency)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\n/* harmony import */ var _common_backend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/backend */ \"./src/api/common/backend.ts\");\n/* harmony import */ var _storages__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../storages */ \"./src/api/storages/index.ts\");\n/* harmony import */ var _preload__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./preload */ \"./src/api/methods/preload.ts\");\n/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tokens */ \"./src/api/methods/tokens.ts\");\n\n\n\n\n\nasync function getBaseCurrency() {\n  var _await$storage$getIte;\n  return (_await$storage$getIte = await _storages__WEBPACK_IMPORTED_MODULE_2__.storage.getItem('baseCurrency')) !== null && _await$storage$getIte !== void 0 ? _await$storage$getIte : _config__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_PRICE_CURRENCY;\n}\nfunction setBaseCurrency(currency) {\n  return _storages__WEBPACK_IMPORTED_MODULE_2__.storage.setItem('baseCurrency', currency);\n}\nasync function fetchPriceHistory(slug, period) {\n  var _token$minterAddress;\n  let baseCurrency = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _config__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_PRICE_CURRENCY;\n  await (0,_preload__WEBPACK_IMPORTED_MODULE_3__.waitDataPreload)();\n  const token = (0,_tokens__WEBPACK_IMPORTED_MODULE_4__.resolveTokenBySlug)(slug);\n  if (!token) {\n    return [];\n  }\n  return (0,_common_backend__WEBPACK_IMPORTED_MODULE_1__.callBackendGet)(`/prices/chart/${(_token$minterAddress = token.minterAddress) !== null && _token$minterAddress !== void 0 ? _token$minterAddress : _config__WEBPACK_IMPORTED_MODULE_0__.TON_SYMBOL}`, {\n    base: baseCurrency,\n    period\n  });\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/methods/prices.ts?");

/***/ }),

/***/ "./src/api/methods/staking.ts":
/*!************************************!*\
  !*** ./src/api/methods/staking.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"checkStakeDraft\": () => (/* binding */ checkStakeDraft),\n/* harmony export */   \"checkUnstakeDraft\": () => (/* binding */ checkUnstakeDraft),\n/* harmony export */   \"fetchBackendStakingState\": () => (/* binding */ fetchBackendStakingState),\n/* harmony export */   \"getBackendStakingState\": () => (/* binding */ getBackendStakingState),\n/* harmony export */   \"getStakingHistory\": () => (/* binding */ getStakingHistory),\n/* harmony export */   \"initStaking\": () => (/* binding */ initStaking),\n/* harmony export */   \"onStakingChangeExpected\": () => (/* binding */ onStakingChangeExpected),\n/* harmony export */   \"submitStake\": () => (/* binding */ submitStake),\n/* harmony export */   \"submitUnstake\": () => (/* binding */ submitUnstake),\n/* harmony export */   \"tryUpdateStakingCommonData\": () => (/* binding */ tryUpdateStakingCommonData)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\n/* harmony import */ var _util_decimals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/decimals */ \"./src/util/decimals.ts\");\n/* harmony import */ var _util_logs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/logs */ \"./src/util/logs.ts\");\n/* harmony import */ var _blockchains__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../blockchains */ \"./src/api/blockchains/index.ts\");\n/* harmony import */ var _blockchains_ton_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../blockchains/ton/constants */ \"./src/api/blockchains/ton/constants.ts\");\n/* harmony import */ var _common_accounts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/accounts */ \"./src/api/common/accounts.ts\");\n/* harmony import */ var _common_backend__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/backend */ \"./src/api/common/backend.ts\");\n/* harmony import */ var _common_cache__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../common/cache */ \"./src/api/common/cache.ts\");\n/* harmony import */ var _common_helpers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common/helpers */ \"./src/api/common/helpers.ts\");\n/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../common/utils */ \"./src/api/common/utils.ts\");\n/* harmony import */ var _environment__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../environment */ \"./src/api/environment.ts\");\n/* harmony import */ var _other__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./other */ \"./src/api/methods/other.ts\");\n/* harmony import */ var _transactions__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./transactions */ \"./src/api/methods/transactions.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst CACHE_TTL = 5000; // 5 s.\nlet backendStakingStateByAddress = {};\n\n// let onUpdate: OnApiUpdate;\n\nfunction initStaking() {\n  // onUpdate = _onUpdate;\n}\nasync function checkStakeDraft(accountId, amount) {\n  const blockchain = _blockchains__WEBPACK_IMPORTED_MODULE_3__[\"default\"][(0,_common_helpers__WEBPACK_IMPORTED_MODULE_8__.resolveBlockchainKey)(accountId)];\n  const backendState = await getBackendStakingState(accountId);\n  return blockchain.checkStakeDraft(accountId, amount, backendState);\n}\nasync function checkUnstakeDraft(accountId, amount) {\n  const blockchain = _blockchains__WEBPACK_IMPORTED_MODULE_3__[\"default\"][(0,_common_helpers__WEBPACK_IMPORTED_MODULE_8__.resolveBlockchainKey)(accountId)];\n  const backendState = await getBackendStakingState(accountId);\n  return blockchain.checkUnstakeDraft(accountId, amount, backendState);\n}\nasync function submitStake(accountId, password, amount, type, fee) {\n  const blockchain = _blockchains__WEBPACK_IMPORTED_MODULE_3__[\"default\"][(0,_common_helpers__WEBPACK_IMPORTED_MODULE_8__.resolveBlockchainKey)(accountId)];\n  const fromAddress = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_5__.fetchStoredAddress)(accountId);\n  const backendState = await getBackendStakingState(accountId);\n  const result = await blockchain.submitStake(accountId, password, amount, type, backendState);\n  if ('error' in result) {\n    return false;\n  }\n  onStakingChangeExpected();\n  const localTransaction = (0,_transactions__WEBPACK_IMPORTED_MODULE_12__.createLocalTransaction)(accountId, {\n    amount: result.amount,\n    fromAddress,\n    toAddress: result.toAddress,\n    comment: _blockchains_ton_constants__WEBPACK_IMPORTED_MODULE_4__.STAKE_COMMENT,\n    fee: fee || 0n,\n    type: 'stake',\n    slug: _config__WEBPACK_IMPORTED_MODULE_0__.TON_TOKEN_SLUG\n  });\n  return {\n    ...result,\n    txId: localTransaction.txId\n  };\n}\nasync function submitUnstake(accountId, password, type, amount, fee) {\n  const blockchain = _blockchains__WEBPACK_IMPORTED_MODULE_3__[\"default\"][(0,_common_helpers__WEBPACK_IMPORTED_MODULE_8__.resolveBlockchainKey)(accountId)];\n  const fromAddress = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_5__.fetchStoredAddress)(accountId);\n  const backendState = await getBackendStakingState(accountId);\n  const result = await blockchain.submitUnstake(accountId, password, type, amount, backendState);\n  if ('error' in result) {\n    return false;\n  }\n  onStakingChangeExpected();\n  const localTransaction = (0,_transactions__WEBPACK_IMPORTED_MODULE_12__.createLocalTransaction)(accountId, {\n    amount: result.amount,\n    fromAddress,\n    toAddress: result.toAddress,\n    comment: _blockchains_ton_constants__WEBPACK_IMPORTED_MODULE_4__.UNSTAKE_COMMENT,\n    fee: fee || 0n,\n    type: 'unstakeRequest',\n    slug: _config__WEBPACK_IMPORTED_MODULE_0__.TON_TOKEN_SLUG\n  });\n  return {\n    ...result,\n    txId: localTransaction.txId\n  };\n}\nasync function getBackendStakingState(accountId) {\n  const {\n    address,\n    ledger\n  } = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_5__.fetchStoredAccount)(accountId);\n  const state = await fetchBackendStakingState(address, Boolean(ledger));\n  return {\n    ...state,\n    nominatorsPool: {\n      ...state.nominatorsPool,\n      start: state.nominatorsPool.start * 1000,\n      end: state.nominatorsPool.end * 1000\n    }\n  };\n}\nasync function fetchBackendStakingState(address, isLedger) {\n  const cacheItem = backendStakingStateByAddress[address];\n  if (cacheItem && cacheItem[0] > Date.now()) {\n    return cacheItem[1];\n  }\n  const headers = {\n    ...(0,_environment__WEBPACK_IMPORTED_MODULE_10__.getEnvironment)().apiHeaders,\n    'X-App-Version': _config__WEBPACK_IMPORTED_MODULE_0__.APP_VERSION,\n    'X-App-ClientID': await (0,_other__WEBPACK_IMPORTED_MODULE_11__.getClientId)(),\n    'X-App-Env': _config__WEBPACK_IMPORTED_MODULE_0__.APP_ENV\n  };\n  const stakingState = await (0,_common_backend__WEBPACK_IMPORTED_MODULE_6__.callBackendGet)(`/staking/state/${address}`, {\n    isLedger\n  }, headers);\n  stakingState.balance = (0,_util_decimals__WEBPACK_IMPORTED_MODULE_1__.fromDecimal)(stakingState.balance);\n  stakingState.totalProfit = (0,_util_decimals__WEBPACK_IMPORTED_MODULE_1__.fromDecimal)(stakingState.totalProfit);\n  if (!(0,_common_utils__WEBPACK_IMPORTED_MODULE_9__.isKnownStakingPool)(stakingState.nominatorsPool.address)) {\n    throw Error('Unexpected pool address, likely a malicious activity');\n  }\n  backendStakingStateByAddress[address] = [Date.now() + CACHE_TTL, stakingState];\n  return stakingState;\n}\nasync function getStakingHistory(accountId, limit, offset) {\n  const address = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_5__.fetchStoredAddress)(accountId);\n  return (0,_common_backend__WEBPACK_IMPORTED_MODULE_6__.callBackendGet)(`/staking/profits/${address}`, {\n    limit,\n    offset\n  });\n}\nfunction onStakingChangeExpected() {\n  backendStakingStateByAddress = {};\n}\nasync function tryUpdateStakingCommonData() {\n  try {\n    const data = await (0,_common_backend__WEBPACK_IMPORTED_MODULE_6__.callBackendGet)('/staking/common');\n    data.round.start *= 1000;\n    data.round.end *= 1000;\n    data.round.unlock *= 1000;\n    data.prevRound.start *= 1000;\n    data.prevRound.end *= 1000;\n    data.prevRound.unlock *= 1000;\n    data.liquid.available = (0,_util_decimals__WEBPACK_IMPORTED_MODULE_1__.fromDecimal)(data.liquid.available);\n    (0,_common_cache__WEBPACK_IMPORTED_MODULE_7__.setStakingCommonCache)(data);\n  } catch (err) {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_2__.logDebugError)('tryUpdateLiquidStakingState', err);\n  }\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/methods/staking.ts?");

/***/ }),

/***/ "./src/api/methods/swap.ts":
/*!*********************************!*\
  !*** ./src/api/methods/swap.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"initSwap\": () => (/* binding */ initSwap),\n/* harmony export */   \"swapBuild\": () => (/* binding */ swapBuild),\n/* harmony export */   \"swapBuildTransfer\": () => (/* binding */ swapBuildTransfer),\n/* harmony export */   \"swapCexCreateTransaction\": () => (/* binding */ swapCexCreateTransaction),\n/* harmony export */   \"swapCexEstimate\": () => (/* binding */ swapCexEstimate),\n/* harmony export */   \"swapCexValidateAddress\": () => (/* binding */ swapCexValidateAddress),\n/* harmony export */   \"swapEstimate\": () => (/* binding */ swapEstimate),\n/* harmony export */   \"swapGetAssets\": () => (/* binding */ swapGetAssets),\n/* harmony export */   \"swapGetHistory\": () => (/* binding */ swapGetHistory),\n/* harmony export */   \"swapGetHistoryByRanges\": () => (/* binding */ swapGetHistoryByRanges),\n/* harmony export */   \"swapGetHistoryItem\": () => (/* binding */ swapGetHistoryItem),\n/* harmony export */   \"swapGetPairs\": () => (/* binding */ swapGetPairs),\n/* harmony export */   \"swapGetTonCurrencies\": () => (/* binding */ swapGetTonCurrencies),\n/* harmony export */   \"swapItemToActivity\": () => (/* binding */ swapItemToActivity),\n/* harmony export */   \"swapReplaceTransactions\": () => (/* binding */ swapReplaceTransactions),\n/* harmony export */   \"swapReplaceTransactionsByRanges\": () => (/* binding */ swapReplaceTransactionsByRanges),\n/* harmony export */   \"swapSubmit\": () => (/* binding */ swapSubmit)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\n/* harmony import */ var _util_account__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/account */ \"./src/util/account.ts\");\n/* harmony import */ var _util_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/assert */ \"./src/util/assert.ts\");\n/* harmony import */ var _util_decimals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/decimals */ \"./src/util/decimals.ts\");\n/* harmony import */ var _util_logs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/logs */ \"./src/util/logs.ts\");\n/* harmony import */ var _util_schedulers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/schedulers */ \"./src/util/schedulers.ts\");\n/* harmony import */ var _util_swap_buildSwapId__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/swap/buildSwapId */ \"./src/util/swap/buildSwapId.ts\");\n/* harmony import */ var _blockchains__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../blockchains */ \"./src/api/blockchains/index.ts\");\n/* harmony import */ var _blockchains_ton_util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../blockchains/ton/util */ \"./src/api/blockchains/ton/util/index.ts\");\n/* harmony import */ var _common_accounts__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../common/accounts */ \"./src/api/common/accounts.ts\");\n/* harmony import */ var _common_backend__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../common/backend */ \"./src/api/common/backend.ts\");\n/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../hooks */ \"./src/api/hooks.ts\");\n/* harmony import */ var _other__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./other */ \"./src/api/methods/other.ts\");\n/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./tokens */ \"./src/api/methods/tokens.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst SWAP_MAX_LT = 50;\nconst SWAP_WAITING_TIME = 5 * 60 * 1_000; // 5 min\nconst SWAP_WAITING_PAUSE = 1_000; // 1 sec\nconst MAX_OLD_SWAP_ID = 41276;\nconst ton = _blockchains__WEBPACK_IMPORTED_MODULE_7__[\"default\"].ton;\nlet onUpdate;\nfunction initSwap(_onUpdate) {\n  onUpdate = _onUpdate;\n}\nasync function swapBuildTransfer(accountId, password, params) {\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_1__.parseAccountId)(accountId);\n  const authToken = await (0,_other__WEBPACK_IMPORTED_MODULE_12__.getBackendAuthToken)(accountId, password);\n  const address = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_9__.fetchStoredAddress)(accountId);\n  const {\n    id,\n    transfers\n  } = await swapBuild(authToken, params);\n  const transferList = transfers.map(transfer => ({\n    ...transfer,\n    amount: BigInt(transfer.amount),\n    isBase64Payload: true\n  }));\n  await ton.validateDexSwapTransfers(network, address, params, transferList);\n  const result = await ton.checkMultiTransactionDraft(accountId, transferList);\n  if ('error' in result) {\n    return result;\n  }\n  return {\n    ...result,\n    id,\n    transfers\n  };\n}\nasync function swapSubmit(accountId, password, fee, transfers, historyItem) {\n  const transferList = transfers.map(transfer => ({\n    ...transfer,\n    amount: BigInt(transfer.amount),\n    isBase64Payload: true\n  }));\n  const result = await ton.submitMultiTransfer(accountId, password, transferList);\n  if ('error' in result) {\n    return result;\n  }\n  const from = getSwapItemSlug(historyItem, historyItem.from);\n  const to = getSwapItemSlug(historyItem, historyItem.to);\n  const swap = {\n    ...historyItem,\n    id: (0,_util_swap_buildSwapId__WEBPACK_IMPORTED_MODULE_6__.buildSwapId)(historyItem.id),\n    from,\n    to,\n    kind: 'swap'\n  };\n  onUpdate({\n    type: 'newActivities',\n    accountId,\n    activities: [swap]\n  });\n  void (0,_hooks__WEBPACK_IMPORTED_MODULE_11__.callHook)('onSwapCreated', accountId, swap.timestamp - 1);\n  return result;\n}\nfunction getSwapItemSlug(item, asset) {\n  if (asset === _config__WEBPACK_IMPORTED_MODULE_0__.TON_SYMBOL) return _config__WEBPACK_IMPORTED_MODULE_0__.TON_TOKEN_SLUG;\n  if (item.cex) return asset;\n  return (0,_blockchains_ton_util__WEBPACK_IMPORTED_MODULE_8__.buildTokenSlug)(asset);\n}\nasync function swapReplaceTransactions(accountId, transactions, network, slug) {\n  if (!transactions.length || network === 'testnet') {\n    return transactions;\n  }\n  try {\n    var _resolveTokenBySlug$m;\n    const address = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_9__.fetchStoredAddress)(accountId);\n    const asset = slug ? (_resolveTokenBySlug$m = (0,_tokens__WEBPACK_IMPORTED_MODULE_13__.resolveTokenBySlug)(slug).minterAddress) !== null && _resolveTokenBySlug$m !== void 0 ? _resolveTokenBySlug$m : _config__WEBPACK_IMPORTED_MODULE_0__.TON_SYMBOL : undefined;\n    const {\n      fromLt,\n      toLt,\n      fromTime,\n      toTime\n    } = buildSwapHistoryRange(transactions);\n    const swaps = await swapGetHistory(address, {\n      fromLt,\n      toLt,\n      fromTimestamp: fromTime,\n      toTimestamp: toTime,\n      asset\n    });\n    if (!swaps.length) {\n      return transactions;\n    }\n    return replaceTransactions(transactions, swaps);\n  } catch (err) {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_4__.logDebugError)('swapReplaceTransactions', err);\n    return transactions;\n  }\n}\nasync function swapReplaceTransactionsByRanges(accountId, transactions, chunks, isFirstLoad) {\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_1__.parseAccountId)(accountId);\n  if (!chunks.length || network === 'testnet') {\n    return transactions;\n  }\n  try {\n    const address = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_9__.fetchStoredAddress)(accountId);\n    if (!isFirstLoad) {\n      await waitPendingDexSwap(address);\n    }\n    const ranges = chunks.map(txs => buildSwapHistoryRange(txs));\n    const swaps = await swapGetHistoryByRanges(address, ranges);\n    if (!swaps.length) {\n      return [...transactions];\n    }\n    return replaceTransactions(transactions, swaps);\n  } catch (err) {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_4__.logDebugError)('swapReplaceTransactionsByRanges', err);\n    return [...transactions];\n  }\n}\nfunction replaceTransactions(transactions, swaps) {\n  const result = [];\n  const hiddenTxIds = new Set();\n  const skipLtRanges = []; // TODO Remove it after applying correcting script in backend\n\n  for (const swap of swaps) {\n    var _swap$txIds;\n    (_swap$txIds = swap.txIds) === null || _swap$txIds === void 0 || _swap$txIds.forEach(txId => {\n      hiddenTxIds.add(txId);\n    });\n    if (swap.lt && Number(swap.id) < MAX_OLD_SWAP_ID) {\n      skipLtRanges.push([swap.lt, swap.lt + SWAP_MAX_LT]);\n    }\n    const swapActivity = swapItemToActivity(swap);\n    result.push(swapActivity);\n  }\n  for (let transaction of transactions) {\n    const [ltString, hash] = transaction.txId.split(':');\n    const lt = Number(ltString);\n    const shortenedTxId = `${lt}:${hash}`;\n    const shouldHide = Boolean(hiddenTxIds.has(shortenedTxId) || skipLtRanges.find(_ref => {\n      let [startLt, endLt] = _ref;\n      return lt >= startLt && lt <= endLt;\n    }));\n    if (shouldHide) {\n      transaction = {\n        ...transaction,\n        shouldHide\n      };\n    }\n    result.push(transaction);\n  }\n  return result;\n}\nasync function waitPendingDexSwap(address) {\n  const waitUntil = Date.now() + SWAP_WAITING_TIME;\n  while (Date.now() < waitUntil) {\n    const pendingSwaps = await swapGetHistory(address, {\n      status: 'pending',\n      isCex: false\n    });\n    if (!pendingSwaps.length) {\n      break;\n    }\n    await (0,_util_schedulers__WEBPACK_IMPORTED_MODULE_5__.pause)(SWAP_WAITING_PAUSE);\n  }\n}\nfunction buildSwapHistoryRange(transactions) {\n  const firstLt = (0,_blockchains_ton_util__WEBPACK_IMPORTED_MODULE_8__.parseTxId)(transactions[0].txId).lt;\n  const lastLt = (0,_blockchains_ton_util__WEBPACK_IMPORTED_MODULE_8__.parseTxId)(transactions[transactions.length - 1].txId).lt;\n  const firstTimestamp = transactions[0].timestamp;\n  const lastTimestamp = transactions[transactions.length - 1].timestamp;\n  const [fromLt, fromTime] = firstLt > lastLt ? [lastLt, lastTimestamp] : [firstLt, firstTimestamp];\n  const [toLt, toTime] = firstLt > lastLt ? [firstLt, firstTimestamp] : [lastLt, lastTimestamp];\n  const slug = transactions[0].slug;\n  const asset = slug === _config__WEBPACK_IMPORTED_MODULE_0__.TON_TOKEN_SLUG ? _config__WEBPACK_IMPORTED_MODULE_0__.TON_SYMBOL : (0,_tokens__WEBPACK_IMPORTED_MODULE_13__.resolveTokenBySlug)(slug).minterAddress;\n  return {\n    asset,\n    fromLt: Math.floor(fromLt / 100) * 100,\n    toLt,\n    fromTime,\n    toTime\n  };\n}\nfunction swapItemToActivity(swap) {\n  return {\n    ...swap,\n    id: (0,_util_swap_buildSwapId__WEBPACK_IMPORTED_MODULE_6__.buildSwapId)(swap.id),\n    kind: 'swap',\n    from: getSwapItemSlug(swap, swap.from),\n    to: getSwapItemSlug(swap, swap.to)\n  };\n}\nfunction swapEstimate(params) {\n  return (0,_common_backend__WEBPACK_IMPORTED_MODULE_10__.callBackendPost)('/swap/ton/estimate', params, {\n    isAllowBadRequest: true\n  });\n}\nfunction swapBuild(authToken, params) {\n  return (0,_common_backend__WEBPACK_IMPORTED_MODULE_10__.callBackendPost)('/swap/ton/build', params, {\n    authToken\n  });\n}\nfunction swapGetAssets() {\n  return (0,_common_backend__WEBPACK_IMPORTED_MODULE_10__.callBackendGet)('/swap/assets');\n}\nfunction swapGetTonCurrencies() {\n  return (0,_common_backend__WEBPACK_IMPORTED_MODULE_10__.callBackendGet)('/swap/ton/tokens');\n}\nfunction swapGetPairs(symbolOrMinter) {\n  return (0,_common_backend__WEBPACK_IMPORTED_MODULE_10__.callBackendGet)('/swap/pairs', {\n    asset: symbolOrMinter\n  });\n}\nfunction swapGetHistory(address, params) {\n  return (0,_common_backend__WEBPACK_IMPORTED_MODULE_10__.callBackendGet)(`/swap/history/${address}`, params);\n}\nfunction swapGetHistoryByRanges(address, ranges) {\n  return (0,_common_backend__WEBPACK_IMPORTED_MODULE_10__.callBackendPost)(`/swap/history-ranges/${address}`, {\n    ranges\n  });\n}\nfunction swapGetHistoryItem(address, id) {\n  return (0,_common_backend__WEBPACK_IMPORTED_MODULE_10__.callBackendGet)(`/swap/history/${address}/${id}`);\n}\nfunction swapCexEstimate(params) {\n  return (0,_common_backend__WEBPACK_IMPORTED_MODULE_10__.callBackendPost)('/swap/cex/estimate', params);\n}\nfunction swapCexValidateAddress(params) {\n  return (0,_common_backend__WEBPACK_IMPORTED_MODULE_10__.callBackendGet)('/swap/cex/validate-address', params);\n}\nasync function swapCexCreateTransaction(accountId, password, params) {\n  const authToken = await (0,_other__WEBPACK_IMPORTED_MODULE_12__.getBackendAuthToken)(accountId, password);\n  const {\n    swap\n  } = await (0,_common_backend__WEBPACK_IMPORTED_MODULE_10__.callBackendPost)('/swap/cex/createTransaction', params, {\n    authToken\n  });\n  const activity = swapItemToActivity(swap);\n  let transfer;\n  if (params.from === _config__WEBPACK_IMPORTED_MODULE_0__.TON_SYMBOL) {\n    transfer = {\n      toAddress: swap.cex.payinAddress,\n      amount: (0,_util_decimals__WEBPACK_IMPORTED_MODULE_3__.fromDecimal)(swap.fromAmount)\n    };\n    (0,_util_assert__WEBPACK_IMPORTED_MODULE_2__.assert)(transfer.amount <= (0,_util_decimals__WEBPACK_IMPORTED_MODULE_3__.fromDecimal)(params.fromAmount));\n  }\n  onUpdate({\n    type: 'newActivities',\n    accountId,\n    activities: [activity]\n  });\n  void (0,_hooks__WEBPACK_IMPORTED_MODULE_11__.callHook)('onSwapCreated', accountId, swap.timestamp - 1);\n  return {\n    swap,\n    activity,\n    transfer\n  };\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/methods/swap.ts?");

/***/ }),

/***/ "./src/api/methods/tokens.ts":
/*!***********************************!*\
  !*** ./src/api/methods/tokens.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"buildTokenSlug\": () => (/* binding */ buildTokenSlug),\n/* harmony export */   \"fetchToken\": () => (/* binding */ fetchToken),\n/* harmony export */   \"fetchTokenBalances\": () => (/* binding */ fetchTokenBalances),\n/* harmony export */   \"fetchTokenBalancesByAddress\": () => (/* binding */ fetchTokenBalancesByAddress),\n/* harmony export */   \"resolveTokenBySlug\": () => (/* binding */ resolveTokenBySlug),\n/* harmony export */   \"resolveTokenMinterAddress\": () => (/* binding */ resolveTokenMinterAddress),\n/* harmony export */   \"resolveTokenWalletAddress\": () => (/* binding */ resolveTokenWalletAddress)\n/* harmony export */ });\n/* harmony import */ var _util_account__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/account */ \"./src/util/account.ts\");\n/* harmony import */ var _blockchains__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../blockchains */ \"./src/api/blockchains/index.ts\");\n\n\nfunction fetchToken(accountId, address) {\n  const {\n    network,\n    blockchain: blockchainKey\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_0__.parseAccountId)(accountId);\n  const blockchain = _blockchains__WEBPACK_IMPORTED_MODULE_1__[\"default\"][blockchainKey];\n  return blockchain.fetchToken(network, address);\n}\nfunction resolveTokenBySlug(slug) {\n  const blockchain = _blockchains__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ton;\n  return blockchain.resolveTokenBySlug(slug);\n}\nfunction resolveTokenWalletAddress(network, address, minterAddress) {\n  const blockchain = _blockchains__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ton;\n  return blockchain.resolveTokenWalletAddress(network, address, minterAddress);\n}\nfunction resolveTokenMinterAddress(network, tokenWalletAddress) {\n  const blockchain = _blockchains__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ton;\n  return blockchain.resolveTokenMinterAddress(network, tokenWalletAddress);\n}\nfunction buildTokenSlug(address) {\n  const blockchain = _blockchains__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ton;\n  return blockchain.buildTokenSlug(address);\n}\nfunction fetchTokenBalances(accountId) {\n  const blockchain = _blockchains__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ton;\n  return blockchain.getAccountTokenBalances(accountId);\n}\nfunction fetchTokenBalancesByAddress(address, network) {\n  const blockchain = _blockchains__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ton;\n  return blockchain.getAddressTokenBalances(address, network);\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/methods/tokens.ts?");

/***/ }),

/***/ "./src/api/methods/transactions.ts":
/*!*****************************************!*\
  !*** ./src/api/methods/transactions.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"checkTransactionDraft\": () => (/* binding */ checkTransactionDraft),\n/* harmony export */   \"createLocalTransaction\": () => (/* binding */ createLocalTransaction),\n/* harmony export */   \"decryptComment\": () => (/* binding */ decryptComment),\n/* harmony export */   \"fetchAllActivitySlice\": () => (/* binding */ fetchAllActivitySlice),\n/* harmony export */   \"fetchTokenActivitySlice\": () => (/* binding */ fetchTokenActivitySlice),\n/* harmony export */   \"initTransactions\": () => (/* binding */ initTransactions),\n/* harmony export */   \"sendSignedTransferMessage\": () => (/* binding */ sendSignedTransferMessage),\n/* harmony export */   \"sendSignedTransferMessages\": () => (/* binding */ sendSignedTransferMessages),\n/* harmony export */   \"submitTransfer\": () => (/* binding */ submitTransfer),\n/* harmony export */   \"waitLastTransfer\": () => (/* binding */ waitLastTransfer)\n/* harmony export */ });\n/* harmony import */ var _util_account__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/account */ \"./src/util/account.ts\");\n/* harmony import */ var _util_logs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/logs */ \"./src/util/logs.ts\");\n/* harmony import */ var _blockchains__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../blockchains */ \"./src/api/blockchains/index.ts\");\n/* harmony import */ var _common_accounts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/accounts */ \"./src/api/common/accounts.ts\");\n/* harmony import */ var _common_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/helpers */ \"./src/api/common/helpers.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../errors */ \"./src/api/errors.ts\");\n/* harmony import */ var _swap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./swap */ \"./src/api/methods/swap.ts\");\n\n\n\n\n\n\n\nlet onUpdate;\nfunction initTransactions(_onUpdate) {\n  onUpdate = _onUpdate;\n}\nasync function fetchTokenActivitySlice(accountId, slug, fromTxId, limit) {\n  const {\n    network,\n    blockchain\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_0__.parseAccountId)(accountId);\n  const activeBlockchain = _blockchains__WEBPACK_IMPORTED_MODULE_2__[\"default\"][blockchain];\n  try {\n    const transactions = await activeBlockchain.getTokenTransactionSlice(accountId, slug, fromTxId, undefined, limit);\n    const activities = await (0,_swap__WEBPACK_IMPORTED_MODULE_6__.swapReplaceTransactions)(accountId, transactions, network, slug);\n    await activeBlockchain.fixTokenActivitiesAddressForm(network, activities);\n    return activities;\n  } catch (err) {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_1__.logDebugError)('fetchTokenActivitySlice', err);\n    return (0,_errors__WEBPACK_IMPORTED_MODULE_5__.handleServerError)(err);\n  }\n}\nasync function fetchAllActivitySlice(accountId, lastTxIds, limit) {\n  const {\n    network,\n    blockchain\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_0__.parseAccountId)(accountId);\n  const activeBlockchain = _blockchains__WEBPACK_IMPORTED_MODULE_2__[\"default\"][blockchain];\n  try {\n    const transactions = await activeBlockchain.getMergedTransactionSlice(accountId, lastTxIds, limit);\n    const activities = await (0,_swap__WEBPACK_IMPORTED_MODULE_6__.swapReplaceTransactions)(accountId, transactions, network);\n    await activeBlockchain.fixTokenActivitiesAddressForm(network, activities);\n    return activities;\n  } catch (err) {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_1__.logDebugError)('fetchAllActivitySlice', err);\n    return (0,_errors__WEBPACK_IMPORTED_MODULE_5__.handleServerError)(err);\n  }\n}\nfunction checkTransactionDraft(accountId, slug, toAddress, amount, comment, shouldEncrypt) {\n  const blockchain = _blockchains__WEBPACK_IMPORTED_MODULE_2__[\"default\"][(0,_common_helpers__WEBPACK_IMPORTED_MODULE_4__.resolveBlockchainKey)(accountId)];\n  return blockchain.checkTransactionDraft(accountId, slug, toAddress, amount, comment, undefined, shouldEncrypt);\n}\nasync function submitTransfer(options) {\n  let shouldCreateLocalTransaction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  const {\n    accountId,\n    password,\n    slug,\n    toAddress,\n    amount,\n    comment,\n    fee,\n    shouldEncrypt\n  } = options;\n  const blockchain = _blockchains__WEBPACK_IMPORTED_MODULE_2__[\"default\"][(0,_common_helpers__WEBPACK_IMPORTED_MODULE_4__.resolveBlockchainKey)(accountId)];\n  const fromAddress = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_3__.fetchStoredAddress)(accountId);\n  const result = await blockchain.submitTransfer(accountId, password, slug, toAddress, amount, comment, undefined, shouldEncrypt);\n  if ('error' in result) {\n    return result;\n  }\n  const {\n    encryptedComment\n  } = result;\n  if (!shouldCreateLocalTransaction) {\n    return result;\n  }\n  const localTransaction = createLocalTransaction(accountId, {\n    amount,\n    fromAddress,\n    toAddress,\n    comment: shouldEncrypt ? undefined : comment,\n    encryptedComment,\n    fee: fee || 0n,\n    slug\n  });\n  return {\n    ...result,\n    txId: localTransaction.txId\n  };\n}\nasync function waitLastTransfer(accountId) {\n  const blockchain = _blockchains__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ton;\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_0__.parseAccountId)(accountId);\n  const address = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_3__.fetchStoredAddress)(accountId);\n  return blockchain.waitLastTransfer(network, address);\n}\nasync function sendSignedTransferMessage(accountId, message) {\n  const blockchain = _blockchains__WEBPACK_IMPORTED_MODULE_2__[\"default\"][(0,_common_helpers__WEBPACK_IMPORTED_MODULE_4__.resolveBlockchainKey)(accountId)];\n  await blockchain.sendSignedMessage(accountId, message);\n  const localTransaction = createLocalTransaction(accountId, message.params);\n  return localTransaction.txId;\n}\nasync function sendSignedTransferMessages(accountId, messages) {\n  const blockchain = _blockchains__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ton;\n  const result = await blockchain.sendSignedMessages(accountId, messages);\n  for (let i = 0; i < result.successNumber; i++) {\n    createLocalTransaction(accountId, messages[i].params);\n  }\n  return result;\n}\nfunction decryptComment(accountId, encryptedComment, fromAddress, password) {\n  const blockchain = _blockchains__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ton;\n  return blockchain.decryptComment(accountId, encryptedComment, fromAddress, password);\n}\nfunction createLocalTransaction(accountId, params) {\n  const {\n    blockchain: blockchainKey,\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_0__.parseAccountId)(accountId);\n  const blockchain = _blockchains__WEBPACK_IMPORTED_MODULE_2__[\"default\"][blockchainKey];\n  const {\n    toAddress\n  } = params;\n  const normalizedAddress = blockchain.normalizeAddress(toAddress, network);\n  const localTransaction = (0,_common_helpers__WEBPACK_IMPORTED_MODULE_4__.buildLocalTransaction)(params, normalizedAddress);\n  onUpdate({\n    type: 'newLocalTransaction',\n    transaction: localTransaction,\n    accountId\n  });\n  return localTransaction;\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/methods/transactions.ts?");

/***/ }),

/***/ "./src/api/methods/wallet.ts":
/*!***********************************!*\
  !*** ./src/api/methods/wallet.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"cancelDappRequest\": () => (/* binding */ cancelDappRequest),\n/* harmony export */   \"confirmDappRequest\": () => (/* binding */ confirmDappRequest),\n/* harmony export */   \"confirmDappRequestConnect\": () => (/* binding */ confirmDappRequestConnect),\n/* harmony export */   \"fetchAddress\": () => (/* binding */ fetchAddress),\n/* harmony export */   \"getMnemonic\": () => (/* binding */ getMnemonic),\n/* harmony export */   \"getMnemonicWordList\": () => (/* binding */ getMnemonicWordList),\n/* harmony export */   \"getWalletBalance\": () => (/* binding */ getWalletBalance),\n/* harmony export */   \"getWalletSeqno\": () => (/* binding */ getWalletSeqno),\n/* harmony export */   \"isWalletInitialized\": () => (/* binding */ isWalletInitialized),\n/* harmony export */   \"verifyPassword\": () => (/* binding */ verifyPassword)\n/* harmony export */ });\n/* harmony import */ var tonweb_mnemonic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tonweb-mnemonic */ \"./node_modules/tonweb-mnemonic/dist/web/index.js\");\n/* harmony import */ var tonweb_mnemonic__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tonweb_mnemonic__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _util_account__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/account */ \"./src/util/account.ts\");\n/* harmony import */ var _blockchains__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../blockchains */ \"./src/api/blockchains/index.ts\");\n/* harmony import */ var _common_accounts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/accounts */ \"./src/api/common/accounts.ts\");\n/* harmony import */ var _common_dappPromises__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/dappPromises */ \"./src/api/common/dappPromises.ts\");\n/* harmony import */ var _common_helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/helpers */ \"./src/api/common/helpers.ts\");\n\n\n\n\n\n\nconst ton = _blockchains__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ton;\nfunction getMnemonic(accountId, password) {\n  const blockchain = _blockchains__WEBPACK_IMPORTED_MODULE_2__[\"default\"][(0,_common_helpers__WEBPACK_IMPORTED_MODULE_5__.resolveBlockchainKey)(accountId)];\n  return blockchain.fetchMnemonic(accountId, password);\n}\nfunction getMnemonicWordList() {\n  return tonweb_mnemonic__WEBPACK_IMPORTED_MODULE_0__.wordlists[\"default\"];\n}\nasync function verifyPassword(password) {\n  const accountId = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_3__.getAccountIdWithMnemonic)();\n  if (!accountId) {\n    throw new Error('The user is not authorized in the wallet');\n  }\n  const blockchain = _blockchains__WEBPACK_IMPORTED_MODULE_2__[\"default\"][(0,_common_helpers__WEBPACK_IMPORTED_MODULE_5__.resolveBlockchainKey)(accountId)];\n  return blockchain.verifyPassword(accountId, password);\n}\nfunction confirmDappRequest(promiseId, data) {\n  _common_dappPromises__WEBPACK_IMPORTED_MODULE_4__.resolveDappPromise(promiseId, data);\n}\nfunction confirmDappRequestConnect(promiseId, data) {\n  _common_dappPromises__WEBPACK_IMPORTED_MODULE_4__.resolveDappPromise(promiseId, data);\n}\nfunction cancelDappRequest(promiseId, reason) {\n  _common_dappPromises__WEBPACK_IMPORTED_MODULE_4__.rejectDappPromise(promiseId, reason);\n}\nasync function getWalletSeqno(accountId) {\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_1__.parseAccountId)(accountId);\n  const address = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_3__.fetchStoredAddress)(accountId);\n  return ton.getWalletSeqno(network, address);\n}\nfunction fetchAddress(accountId) {\n  return (0,_common_accounts__WEBPACK_IMPORTED_MODULE_3__.fetchStoredAddress)(accountId);\n}\nfunction isWalletInitialized(network, address) {\n  const blockchain = _blockchains__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ton;\n  return blockchain.isAddressInitialized(network, address);\n}\nfunction getWalletBalance(network, address) {\n  const blockchain = _blockchains__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ton;\n  return blockchain.getWalletBalance(network, address);\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/methods/wallet.ts?");

/***/ }),

/***/ "./src/api/providers/worker/provider.ts":
/*!**********************************************!*\
  !*** ./src/api/providers/worker/provider.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _util_createPostMessageInterface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/createPostMessageInterface */ \"./src/util/createPostMessageInterface.ts\");\n/* harmony import */ var _methods__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../methods */ \"./src/api/methods/index.ts\");\n/* harmony import */ var _methods_init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../methods/init */ \"./src/api/methods/init.ts\");\n/* harmony import */ var _tonConnect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../tonConnect */ \"./src/api/tonConnect/index.ts\");\n\n\n\n\n(0,_util_createPostMessageInterface__WEBPACK_IMPORTED_MODULE_0__.createPostMessageInterface)(function (name, origin) {\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n  if (name === 'init') {\n    return (0,_methods_init__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(args[0], args[1]);\n  } else {\n    if (name.startsWith('tonConnect_')) {\n      name = name.replace('tonConnect_', '');\n      const method = _tonConnect__WEBPACK_IMPORTED_MODULE_3__[name];\n      // @ts-ignore\n      return method(...args);\n    }\n    const method = _methods__WEBPACK_IMPORTED_MODULE_1__[name];\n\n    // @ts-ignore\n    return method(...args);\n  }\n});\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/providers/worker/provider.ts?");

/***/ }),

/***/ "./src/api/storages/index.ts":
/*!***********************************!*\
  !*** ./src/api/storages/index.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"storage\": () => (/* binding */ storage)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./src/api/storages/types.ts\");\n/* harmony import */ var _localStorage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./localStorage */ \"./src/api/storages/localStorage.ts\");\n\n\nconst storage = _localStorage__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  [_types__WEBPACK_IMPORTED_MODULE_0__.StorageType.LocalStorage]: _localStorage__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n});\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/storages/index.ts?");

/***/ }),

/***/ "./src/api/storages/localStorage.ts":
/*!******************************************!*\
  !*** ./src/api/storages/localStorage.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_iteratees__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/iteratees */ \"./src/util/iteratees.ts\");\n\nfunction withPromise(fn) {\n  return function () {\n    return Promise.resolve(fn(...arguments));\n  };\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (typeof localStorage === 'object' ? {\n  getItem: withPromise(localStorage.getItem),\n  setItem: localStorage.setItem,\n  removeItem: localStorage.removeItem,\n  clear: localStorage.clear,\n  getAll: withPromise(() => ({\n    ...localStorage\n  })),\n  getMany: withPromise(keys => (0,_util_iteratees__WEBPACK_IMPORTED_MODULE_0__.pick)(localStorage, keys)),\n  setMany: items => {\n    Object.assign(localStorage, items);\n  }\n} : {});\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/storages/localStorage.ts?");

/***/ }),

/***/ "./src/api/storages/types.ts":
/*!***********************************!*\
  !*** ./src/api/storages/types.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"StorageType\": () => (/* binding */ StorageType)\n/* harmony export */ });\nlet StorageType = /*#__PURE__*/function (StorageType) {\n  StorageType[StorageType[\"LocalStorage\"] = 0] = \"LocalStorage\";\n  return StorageType;\n}({});\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/storages/types.ts?");

/***/ }),

/***/ "./src/api/tonConnect/errors.ts":
/*!**************************************!*\
  !*** ./src/api/tonConnect/errors.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BadRequestError\": () => (/* binding */ BadRequestError),\n/* harmony export */   \"InsufficientBalance\": () => (/* binding */ InsufficientBalance),\n/* harmony export */   \"ManifestContentError\": () => (/* binding */ ManifestContentError),\n/* harmony export */   \"TonConnectError\": () => (/* binding */ TonConnectError),\n/* harmony export */   \"UnknownAppError\": () => (/* binding */ UnknownAppError),\n/* harmony export */   \"UnknownError\": () => (/* binding */ UnknownError),\n/* harmony export */   \"UserRejectsError\": () => (/* binding */ UserRejectsError)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./src/api/tonConnect/types/index.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors */ \"./src/api/errors.ts\");\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// eslint-disable-next-line max-classes-per-file\n\n\n\nclass TonConnectError extends _errors__WEBPACK_IMPORTED_MODULE_1__.ApiBaseError {\n  constructor(message) {\n    let code = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let displayError = arguments.length > 2 ? arguments[2] : undefined;\n    super(message);\n    _defineProperty(this, \"code\", void 0);\n    this.code = code;\n    this.displayError = displayError;\n  }\n}\nclass ManifestContentError extends TonConnectError {\n  constructor() {\n    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Manifest content error';\n    super(message, _types__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.MANIFEST_CONTENT_ERROR);\n  }\n}\nclass UnknownError extends TonConnectError {\n  constructor() {\n    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Unknown error.';\n    super(message, 0);\n  }\n}\nclass BadRequestError extends TonConnectError {\n  constructor() {\n    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Bad request';\n    let displayError = arguments.length > 1 ? arguments[1] : undefined;\n    super(message, 1, displayError);\n  }\n}\nclass UnknownAppError extends TonConnectError {\n  constructor() {\n    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Unknown app error';\n    super(message, 100);\n  }\n}\nclass UserRejectsError extends TonConnectError {\n  constructor() {\n    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'The user rejected the action';\n    super(message, 300);\n  }\n}\nclass InsufficientBalance extends BadRequestError {\n  constructor() {\n    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Insufficient balance';\n    super(message);\n  }\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/tonConnect/errors.ts?");

/***/ }),

/***/ "./src/api/tonConnect/index.ts":
/*!*************************************!*\
  !*** ./src/api/tonConnect/index.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"connect\": () => (/* binding */ connect),\n/* harmony export */   \"deactivate\": () => (/* binding */ deactivate),\n/* harmony export */   \"disconnect\": () => (/* binding */ disconnect),\n/* harmony export */   \"fetchDappMetadata\": () => (/* binding */ fetchDappMetadata),\n/* harmony export */   \"initTonConnect\": () => (/* binding */ initTonConnect),\n/* harmony export */   \"reconnect\": () => (/* binding */ reconnect),\n/* harmony export */   \"sendTransaction\": () => (/* binding */ sendTransaction),\n/* harmony export */   \"signData\": () => (/* binding */ signData)\n/* harmony export */ });\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ton/core */ \"./node_modules/@ton/core/dist/index.js\");\n/* harmony import */ var _ton_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ton_core__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tonconnect/protocol */ \"./node_modules/@tonconnect/protocol/lib/esm/index.mjs\");\n/* harmony import */ var tweetnacl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tweetnacl */ \"./node_modules/tweetnacl/nacl-fast.js\");\n/* harmony import */ var tweetnacl__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(tweetnacl__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../types */ \"./src/api/types/index.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types */ \"./src/api/tonConnect/types/index.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../config */ \"./src/config.ts\");\n/* harmony import */ var _util_account__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/account */ \"./src/util/account.ts\");\n/* harmony import */ var _util_logs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/logs */ \"./src/util/logs.ts\");\n/* harmony import */ var _util_metadata__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/metadata */ \"./src/util/metadata.ts\");\n/* harmony import */ var _util_safeExec__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../util/safeExec */ \"./src/util/safeExec.ts\");\n/* harmony import */ var _blockchains__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../blockchains */ \"./src/api/blockchains/index.ts\");\n/* harmony import */ var _blockchains_ton__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../blockchains/ton */ \"./src/api/blockchains/ton/index.ts\");\n/* harmony import */ var _blockchains_ton_auth__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../blockchains/ton/auth */ \"./src/api/blockchains/ton/auth.ts\");\n/* harmony import */ var _blockchains_ton_util_tonCore__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../blockchains/ton/util/tonCore */ \"./src/api/blockchains/ton/util/tonCore.ts\");\n/* harmony import */ var _common_accounts__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../common/accounts */ \"./src/api/common/accounts.ts\");\n/* harmony import */ var _common_dappPromises__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../common/dappPromises */ \"./src/api/common/dappPromises.ts\");\n/* harmony import */ var _common_helpers__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../common/helpers */ \"./src/api/common/helpers.ts\");\n/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../common/utils */ \"./src/api/common/utils.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../errors */ \"./src/api/errors.ts\");\n/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../hooks */ \"./src/api/hooks.ts\");\n/* harmony import */ var _methods_dapps__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../methods/dapps */ \"./src/api/methods/dapps.ts\");\n/* harmony import */ var _methods__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../methods */ \"./src/api/methods/index.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./errors */ \"./src/api/tonConnect/errors.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./utils */ \"./src/api/tonConnect/utils.ts\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n// eslint-disable-next-line max-classes-per-file\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst ton = _blockchains__WEBPACK_IMPORTED_MODULE_10__[\"default\"].ton;\nlet resolveInit;\nconst initPromise = new Promise(resolve => {\n  resolveInit = resolve;\n});\nlet onPopupUpdate;\nfunction initTonConnect(_onPopupUpdate) {\n  onPopupUpdate = _onPopupUpdate;\n  resolveInit();\n}\nasync function connect(request, message, id) {\n  try {\n    await openExtensionPopup(true);\n    onPopupUpdate({\n      type: 'dappLoading',\n      connectionType: 'connect',\n      isSse: request && 'sseOptions' in request\n    });\n    const dappMetadata = await fetchDappMetadata(message.manifestUrl);\n    // Take origin from manifest metadata\n    request.origin = dappMetadata.origin;\n    const {\n      origin\n    } = await validateRequest(request, true);\n    const addressItem = message.items.find(_ref => {\n      let {\n        name\n      } = _ref;\n      return name === 'ton_addr';\n    });\n    const proofItem = message.items.find(_ref2 => {\n      let {\n        name\n      } = _ref2;\n      return name === 'ton_proof';\n    });\n    const proof = proofItem ? {\n      timestamp: Math.round(Date.now() / 1000),\n      domain: new URL(origin).host,\n      payload: proofItem.payload\n    } : undefined;\n    if (!addressItem) {\n      throw new _errors__WEBPACK_IMPORTED_MODULE_22__.BadRequestError(\"Missing 'ton_addr'\");\n    }\n    let accountId = await getCurrentAccountOrFail();\n    const {\n      promiseId,\n      promise\n    } = (0,_common_dappPromises__WEBPACK_IMPORTED_MODULE_15__.createDappPromise)();\n    const dapp = {\n      ...(await dappMetadata),\n      connectedAt: Date.now(),\n      ...('sseOptions' in request && {\n        sse: request.sseOptions\n      })\n    };\n    onPopupUpdate({\n      type: 'dappConnect',\n      promiseId,\n      accountId,\n      dapp,\n      permissions: {\n        address: true,\n        proof: !!proof\n      },\n      proof\n    });\n    const promiseResult = await promise;\n    accountId = promiseResult.accountId;\n    await (0,_methods_dapps__WEBPACK_IMPORTED_MODULE_20__.addDapp)(accountId, dapp);\n    const result = await reconnect(request, id);\n    if (result.event === 'connect' && proof) {\n      const address = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_14__.fetchStoredAddress)(accountId);\n      const {\n        password,\n        signature\n      } = promiseResult;\n      let proofReplyItem;\n      if (password) {\n        proofReplyItem = await signTonProof(accountId, password, address, proof);\n      } else {\n        proofReplyItem = buildTonProofReplyItem(proof, signature);\n      }\n      result.payload.items.push(proofReplyItem);\n    }\n    return result;\n  } catch (err) {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_7__.logDebugError)('tonConnect:connect', err);\n    (0,_util_safeExec__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(() => {\n      onPopupUpdate({\n        type: 'dappCloseLoading'\n      });\n    });\n    return formatConnectError(id, err);\n  }\n}\nasync function reconnect(request, id) {\n  try {\n    const {\n      origin,\n      accountId\n    } = await validateRequest(request);\n    (0,_methods_dapps__WEBPACK_IMPORTED_MODULE_20__.activateDapp)(accountId, origin);\n    const currentDapp = await (0,_methods_dapps__WEBPACK_IMPORTED_MODULE_20__.getDapp)(accountId, origin);\n    if (!currentDapp) {\n      throw new _errors__WEBPACK_IMPORTED_MODULE_22__.UnknownAppError();\n    }\n    await (0,_methods_dapps__WEBPACK_IMPORTED_MODULE_20__.updateDapp)(accountId, origin, dapp => ({\n      ...dapp,\n      connectedAt: Date.now()\n    }));\n    const address = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_14__.fetchStoredAddress)(accountId);\n    const items = [await buildTonAddressReplyItem(accountId, address)];\n    return {\n      event: 'connect',\n      id,\n      payload: {\n        items\n      }\n    };\n  } catch (e) {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_7__.logDebugError)('tonConnect:reconnect', e);\n    return formatConnectError(id, e);\n  }\n}\nasync function disconnect(request, message) {\n  try {\n    const {\n      origin,\n      accountId\n    } = await validateRequest(request);\n    await (0,_methods_dapps__WEBPACK_IMPORTED_MODULE_20__.deleteDapp)(accountId, origin, true);\n    (0,_methods_dapps__WEBPACK_IMPORTED_MODULE_20__.deactivateAccountDapp)(accountId);\n  } catch (err) {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_7__.logDebugError)('tonConnect:disconnect', err);\n  }\n  return {\n    id: message.id,\n    result: {}\n  };\n}\nasync function sendTransaction(request, message) {\n  try {\n    const {\n      origin,\n      accountId\n    } = await validateRequest(request);\n    const txPayload = JSON.parse(message.params[0]);\n    if (txPayload.messages.length > 4) {\n      throw new _errors__WEBPACK_IMPORTED_MODULE_22__.BadRequestError('Payload contains more than 4 messages, which exceeds limit');\n    }\n    const messages = txPayload.messages;\n    let validUntil = txPayload.valid_until;\n    if (validUntil && validUntil > 10 ** 10) {\n      // If milliseconds were passed instead of seconds\n      validUntil = Math.round(validUntil / 1000);\n    }\n    const {\n      network\n    } = (0,_util_account__WEBPACK_IMPORTED_MODULE_6__.parseAccountId)(accountId);\n    const account = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_14__.fetchStoredAccount)(accountId);\n    const isLedger = !!account.ledger;\n    await openExtensionPopup(true);\n    onPopupUpdate({\n      type: 'dappLoading',\n      connectionType: 'sendTransaction'\n    });\n    const {\n      preparedMessages,\n      checkResult\n    } = await checkTransactionMessages(accountId, messages, network);\n    const dapp = (await (0,_methods_dapps__WEBPACK_IMPORTED_MODULE_20__.getDappsByOrigin)(accountId))[origin];\n    const transactionsForRequest = await prepareTransactionForRequest(network, messages, isLedger);\n    const {\n      promiseId,\n      promise\n    } = (0,_common_dappPromises__WEBPACK_IMPORTED_MODULE_15__.createDappPromise)();\n    onPopupUpdate({\n      type: 'dappSendTransactions',\n      promiseId,\n      accountId,\n      dapp,\n      transactions: transactionsForRequest,\n      fee: checkResult.fee\n    });\n\n    // eslint-disable-next-line prefer-const\n    const response = await promise;\n    if (validUntil && validUntil < Date.now() / 1000) {\n      throw new _errors__WEBPACK_IMPORTED_MODULE_22__.BadRequestError('The confirmation timeout has expired');\n    }\n    let boc;\n    let successNumber;\n    let error;\n    if (isLedger) {\n      const signedTransfers = response;\n      const submitResult = await ton.sendSignedMessages(accountId, signedTransfers);\n      boc = submitResult.externalMessage.toBoc().toString('base64');\n      successNumber = submitResult.successNumber;\n      if (successNumber > 0) {\n        if (successNumber < messages.length) {\n          onPopupUpdate({\n            type: 'showError',\n            error: _types__WEBPACK_IMPORTED_MODULE_3__.ApiTransactionError.PartialTransactionFailure\n          });\n        }\n      } else {\n        error = 'Failed transfers';\n      }\n    } else {\n      const password = response;\n      const submitResult = await ton.submitMultiTransfer(accountId, password, preparedMessages, validUntil);\n      if ('error' in submitResult) {\n        error = submitResult.error;\n      } else {\n        boc = submitResult.boc;\n        successNumber = messages.length;\n      }\n    }\n    if (error) {\n      throw new _errors__WEBPACK_IMPORTED_MODULE_22__.UnknownError(error);\n    }\n    const fromAddress = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_14__.fetchStoredAddress)(accountId);\n    const successTransactions = transactionsForRequest.slice(0, successNumber);\n    successTransactions.forEach(_ref3 => {\n      let {\n        amount,\n        normalizedAddress,\n        payload\n      } = _ref3;\n      const comment = (payload === null || payload === void 0 ? void 0 : payload.type) === 'comment' ? payload.comment : undefined;\n      (0,_methods__WEBPACK_IMPORTED_MODULE_21__.createLocalTransaction)(accountId, {\n        amount,\n        fromAddress,\n        toAddress: normalizedAddress,\n        comment,\n        fee: checkResult.fee,\n        slug: _config__WEBPACK_IMPORTED_MODULE_5__.TON_TOKEN_SLUG\n      });\n    });\n    return {\n      result: boc,\n      id: message.id\n    };\n  } catch (err) {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_7__.logDebugError)('tonConnect:sendTransaction', err);\n    (0,_util_safeExec__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(() => {\n      onPopupUpdate({\n        type: 'dappCloseLoading'\n      });\n    });\n    let code = _types__WEBPACK_IMPORTED_MODULE_4__.SEND_TRANSACTION_ERROR_CODES.UNKNOWN_ERROR;\n    let errorMessage = 'Unhandled error';\n    let displayError;\n    if (err instanceof _errors__WEBPACK_IMPORTED_MODULE_18__.ApiUserRejectsError) {\n      code = _types__WEBPACK_IMPORTED_MODULE_4__.SEND_TRANSACTION_ERROR_CODES.USER_REJECTS_ERROR;\n      errorMessage = err.message;\n    } else if (err instanceof _errors__WEBPACK_IMPORTED_MODULE_22__.TonConnectError) {\n      code = err.code;\n      errorMessage = err.message;\n      displayError = err.displayError;\n    } else if (err instanceof _errors__WEBPACK_IMPORTED_MODULE_18__.ApiServerError) {\n      displayError = err.displayError;\n    } else {\n      displayError = _types__WEBPACK_IMPORTED_MODULE_3__.ApiCommonError.Unexpected;\n    }\n    if (onPopupUpdate && (0,_common_helpers__WEBPACK_IMPORTED_MODULE_16__.isUpdaterAlive)(onPopupUpdate) && displayError) {\n      onPopupUpdate({\n        type: 'showError',\n        error: displayError\n      });\n    }\n    return {\n      error: {\n        code,\n        message: errorMessage\n      },\n      id: message.id\n    };\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction signData(request, message) {\n  return {\n    error: {\n      code: _types__WEBPACK_IMPORTED_MODULE_4__.SIGN_DATA_ERROR_CODES.METHOD_NOT_SUPPORTED,\n      message: 'Method not supported'\n    },\n    id: message.id\n  };\n}\nasync function checkTransactionMessages(accountId, messages, network) {\n  const preparedMessages = messages.map(msg => {\n    const {\n      address,\n      amount,\n      payload,\n      stateInit\n    } = msg;\n    return {\n      toAddress: (0,_blockchains_ton_util_tonCore__WEBPACK_IMPORTED_MODULE_13__.getIsRawAddress)(address) ? (0,_blockchains_ton_util_tonCore__WEBPACK_IMPORTED_MODULE_13__.toBase64Address)(address, true, network) : address,\n      amount: BigInt(amount),\n      payload: payload ? _ton_core__WEBPACK_IMPORTED_MODULE_0__.Cell.fromBase64(payload) : undefined,\n      stateInit: stateInit ? _ton_core__WEBPACK_IMPORTED_MODULE_0__.Cell.fromBase64(stateInit) : undefined\n    };\n  });\n  const checkResult = await ton.checkMultiTransactionDraft(accountId, preparedMessages);\n  if ('error' in checkResult) {\n    onPopupUpdate({\n      type: 'showError',\n      error: checkResult.error\n    });\n    throw new _errors__WEBPACK_IMPORTED_MODULE_22__.BadRequestError(checkResult.error);\n  }\n  return {\n    preparedMessages,\n    checkResult\n  };\n}\nfunction prepareTransactionForRequest(network, messages, isLedger) {\n  return Promise.all(messages.map(async _ref4 => {\n    let {\n      address,\n      amount,\n      payload: rawPayload,\n      stateInit\n    } = _ref4;\n    const toAddress = (0,_blockchains_ton_util_tonCore__WEBPACK_IMPORTED_MODULE_13__.getIsRawAddress)(address) ? (0,_blockchains_ton_util_tonCore__WEBPACK_IMPORTED_MODULE_13__.toBase64Address)(address, true, network) : address;\n    // Fix address format for `waitTxComplete` to work properly\n    const normalizedAddress = (0,_blockchains_ton_util_tonCore__WEBPACK_IMPORTED_MODULE_13__.toBase64Address)(address, undefined, network);\n    const payload = rawPayload ? await (0,_blockchains_ton__WEBPACK_IMPORTED_MODULE_11__.parsePayloadBase64)(network, toAddress, rawPayload) : undefined;\n    return {\n      toAddress,\n      amount: BigInt(amount),\n      rawPayload,\n      payload,\n      stateInit,\n      normalizedAddress\n    };\n  }));\n}\nasync function deactivate(request) {\n  try {\n    const {\n      origin\n    } = await validateRequest(request, true);\n    (0,_methods_dapps__WEBPACK_IMPORTED_MODULE_20__.deactivateDapp)(origin);\n  } catch (err) {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_7__.logDebugError)('tonConnect:deactivate', err);\n  }\n}\nfunction formatConnectError(id, error) {\n  let code = _types__WEBPACK_IMPORTED_MODULE_4__.CONNECT_EVENT_ERROR_CODES.UNKNOWN_ERROR;\n  let message = 'Unhandled error';\n  if (error instanceof _errors__WEBPACK_IMPORTED_MODULE_18__.ApiUserRejectsError) {\n    code = _types__WEBPACK_IMPORTED_MODULE_4__.CONNECT_EVENT_ERROR_CODES.USER_REJECTS_ERROR;\n    message = error.message;\n  } else if (error instanceof _errors__WEBPACK_IMPORTED_MODULE_22__.TonConnectError) {\n    code = error.code;\n    message = error.message;\n  }\n  return {\n    id,\n    event: 'connect_error',\n    payload: {\n      code,\n      message\n    }\n  };\n}\nasync function buildTonAddressReplyItem(accountId, address) {\n  const {\n    network\n  } = (0,_util_account__WEBPACK_IMPORTED_MODULE_6__.parseAccountId)(accountId);\n  const [stateInit, publicKey] = await Promise.all([ton.getWalletStateInit(accountId), (0,_common_accounts__WEBPACK_IMPORTED_MODULE_14__.fetchStoredPublicKey)(accountId)]);\n  return {\n    name: 'ton_addr',\n    address: (0,_blockchains_ton_util_tonCore__WEBPACK_IMPORTED_MODULE_13__.toRawAddress)(address),\n    network: network === 'mainnet' ? _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_1__.CHAIN.MAINNET : _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_1__.CHAIN.TESTNET,\n    publicKey,\n    walletStateInit: stateInit.toBoc({\n      idx: true,\n      crc32: true\n    }).toString('base64')\n  };\n}\nasync function signTonProof(accountId, password, walletAddress, proof) {\n  const keyPair = await (0,_blockchains_ton_auth__WEBPACK_IMPORTED_MODULE_12__.fetchKeyPair)(accountId, password);\n  const {\n    timestamp,\n    domain,\n    payload\n  } = proof;\n  const timestampBuffer = Buffer.allocUnsafe(8);\n  timestampBuffer.writeBigInt64LE(BigInt(timestamp));\n  const domainBuffer = Buffer.from(domain);\n  const domainLengthBuffer = Buffer.allocUnsafe(4);\n  domainLengthBuffer.writeInt32LE(domainBuffer.byteLength);\n  const address = _ton_core__WEBPACK_IMPORTED_MODULE_0__.Address.parse(walletAddress);\n  const addressWorkchainBuffer = Buffer.allocUnsafe(4);\n  addressWorkchainBuffer.writeInt32BE(address.workChain);\n  const addressBuffer = Buffer.concat([addressWorkchainBuffer, address.hash]);\n  const messageBuffer = Buffer.concat([Buffer.from('ton-proof-item-v2/', 'utf8'), addressBuffer, domainLengthBuffer, domainBuffer, timestampBuffer, Buffer.from(payload)]);\n  const bufferToSign = Buffer.concat([Buffer.from('ffff', 'hex'), Buffer.from('ton-connect', 'utf8'), Buffer.from(await (0,_common_utils__WEBPACK_IMPORTED_MODULE_17__.sha256)(messageBuffer))]);\n  const signature = tweetnacl__WEBPACK_IMPORTED_MODULE_2___default().sign.detached(Buffer.from(await (0,_common_utils__WEBPACK_IMPORTED_MODULE_17__.sha256)(bufferToSign)), keyPair.secretKey);\n  return buildTonProofReplyItem(proof, (0,_common_utils__WEBPACK_IMPORTED_MODULE_17__.bytesToBase64)(signature));\n}\nfunction buildTonProofReplyItem(proof, signature) {\n  const {\n    timestamp,\n    domain,\n    payload\n  } = proof;\n  const domainBuffer = Buffer.from(domain);\n  return {\n    name: 'ton_proof',\n    proof: {\n      timestamp,\n      domain: {\n        lengthBytes: domainBuffer.byteLength,\n        value: domainBuffer.toString('utf8')\n      },\n      signature,\n      payload\n    }\n  };\n}\nasync function fetchDappMetadata(manifestUrl, origin) {\n  try {\n    const data = await (0,_util_metadata__WEBPACK_IMPORTED_MODULE_8__.fetchJsonMetadata)(manifestUrl);\n    const {\n      url,\n      name,\n      iconUrl\n    } = await data;\n    if (!(0,_utils__WEBPACK_IMPORTED_MODULE_23__.isValidUrl)(url) || !(0,_utils__WEBPACK_IMPORTED_MODULE_23__.isValidString)(name) || !(0,_utils__WEBPACK_IMPORTED_MODULE_23__.isValidUrl)(iconUrl)) {\n      throw new Error('Invalid data');\n    }\n    return {\n      origin: origin !== null && origin !== void 0 ? origin : new URL(url).origin,\n      url,\n      name,\n      iconUrl,\n      manifestUrl\n    };\n  } catch (err) {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_7__.logDebugError)('fetchDapp', err);\n    throw new _errors__WEBPACK_IMPORTED_MODULE_22__.ManifestContentError();\n  }\n}\nasync function validateRequest(request) {\n  let skipConnection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const {\n    origin\n  } = request;\n  if (!origin) {\n    throw new _errors__WEBPACK_IMPORTED_MODULE_22__.BadRequestError('Invalid origin');\n  }\n  let accountId = '';\n  if (request.accountId) {\n    accountId = request.accountId;\n  } else if (!skipConnection) {\n    const {\n      network\n    } = (0,_util_account__WEBPACK_IMPORTED_MODULE_6__.parseAccountId)(await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_14__.getCurrentAccountIdOrFail)());\n    const lastAccountId = await (0,_methods_dapps__WEBPACK_IMPORTED_MODULE_20__.findLastConnectedAccount)(network, origin);\n    if (!lastAccountId) {\n      throw new _errors__WEBPACK_IMPORTED_MODULE_22__.BadRequestError('The connection is outdated, try relogin');\n    }\n    accountId = lastAccountId;\n  }\n  return {\n    origin,\n    accountId\n  };\n}\nasync function openExtensionPopup(force) {\n  if (!_config__WEBPACK_IMPORTED_MODULE_5__.IS_EXTENSION || !force && onPopupUpdate && (0,_common_helpers__WEBPACK_IMPORTED_MODULE_16__.isUpdaterAlive)(onPopupUpdate)) {\n    return false;\n  }\n  await (0,_hooks__WEBPACK_IMPORTED_MODULE_19__.callHook)('onWindowNeeded');\n  await initPromise;\n  return true;\n}\nasync function getCurrentAccountOrFail() {\n  const accountId = await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_14__.getCurrentAccountId)();\n  if (!accountId) {\n    throw new _errors__WEBPACK_IMPORTED_MODULE_22__.BadRequestError('The user is not authorized in the wallet');\n  }\n  return accountId;\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/tonConnect/index.ts?");

/***/ }),

/***/ "./src/api/tonConnect/sse.ts":
/*!***********************************!*\
  !*** ./src/api/tonConnect/sse.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"initSse\": () => (/* binding */ initSse),\n/* harmony export */   \"resetupSseConnection\": () => (/* binding */ resetupSseConnection),\n/* harmony export */   \"sendSseDisconnect\": () => (/* binding */ sendSseDisconnect),\n/* harmony export */   \"startSseConnection\": () => (/* binding */ startSseConnection)\n/* harmony export */ });\n/* harmony import */ var tweetnacl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tweetnacl */ \"./node_modules/tweetnacl/nacl-fast.js\");\n/* harmony import */ var tweetnacl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tweetnacl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _util_account__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/account */ \"./src/util/account.ts\");\n/* harmony import */ var _util_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/fetch */ \"./src/util/fetch.ts\");\n/* harmony import */ var _util_iteratees__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/iteratees */ \"./src/util/iteratees.ts\");\n/* harmony import */ var _util_logs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/logs */ \"./src/util/logs.ts\");\n/* harmony import */ var _util_safeExec__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/safeExec */ \"./src/util/safeExec.ts\");\n/* harmony import */ var _common_accounts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/accounts */ \"./src/api/common/accounts.ts\");\n/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../common/utils */ \"./src/api/common/utils.ts\");\n/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../db */ \"./src/api/db.ts\");\n/* harmony import */ var _methods_dapps__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../methods/dapps */ \"./src/api/methods/dapps.ts\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./index */ \"./src/api/tonConnect/index.ts\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\n\n\n\n\n\n\n\n\n\nconst BRIDGE_URL = 'https://tonconnectbridge.mytonwallet.org/bridge';\nconst TTL_SEC = 300;\nconst NONCE_SIZE = 24;\nconst MAX_CONFIRM_DURATION = 60 * 1000;\nlet sseEventSource;\nlet sseDapps = [];\nlet delayedReturnParams;\nlet onUpdate;\nfunction initSse(_onUpdate) {\n  onUpdate = _onUpdate;\n}\nasync function startSseConnection(url, deviceInfo) {\n  const {\n    searchParams: params,\n    origin\n  } = new URL(url);\n  const ret = params.get('ret') || 'back';\n  const version = Number(params.get('v'));\n  const appClientId = params.get('id');\n  // `back` strategy cannot be implemented\n  const shouldOpenUrl = ret !== 'back' && ret !== 'none';\n  if (!params.get('r')) {\n    if (shouldOpenUrl) {\n      delayedReturnParams = {\n        validUntil: Date.now() + MAX_CONFIRM_DURATION,\n        url: ret\n      };\n    }\n    return undefined;\n  }\n  if (await _db__WEBPACK_IMPORTED_MODULE_8__.apiDb.sseConnections.get(appClientId)) {\n    // Avoid re-processing link\n    return ret !== null && ret !== void 0 ? ret : undefined;\n  }\n  const connectRequest = JSON.parse(params.get('r'));\n  (0,_util_logs__WEBPACK_IMPORTED_MODULE_4__.logDebug)('SSE Start connection:', {\n    version,\n    appClientId,\n    connectRequest,\n    ret,\n    origin\n  });\n  const {\n    secretKey: secretKeyArray,\n    publicKey: publicKeyArray\n  } = tweetnacl__WEBPACK_IMPORTED_MODULE_0___default().box.keyPair();\n  const secretKey = (0,_common_utils__WEBPACK_IMPORTED_MODULE_7__.bytesToHex)(secretKeyArray);\n  const clientId = (0,_common_utils__WEBPACK_IMPORTED_MODULE_7__.bytesToHex)(publicKeyArray);\n  const lastOutputId = 0;\n  const request = {\n    origin,\n    sseOptions: {\n      clientId,\n      appClientId,\n      secretKey,\n      lastOutputId\n    }\n  };\n  await (0,_common_accounts__WEBPACK_IMPORTED_MODULE_6__.waitLogin)();\n  const result = await _index__WEBPACK_IMPORTED_MODULE_10__.connect(request, connectRequest, lastOutputId);\n  if (result.event === 'connect') {\n    result.payload.device = deviceInfo;\n  }\n  await sendMessage(result, secretKey, clientId, appClientId);\n  await _db__WEBPACK_IMPORTED_MODULE_8__.apiDb.sseConnections.put({\n    clientId: appClientId\n  });\n  if (result.event !== 'connect_error') {\n    await resetupSseConnection();\n  }\n  if (!shouldOpenUrl) {\n    return undefined;\n  }\n  return ret;\n}\nasync function resetupSseConnection() {\n  closeEventSource();\n  const [lastEventId, dappsState, network] = await Promise.all([(0,_methods_dapps__WEBPACK_IMPORTED_MODULE_9__.getSseLastEventId)(), (0,_methods_dapps__WEBPACK_IMPORTED_MODULE_9__.getDappsState)(), (0,_common_accounts__WEBPACK_IMPORTED_MODULE_6__.getCurrentNetwork)()]);\n  if (!dappsState || !network) {\n    return;\n  }\n  sseDapps = Object.entries(dappsState).reduce((result, _ref) => {\n    let [accountId, dapps] = _ref;\n    if ((0,_util_account__WEBPACK_IMPORTED_MODULE_1__.parseAccountId)(accountId).network === network) {\n      for (const dapp of Object.values(dapps)) {\n        result.push({\n          ...dapp.sse,\n          accountId,\n          origin: dapp.origin\n        });\n      }\n    }\n    return result;\n  }, []);\n  const clientIds = (0,_util_iteratees__WEBPACK_IMPORTED_MODULE_3__.extractKey)(sseDapps, 'clientId');\n  if (!clientIds.length) {\n    return;\n  }\n  if (sseEventSource) {\n    (0,_util_safeExec__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(() => {\n      sseEventSource.close();\n    });\n    sseEventSource = undefined;\n  }\n  sseEventSource = openEventSource(clientIds, lastEventId);\n  sseEventSource.onopen = () => {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_4__.logDebug)('EventSource opened');\n  };\n  sseEventSource.onerror = e => {\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_4__.logDebugError)('EventSource', e.type);\n  };\n  sseEventSource.onmessage = async event => {\n    const {\n      from,\n      message: encryptedMessage\n    } = JSON.parse(event.data);\n    const sseDapp = sseDapps.find(_ref2 => {\n      let {\n        appClientId\n      } = _ref2;\n      return appClientId === from;\n    });\n    if (!sseDapp) {\n      (0,_util_logs__WEBPACK_IMPORTED_MODULE_4__.logDebug)(`Dapp with clientId ${from} not found`);\n      return;\n    }\n    const {\n      accountId,\n      clientId,\n      appClientId,\n      secretKey,\n      origin\n    } = sseDapp;\n    const message = decryptMessage(encryptedMessage, appClientId, secretKey);\n    (0,_util_logs__WEBPACK_IMPORTED_MODULE_4__.logDebug)('SSE Event:', message);\n    await (0,_methods_dapps__WEBPACK_IMPORTED_MODULE_9__.setSseLastEventId)(event.lastEventId);\n\n    // @ts-ignore\n    const result = await _index__WEBPACK_IMPORTED_MODULE_10__[message.method]({\n      origin,\n      accountId\n    }, message);\n    await sendMessage(result, secretKey, clientId, appClientId);\n    if (delayedReturnParams) {\n      const {\n        validUntil,\n        url\n      } = delayedReturnParams;\n      if (validUntil > Date.now()) {\n        onUpdate({\n          type: 'openUrl',\n          url\n        });\n      }\n      delayedReturnParams = undefined;\n    }\n  };\n}\nasync function sendSseDisconnect(accountId, origin) {\n  const sseDapp = sseDapps.find(dapp => dapp.origin === origin && dapp.accountId === accountId);\n  if (!sseDapp) return;\n  const {\n    secretKey,\n    clientId,\n    appClientId\n  } = sseDapp;\n  const lastOutputId = sseDapp.lastOutputId + 1;\n  const response = {\n    event: 'disconnect',\n    id: lastOutputId,\n    payload: {}\n  };\n  await sendMessage(response, secretKey, clientId, appClientId);\n}\nfunction sendMessage(message, secretKey, clientId, toId, topic) {\n  const buffer = Buffer.from(JSON.stringify(message));\n  const encryptedMessage = encryptMessage(buffer, toId, secretKey);\n  return sendRawMessage(encryptedMessage, clientId, toId, topic);\n}\nasync function sendRawMessage(body, clientId, toId, topic) {\n  const url = new URL(`${BRIDGE_URL}/message`);\n  url.searchParams.set('client_id', clientId);\n  url.searchParams.set('to', toId);\n  url.searchParams.set('ttl', TTL_SEC.toString());\n  if (topic) {\n    url.searchParams.set('topic', topic);\n  }\n  const response = await fetch(url, {\n    method: 'POST',\n    body\n  });\n  (0,_util_fetch__WEBPACK_IMPORTED_MODULE_2__.handleFetchErrors)(response);\n}\nfunction closeEventSource() {\n  if (!sseEventSource) return;\n  sseEventSource.close();\n  sseEventSource = undefined;\n}\nfunction openEventSource(clientIds, lastEventId) {\n  const url = new URL(`${BRIDGE_URL}/events`);\n  url.searchParams.set('client_id', clientIds.join(','));\n  if (lastEventId) {\n    url.searchParams.set('last_event_id', lastEventId);\n  }\n  return new EventSource(url);\n}\nfunction encryptMessage(message, publicKey, secretKey) {\n  const nonce = (0,tweetnacl__WEBPACK_IMPORTED_MODULE_0__.randomBytes)(NONCE_SIZE);\n  const encrypted = tweetnacl__WEBPACK_IMPORTED_MODULE_0___default().box(message, nonce, Buffer.from(publicKey, 'hex'), Buffer.from(secretKey, 'hex'));\n  return Buffer.concat([nonce, encrypted]).toString('base64');\n}\nfunction decryptMessage(message, publicKey, secretKey) {\n  const fullBuffer = Buffer.from(message, 'base64');\n  const nonce = fullBuffer.subarray(0, NONCE_SIZE);\n  const encrypted = fullBuffer.subarray(NONCE_SIZE);\n  const decrypted = tweetnacl__WEBPACK_IMPORTED_MODULE_0___default().box.open(encrypted, nonce, Buffer.from(publicKey, 'hex'), Buffer.from(secretKey, 'hex'));\n  const jsonText = new TextDecoder('utf-8').decode(decrypted);\n  return JSON.parse(jsonText);\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/tonConnect/sse.ts?");

/***/ }),

/***/ "./src/api/tonConnect/types/index.ts":
/*!*******************************************!*\
  !*** ./src/api/tonConnect/types/index.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CONNECT_EVENT_ERROR_CODES\": () => (/* binding */ CONNECT_EVENT_ERROR_CODES),\n/* harmony export */   \"SEND_TRANSACTION_ERROR_CODES\": () => (/* binding */ SEND_TRANSACTION_ERROR_CODES),\n/* harmony export */   \"SIGN_DATA_ERROR_CODES\": () => (/* binding */ SIGN_DATA_ERROR_CODES)\n/* harmony export */ });\n// eslint-disable-next-line @typescript-eslint/naming-convention\nlet CONNECT_EVENT_ERROR_CODES = /*#__PURE__*/function (CONNECT_EVENT_ERROR_CODES) {\n  CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"UNKNOWN_ERROR\"] = 0] = \"UNKNOWN_ERROR\";\n  CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"BAD_REQUEST_ERROR\"] = 1] = \"BAD_REQUEST_ERROR\";\n  CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"MANIFEST_NOT_FOUND_ERROR\"] = 2] = \"MANIFEST_NOT_FOUND_ERROR\";\n  CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"MANIFEST_CONTENT_ERROR\"] = 3] = \"MANIFEST_CONTENT_ERROR\";\n  CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"UNKNOWN_APP_ERROR\"] = 100] = \"UNKNOWN_APP_ERROR\";\n  CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"USER_REJECTS_ERROR\"] = 300] = \"USER_REJECTS_ERROR\";\n  CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES[\"METHOD_NOT_SUPPORTED\"] = 400] = \"METHOD_NOT_SUPPORTED\";\n  return CONNECT_EVENT_ERROR_CODES;\n}({});\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nlet SEND_TRANSACTION_ERROR_CODES = /*#__PURE__*/function (SEND_TRANSACTION_ERROR_CODES) {\n  SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES[\"UNKNOWN_ERROR\"] = 0] = \"UNKNOWN_ERROR\";\n  SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES[\"BAD_REQUEST_ERROR\"] = 1] = \"BAD_REQUEST_ERROR\";\n  SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES[\"UNKNOWN_APP_ERROR\"] = 100] = \"UNKNOWN_APP_ERROR\";\n  SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES[\"USER_REJECTS_ERROR\"] = 300] = \"USER_REJECTS_ERROR\";\n  SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES[\"METHOD_NOT_SUPPORTED\"] = 400] = \"METHOD_NOT_SUPPORTED\";\n  return SEND_TRANSACTION_ERROR_CODES;\n}({});\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nlet SIGN_DATA_ERROR_CODES = /*#__PURE__*/function (SIGN_DATA_ERROR_CODES) {\n  SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES[\"UNKNOWN_ERROR\"] = 0] = \"UNKNOWN_ERROR\";\n  SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES[\"BAD_REQUEST_ERROR\"] = 1] = \"BAD_REQUEST_ERROR\";\n  SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES[\"UNKNOWN_APP_ERROR\"] = 100] = \"UNKNOWN_APP_ERROR\";\n  SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES[\"USER_REJECTS_ERROR\"] = 300] = \"USER_REJECTS_ERROR\";\n  SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES[\"METHOD_NOT_SUPPORTED\"] = 400] = \"METHOD_NOT_SUPPORTED\";\n  return SIGN_DATA_ERROR_CODES;\n}({});\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/tonConnect/types/index.ts?");

/***/ }),

/***/ "./src/api/tonConnect/utils.ts":
/*!*************************************!*\
  !*** ./src/api/tonConnect/utils.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isValidString\": () => (/* binding */ isValidString),\n/* harmony export */   \"isValidUrl\": () => (/* binding */ isValidUrl)\n/* harmony export */ });\nfunction isValidString(value) {\n  let maxLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n  return typeof value === 'string' && value.length <= maxLength;\n}\nfunction isValidUrl(url) {\n  const isString = isValidString(url, 150);\n  if (!isString) return false;\n  try {\n    // eslint-disable-next-line no-new\n    new URL(url);\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/tonConnect/utils.ts?");

/***/ }),

/***/ "./src/api/types/activity.ts":
/*!***********************************!*\
  !*** ./src/api/types/activity.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/types/activity.ts?");

/***/ }),

/***/ "./src/api/types/backend.ts":
/*!**********************************!*\
  !*** ./src/api/types/backend.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/types/backend.ts?");

/***/ }),

/***/ "./src/api/types/errors.ts":
/*!*********************************!*\
  !*** ./src/api/types/errors.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ApiCommonError\": () => (/* binding */ ApiCommonError),\n/* harmony export */   \"ApiTransactionDraftError\": () => (/* binding */ ApiTransactionDraftError),\n/* harmony export */   \"ApiTransactionError\": () => (/* binding */ ApiTransactionError)\n/* harmony export */ });\nlet ApiCommonError = /*#__PURE__*/function (ApiCommonError) {\n  ApiCommonError[\"Unexpected\"] = \"Unexpected\";\n  ApiCommonError[\"ServerError\"] = \"ServerError\";\n  ApiCommonError[\"DebugError\"] = \"DebugError\";\n  return ApiCommonError;\n}({});\nlet ApiTransactionDraftError = /*#__PURE__*/function (ApiTransactionDraftError) {\n  ApiTransactionDraftError[\"InvalidAmount\"] = \"InvalidAmount\";\n  ApiTransactionDraftError[\"InvalidToAddress\"] = \"InvalidToAddress\";\n  ApiTransactionDraftError[\"InsufficientBalance\"] = \"InsufficientBalance\";\n  ApiTransactionDraftError[\"DomainNotResolved\"] = \"DomainNotResolved\";\n  ApiTransactionDraftError[\"WalletNotInitialized\"] = \"WalletNotInitialized\";\n  ApiTransactionDraftError[\"UnsupportedHardwareOperation\"] = \"UnsupportedHardwareOperation\";\n  ApiTransactionDraftError[\"UnsupportedHardwareContract\"] = \"UnsupportedHardwareContract\";\n  ApiTransactionDraftError[\"EncryptedDataNotSupported\"] = \"EncryptedDataNotSupported\";\n  ApiTransactionDraftError[\"NonAsciiCommentForHardwareOperation\"] = \"NonAsciiCommentForHardwareOperation\";\n  ApiTransactionDraftError[\"TooLongCommentForHardwareOperation\"] = \"TooLongCommentForHardwareOperation\";\n  ApiTransactionDraftError[\"InvalidAddressFormat\"] = \"InvalidAddressFormat\";\n  return ApiTransactionDraftError;\n}({});\nlet ApiTransactionError = /*#__PURE__*/function (ApiTransactionError) {\n  ApiTransactionError[\"PartialTransactionFailure\"] = \"PartialTransactionFailure\";\n  ApiTransactionError[\"IncorrectDeviceTime\"] = \"IncorrectDeviceTime\";\n  ApiTransactionError[\"InsufficientBalance\"] = \"InsufficientBalance\";\n  ApiTransactionError[\"UnsuccesfulTransfer\"] = \"UnsuccesfulTransfer\";\n  ApiTransactionError[\"UnsupportedHardwareContract\"] = \"UnsupportedHardwareContract\";\n  ApiTransactionError[\"UnsupportedHardwarePayload\"] = \"UnsupportedHardwarePayload\";\n  ApiTransactionError[\"NonAsciiCommentForHardwareOperation\"] = \"NonAsciiCommentForHardwareOperation\";\n  ApiTransactionError[\"TooLongCommentForHardwareOperation\"] = \"TooLongCommentForHardwareOperation\";\n  ApiTransactionError[\"UnsupportedHardwareNftOperation\"] = \"UnsupportedHardwareNftOperation\";\n  return ApiTransactionError;\n}({});\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/types/errors.ts?");

/***/ }),

/***/ "./src/api/types/index.ts":
/*!********************************!*\
  !*** ./src/api/types/index.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ApiCommonError\": () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_3__.ApiCommonError),\n/* harmony export */   \"ApiLiquidUnstakeMode\": () => (/* reexport safe */ _misc__WEBPACK_IMPORTED_MODULE_1__.ApiLiquidUnstakeMode),\n/* harmony export */   \"ApiTransactionDraftError\": () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_3__.ApiTransactionDraftError),\n/* harmony export */   \"ApiTransactionError\": () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_3__.ApiTransactionError),\n/* harmony export */   \"TRANSFER_TIMEOUT_SEC\": () => (/* reexport safe */ _misc__WEBPACK_IMPORTED_MODULE_1__.TRANSFER_TIMEOUT_SEC),\n/* harmony export */   \"WORKCHAIN\": () => (/* reexport safe */ _misc__WEBPACK_IMPORTED_MODULE_1__.WORKCHAIN),\n/* harmony export */   \"Workchain\": () => (/* reexport safe */ _misc__WEBPACK_IMPORTED_MODULE_1__.Workchain)\n/* harmony export */ });\n/* harmony import */ var _updates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./updates */ \"./src/api/types/updates.ts\");\n/* harmony import */ var _misc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./misc */ \"./src/api/types/misc.ts\");\n/* harmony import */ var _payload__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./payload */ \"./src/api/types/payload.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors */ \"./src/api/types/errors.ts\");\n/* harmony import */ var _backend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./backend */ \"./src/api/types/backend.ts\");\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./storage */ \"./src/api/types/storage.ts\");\n/* harmony import */ var _activity__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./activity */ \"./src/api/types/activity.ts\");\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/types/index.ts?");

/***/ }),

/***/ "./src/api/types/misc.ts":
/*!*******************************!*\
  !*** ./src/api/types/misc.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ApiLiquidUnstakeMode\": () => (/* binding */ ApiLiquidUnstakeMode),\n/* harmony export */   \"TRANSFER_TIMEOUT_SEC\": () => (/* binding */ TRANSFER_TIMEOUT_SEC),\n/* harmony export */   \"WORKCHAIN\": () => (/* binding */ WORKCHAIN),\n/* harmony export */   \"Workchain\": () => (/* binding */ Workchain)\n/* harmony export */ });\nlet Workchain = /*#__PURE__*/function (Workchain) {\n  Workchain[Workchain[\"MasterChain\"] = -1] = \"MasterChain\";\n  Workchain[Workchain[\"BaseChain\"] = 0] = \"BaseChain\";\n  return Workchain;\n}({});\nconst WORKCHAIN = Workchain.BaseChain;\nconst TRANSFER_TIMEOUT_SEC = 60; // 1 min.\n\nlet ApiLiquidUnstakeMode = /*#__PURE__*/function (ApiLiquidUnstakeMode) {\n  ApiLiquidUnstakeMode[ApiLiquidUnstakeMode[\"Default\"] = 0] = \"Default\";\n  ApiLiquidUnstakeMode[ApiLiquidUnstakeMode[\"Instant\"] = 1] = \"Instant\";\n  ApiLiquidUnstakeMode[ApiLiquidUnstakeMode[\"BestRate\"] = 2] = \"BestRate\";\n  return ApiLiquidUnstakeMode;\n}({});\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/types/misc.ts?");

/***/ }),

/***/ "./src/api/types/payload.ts":
/*!**********************************!*\
  !*** ./src/api/types/payload.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/types/payload.ts?");

/***/ }),

/***/ "./src/api/types/storage.ts":
/*!**********************************!*\
  !*** ./src/api/types/storage.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/types/storage.ts?");

/***/ }),

/***/ "./src/api/types/updates.ts":
/*!**********************************!*\
  !*** ./src/api/types/updates.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\n\n//# sourceURL=webpack://mytonwallet-lib/./src/api/types/updates.ts?");

/***/ }),

/***/ "./src/config.ts":
/*!***********************!*\
  !*** ./src/config.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"APP_ENV\": () => (/* binding */ APP_ENV),\n/* harmony export */   \"APP_VERSION\": () => (/* binding */ APP_VERSION),\n/* harmony export */   \"BRILLIANT_API_BASE_URL\": () => (/* binding */ BRILLIANT_API_BASE_URL),\n/* harmony export */   \"CURRENCY_LIST\": () => (/* binding */ CURRENCY_LIST),\n/* harmony export */   \"DEBUG\": () => (/* binding */ DEBUG),\n/* harmony export */   \"DEBUG_ALERT_MSG\": () => (/* binding */ DEBUG_ALERT_MSG),\n/* harmony export */   \"DEBUG_MORE\": () => (/* binding */ DEBUG_MORE),\n/* harmony export */   \"DEFAULT_DECIMAL_PLACES\": () => (/* binding */ DEFAULT_DECIMAL_PLACES),\n/* harmony export */   \"DEFAULT_ERROR_PAUSE\": () => (/* binding */ DEFAULT_ERROR_PAUSE),\n/* harmony export */   \"DEFAULT_FEE\": () => (/* binding */ DEFAULT_FEE),\n/* harmony export */   \"DEFAULT_PRICE_CURRENCY\": () => (/* binding */ DEFAULT_PRICE_CURRENCY),\n/* harmony export */   \"DEFAULT_RETRIES\": () => (/* binding */ DEFAULT_RETRIES),\n/* harmony export */   \"DEFAULT_TIMEOUT\": () => (/* binding */ DEFAULT_TIMEOUT),\n/* harmony export */   \"DEFAULT_WALLET_VERSION\": () => (/* binding */ DEFAULT_WALLET_VERSION),\n/* harmony export */   \"ELECTRON_TONHTTPAPI_MAINNET_API_KEY\": () => (/* binding */ ELECTRON_TONHTTPAPI_MAINNET_API_KEY),\n/* harmony export */   \"ELECTRON_TONHTTPAPI_TESTNET_API_KEY\": () => (/* binding */ ELECTRON_TONHTTPAPI_TESTNET_API_KEY),\n/* harmony export */   \"INIT_SWAP_ASSETS\": () => (/* binding */ INIT_SWAP_ASSETS),\n/* harmony export */   \"IS_NATIVE_ANDROID\": () => (/* binding */ IS_NATIVE_ANDROID),\n/* harmony export */   \"JUSDT_TOKEN_SLUG\": () => (/* binding */ JUSDT_TOKEN_SLUG),\n/* harmony export */   \"JWBTC_TOKEN_SLUG\": () => (/* binding */ JWBTC_TOKEN_SLUG),\n/* harmony export */   \"LIQUID_JETTON\": () => (/* binding */ LIQUID_JETTON),\n/* harmony export */   \"LIQUID_POOL\": () => (/* binding */ LIQUID_POOL),\n/* harmony export */   \"MAIN_ACCOUNT_ID\": () => (/* binding */ MAIN_ACCOUNT_ID),\n/* harmony export */   \"MIN_BALANCE_FOR_UNSTAKE\": () => (/* binding */ MIN_BALANCE_FOR_UNSTAKE),\n/* harmony export */   \"NOMINATORS_STAKING_MIN_AMOUNT\": () => (/* binding */ NOMINATORS_STAKING_MIN_AMOUNT),\n/* harmony export */   \"ONE_TON\": () => (/* binding */ ONE_TON),\n/* harmony export */   \"POPULAR_WALLET_VERSIONS\": () => (/* binding */ POPULAR_WALLET_VERSIONS),\n/* harmony export */   \"PRODUCTION_URL\": () => (/* binding */ PRODUCTION_URL),\n/* harmony export */   \"PROXY_HOSTS\": () => (/* binding */ PROXY_HOSTS),\n/* harmony export */   \"SHORT_CURRENCY_SYMBOL_MAP\": () => (/* binding */ SHORT_CURRENCY_SYMBOL_MAP),\n/* harmony export */   \"STAKING_CYCLE_DURATION_MS\": () => (/* binding */ STAKING_CYCLE_DURATION_MS),\n/* harmony export */   \"STAKING_FORWARD_AMOUNT\": () => (/* binding */ STAKING_FORWARD_AMOUNT),\n/* harmony export */   \"STAKING_MIN_AMOUNT\": () => (/* binding */ STAKING_MIN_AMOUNT),\n/* harmony export */   \"STAKING_POOLS\": () => (/* binding */ STAKING_POOLS),\n/* harmony export */   \"STRICTERDOM_ENABLED\": () => (/* binding */ STRICTERDOM_ENABLED),\n/* harmony export */   \"SWAP_FEE_ADDRESS\": () => (/* binding */ SWAP_FEE_ADDRESS),\n/* harmony export */   \"TINY_TRANSFER_MAX_COST\": () => (/* binding */ TINY_TRANSFER_MAX_COST),\n/* harmony export */   \"TOKEN_INFO\": () => (/* binding */ TOKEN_INFO),\n/* harmony export */   \"TONAPIIO_MAINNET_URL\": () => (/* binding */ TONAPIIO_MAINNET_URL),\n/* harmony export */   \"TONAPIIO_TESTNET_URL\": () => (/* binding */ TONAPIIO_TESTNET_URL),\n/* harmony export */   \"TONCONNECT_PROTOCOL\": () => (/* binding */ TONCONNECT_PROTOCOL),\n/* harmony export */   \"TONCONNECT_PROTOCOL_VERSION\": () => (/* binding */ TONCONNECT_PROTOCOL_VERSION),\n/* harmony export */   \"TONCONNECT_UNIVERSAL_URL\": () => (/* binding */ TONCONNECT_UNIVERSAL_URL),\n/* harmony export */   \"TONCONNECT_WALLET_JSBRIDGE_KEY\": () => (/* binding */ TONCONNECT_WALLET_JSBRIDGE_KEY),\n/* harmony export */   \"TONHTTPAPI_MAINNET_API_KEY\": () => (/* binding */ TONHTTPAPI_MAINNET_API_KEY),\n/* harmony export */   \"TONHTTPAPI_MAINNET_URL\": () => (/* binding */ TONHTTPAPI_MAINNET_URL),\n/* harmony export */   \"TONHTTPAPI_TESTNET_API_KEY\": () => (/* binding */ TONHTTPAPI_TESTNET_API_KEY),\n/* harmony export */   \"TONHTTPAPI_TESTNET_URL\": () => (/* binding */ TONHTTPAPI_TESTNET_URL),\n/* harmony export */   \"TONHTTPAPI_V3_MAINNET_API_URL\": () => (/* binding */ TONHTTPAPI_V3_MAINNET_API_URL),\n/* harmony export */   \"TONHTTPAPI_V3_TESTNET_API_URL\": () => (/* binding */ TONHTTPAPI_V3_TESTNET_API_URL),\n/* harmony export */   \"TON_BLOCKCHAIN\": () => (/* binding */ TON_BLOCKCHAIN),\n/* harmony export */   \"TON_PROTOCOL\": () => (/* binding */ TON_PROTOCOL),\n/* harmony export */   \"TON_SYMBOL\": () => (/* binding */ TON_SYMBOL),\n/* harmony export */   \"TON_TOKEN_SLUG\": () => (/* binding */ TON_TOKEN_SLUG),\n/* harmony export */   \"USDT_TRON_TOKEN_SLUG\": () => (/* binding */ USDT_TRON_TOKEN_SLUG),\n/* harmony export */   \"VALIDATION_PERIOD_MS\": () => (/* binding */ VALIDATION_PERIOD_MS)\n/* harmony export */ });\nconst APP_ENV = \"development\";\nconst APP_VERSION = \"1.0.0\";\nconst DEBUG = APP_ENV !== 'production' && APP_ENV !== 'perf' && APP_ENV !== 'test';\nconst DEBUG_MORE = false;\nconst PRODUCTION_URL = 'https://mytonwallet.app';\nconst SWAP_FEE_ADDRESS =  false || 'UQDUkQbpTVIgt7v66-JTFR-3-eXRFz_4V66F-Ufn6vOg0GOp';\nconst STRICTERDOM_ENABLED = DEBUG;\nconst DEBUG_ALERT_MSG = 'Shoot!\\nSomething went wrong, please see the error details in Dev Tools Console.';\nconst TON_SYMBOL = 'TON';\nconst DEFAULT_DECIMAL_PLACES = 9;\nconst MAIN_ACCOUNT_ID = '0-ton-mainnet';\nconst IS_NATIVE_ANDROID = false;\nconst TONHTTPAPI_MAINNET_URL = \"https://tonhttpapi.mytonwallet.org/api/v2/jsonRPC\" || 0;\nconst TONHTTPAPI_MAINNET_API_KEY = \"32b68f5b8ec2cd33ef41dc4396173fc309f369948b393c7fab46b72bac66434d\";\nconst ELECTRON_TONHTTPAPI_MAINNET_API_KEY = null;\nconst TONHTTPAPI_V3_MAINNET_API_URL =  false || 'https://tonhttpapi-v3.mytonwallet.org/api/v3';\nconst TONAPIIO_MAINNET_URL = \"https://tonapiio.mytonwallet.org\" || 0;\nconst TONHTTPAPI_TESTNET_URL = \"https://tonhttpapi-testnet.mytonwallet.org/api/v2/jsonRPC\" || 0;\nconst TONHTTPAPI_TESTNET_API_KEY = \"729eb455e9c0943dabdbe0c2c75270a67a3da6aae8ea7c6a572089e7c1939826\";\nconst ELECTRON_TONHTTPAPI_TESTNET_API_KEY = null;\nconst TONHTTPAPI_V3_TESTNET_API_URL =  false || 'https://tonhttpapi-v3-testnet.mytonwallet.org/api/v3';\nconst TONAPIIO_TESTNET_URL = \"https://tonapiio-testnet.mytonwallet.org\" || 0;\nconst BRILLIANT_API_BASE_URL =  false || 'https://api.mytonwallet.org';\nconst TON_TOKEN_SLUG = 'toncoin';\nconst JWBTC_TOKEN_SLUG = 'ton-eqdcbkghmc';\nconst JUSDT_TOKEN_SLUG = 'ton-eqbynbo23y';\nconst USDT_TRON_TOKEN_SLUG = 'usdtrx';\nconst PROXY_HOSTS = \"tonproxy.io:38080 tonproxy.io:38081 tonproxy.io:38082\";\nconst TINY_TRANSFER_MAX_COST = 0.01;\nconst STAKING_CYCLE_DURATION_MS = 131072000; // 36.4 hours\nconst VALIDATION_PERIOD_MS = 65536000; // 18.2 h.\nconst ONE_TON = 1000000000n;\nconst MIN_BALANCE_FOR_UNSTAKE = 1020000000n; // 1.02 TON\nconst STAKING_FORWARD_AMOUNT = ONE_TON;\nconst DEFAULT_FEE = 15000000n; // 0.015 TON\n\nconst STAKING_POOLS =  false ? 0 : [];\nconst LIQUID_POOL =  false || 'EQD2_4d91M4TVbEBVyBF8J1UwpMJc361LKVCz6bBlffMW05o';\nconst LIQUID_JETTON =  false || 'EQCqC6EhRJ_tpWngKxL6dV0k6DSnRUrs9GSVkLbfdCqsj6TE';\nconst STAKING_MIN_AMOUNT = ONE_TON;\nconst NOMINATORS_STAKING_MIN_AMOUNT = ONE_TON * 10001n;\nconst TON_PROTOCOL = 'ton://';\nconst TONCONNECT_PROTOCOL = 'tc://';\nconst TONCONNECT_UNIVERSAL_URL = 'https://connect.mytonwallet.org';\nconst TONCONNECT_PROTOCOL_VERSION = 2;\nconst TONCONNECT_WALLET_JSBRIDGE_KEY = 'mytonwallet';\nconst TOKEN_INFO = {\n  toncoin: {\n    name: 'Toncoin',\n    symbol: TON_SYMBOL,\n    slug: TON_TOKEN_SLUG,\n    cmcSlug: TON_TOKEN_SLUG,\n    quote: {\n      slug: TON_TOKEN_SLUG,\n      price: 1.95,\n      priceUsd: 1.95,\n      percentChange24h: 0\n    },\n    decimals: DEFAULT_DECIMAL_PLACES\n  }\n};\nconst TON_BLOCKCHAIN = 'ton';\nconst INIT_SWAP_ASSETS = {\n  toncoin: {\n    name: 'Toncoin',\n    symbol: TON_SYMBOL,\n    blockchain: TON_BLOCKCHAIN,\n    slug: TON_TOKEN_SLUG,\n    decimals: DEFAULT_DECIMAL_PLACES,\n    price: 0,\n    priceUsd: 0,\n    isPopular: true\n  },\n  'ton-eqdcbkghmc': {\n    name: 'jWBTC',\n    symbol: 'jWBTC',\n    blockchain: TON_BLOCKCHAIN,\n    slug: 'ton-eqdcbkghmc',\n    decimals: 8,\n    // eslint-disable-next-line max-len\n    image: 'https://cache.tonapi.io/imgproxy/LaFKdzahVX9epWT067gyVLd8aCa1lFrZd7Rp9siViEE/rs:fill:200:200:1/g:no/aHR0cHM6Ly9icmlkZ2UudG9uLm9yZy90b2tlbi8xLzB4MjI2MGZhYzVlNTU0MmE3NzNhYTQ0ZmJjZmVkZjdjMTkzYmMyYzU5OS5wbmc.webp',\n    contract: 'EQDcBkGHmC4pTf34x3Gm05XvepO5w60DNxZ-XT4I6-UGG5L5',\n    price: 0,\n    priceUsd: 0,\n    isPopular: false,\n    keywords: ['bitcoin']\n  }\n};\nconst DEFAULT_PRICE_CURRENCY = 'USD';\nconst SHORT_CURRENCY_SYMBOL_MAP = {\n  USD: '$',\n  EUR: '',\n  RUB: '',\n  CNY: ''\n};\nconst CURRENCY_LIST = [{\n  value: 'USD',\n  name: 'US Dollar'\n}, {\n  value: 'EUR',\n  name: 'Euro'\n}, {\n  value: 'RUB',\n  name: 'Ruble'\n}, {\n  value: 'CNY',\n  name: 'Yuan'\n}, {\n  value: 'BTC',\n  name: 'Bitcoin'\n}, {\n  value: TON_SYMBOL,\n  name: 'Toncoin'\n}];\nconst DEFAULT_WALLET_VERSION = 'v4R2';\nconst POPULAR_WALLET_VERSIONS = ['v3R1', 'v3R2', 'v4R2'];\nconst DEFAULT_TIMEOUT = 5000;\nconst DEFAULT_RETRIES = 3;\nconst DEFAULT_ERROR_PAUSE = 200;\n\n//# sourceURL=webpack://mytonwallet-lib/./src/config.ts?");

/***/ }),

/***/ "./src/lib/aes-js/index.js":
/*!*********************************!*\
  !*** ./src/lib/aes-js/index.js ***!
  \*********************************/
/***/ (function(module) {

eval("// Version 3.1.2\n/*! MIT License. Copyright 2015-2018 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */\n(function (root) {\n  \"use strict\";\n\n  function checkInt(value) {\n    return parseInt(value) === value;\n  }\n  function checkInts(arrayish) {\n    if (!checkInt(arrayish.length)) {\n      return false;\n    }\n    for (var i = 0; i < arrayish.length; i++) {\n      if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function coerceArray(arg, copy) {\n    // ArrayBuffer view\n    if (arg.buffer && arg.name === 'Uint8Array') {\n      if (copy) {\n        if (arg.slice) {\n          arg = arg.slice();\n        } else {\n          arg = Array.prototype.slice.call(arg);\n        }\n      }\n      return arg;\n    }\n\n    // It's an array; check it is a valid representation of a byte\n    if (Array.isArray(arg)) {\n      if (!checkInts(arg)) {\n        throw new Error('Array contains invalid value: ' + arg);\n      }\n      return new Uint8Array(arg);\n    }\n\n    // Something else, but behaves like an array (maybe a Buffer? Arguments?)\n    if (checkInt(arg.length) && checkInts(arg)) {\n      return new Uint8Array(arg);\n    }\n    throw new Error('unsupported array-like object');\n  }\n  function createArray(length) {\n    return new Uint8Array(length);\n  }\n  function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {\n    if (sourceStart != null || sourceEnd != null) {\n      if (sourceArray.slice) {\n        sourceArray = sourceArray.slice(sourceStart, sourceEnd);\n      } else {\n        sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);\n      }\n    }\n    targetArray.set(sourceArray, targetStart);\n  }\n  var convertUtf8 = function () {\n    function toBytes(text) {\n      var result = [],\n        i = 0;\n      text = encodeURI(text);\n      while (i < text.length) {\n        var c = text.charCodeAt(i++);\n\n        // if it is a % sign, encode the following 2 bytes as a hex value\n        if (c === 37) {\n          result.push(parseInt(text.substr(i, 2), 16));\n          i += 2;\n\n          // otherwise, just the actual byte\n        } else {\n          result.push(c);\n        }\n      }\n      return coerceArray(result);\n    }\n    function fromBytes(bytes) {\n      var result = [],\n        i = 0;\n      while (i < bytes.length) {\n        var c = bytes[i];\n        if (c < 128) {\n          result.push(String.fromCharCode(c));\n          i++;\n        } else if (c > 191 && c < 224) {\n          result.push(String.fromCharCode((c & 0x1f) << 6 | bytes[i + 1] & 0x3f));\n          i += 2;\n        } else {\n          result.push(String.fromCharCode((c & 0x0f) << 12 | (bytes[i + 1] & 0x3f) << 6 | bytes[i + 2] & 0x3f));\n          i += 3;\n        }\n      }\n      return result.join('');\n    }\n    return {\n      toBytes: toBytes,\n      fromBytes: fromBytes\n    };\n  }();\n  var convertHex = function () {\n    function toBytes(text) {\n      var result = [];\n      for (var i = 0; i < text.length; i += 2) {\n        result.push(parseInt(text.substr(i, 2), 16));\n      }\n      return result;\n    }\n\n    // http://ixti.net/development/javascript/2011/11/11/base64-encodedecode-of-utf8-in-browser-with-js.html\n    var Hex = '0123456789abcdef';\n    function fromBytes(bytes) {\n      var result = [];\n      for (var i = 0; i < bytes.length; i++) {\n        var v = bytes[i];\n        result.push(Hex[(v & 0xf0) >> 4] + Hex[v & 0x0f]);\n      }\n      return result.join('');\n    }\n    return {\n      toBytes: toBytes,\n      fromBytes: fromBytes\n    };\n  }();\n\n  // Number of rounds by keysize\n  var numberOfRounds = {\n    16: 10,\n    24: 12,\n    32: 14\n  };\n\n  // Round constant words\n  var rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];\n\n  // S-box and Inverse S-box (S is for Substitution)\n  var S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];\n  var Si = [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];\n\n  // Transformations for encryption\n  var T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];\n  var T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];\n  var T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];\n  var T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];\n\n  // Transformations for decryption\n  var T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];\n  var T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];\n  var T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];\n  var T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];\n\n  // Transformations for decryption key expansion\n  var U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];\n  var U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];\n  var U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];\n  var U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];\n  function convertToInt32(bytes) {\n    var result = [];\n    for (var i = 0; i < bytes.length; i += 4) {\n      result.push(bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]);\n    }\n    return result;\n  }\n  var AES = function (key) {\n    if (!(this instanceof AES)) {\n      throw Error('AES must be instanitated with `new`');\n    }\n    Object.defineProperty(this, 'key', {\n      value: coerceArray(key, true)\n    });\n    this._prepare();\n  };\n  AES.prototype._prepare = function () {\n    var rounds = numberOfRounds[this.key.length];\n    if (rounds == null) {\n      throw new Error('invalid key size (must be 16, 24 or 32 bytes)');\n    }\n\n    // encryption round keys\n    this._Ke = [];\n\n    // decryption round keys\n    this._Kd = [];\n    for (var i = 0; i <= rounds; i++) {\n      this._Ke.push([0, 0, 0, 0]);\n      this._Kd.push([0, 0, 0, 0]);\n    }\n    var roundKeyCount = (rounds + 1) * 4;\n    var KC = this.key.length / 4;\n\n    // convert the key into ints\n    var tk = convertToInt32(this.key);\n\n    // copy values into round key arrays\n    var index;\n    for (var i = 0; i < KC; i++) {\n      index = i >> 2;\n      this._Ke[index][i % 4] = tk[i];\n      this._Kd[rounds - index][i % 4] = tk[i];\n    }\n\n    // key expansion (fips-197 section 5.2)\n    var rconpointer = 0;\n    var t = KC,\n      tt;\n    while (t < roundKeyCount) {\n      tt = tk[KC - 1];\n      tk[0] ^= S[tt >> 16 & 0xFF] << 24 ^ S[tt >> 8 & 0xFF] << 16 ^ S[tt & 0xFF] << 8 ^ S[tt >> 24 & 0xFF] ^ rcon[rconpointer] << 24;\n      rconpointer += 1;\n\n      // key expansion (for non-256 bit)\n      if (KC != 8) {\n        for (var i = 1; i < KC; i++) {\n          tk[i] ^= tk[i - 1];\n        }\n\n        // key expansion for 256-bit keys is \"slightly different\" (fips-197)\n      } else {\n        for (var i = 1; i < KC / 2; i++) {\n          tk[i] ^= tk[i - 1];\n        }\n        tt = tk[KC / 2 - 1];\n        tk[KC / 2] ^= S[tt & 0xFF] ^ S[tt >> 8 & 0xFF] << 8 ^ S[tt >> 16 & 0xFF] << 16 ^ S[tt >> 24 & 0xFF] << 24;\n        for (var i = KC / 2 + 1; i < KC; i++) {\n          tk[i] ^= tk[i - 1];\n        }\n      }\n\n      // copy values into round key arrays\n      var i = 0,\n        r,\n        c;\n      while (i < KC && t < roundKeyCount) {\n        r = t >> 2;\n        c = t % 4;\n        this._Ke[r][c] = tk[i];\n        this._Kd[rounds - r][c] = tk[i++];\n        t++;\n      }\n    }\n\n    // inverse-cipher-ify the decryption round key (fips-197 section 5.3)\n    for (var r = 1; r < rounds; r++) {\n      for (var c = 0; c < 4; c++) {\n        tt = this._Kd[r][c];\n        this._Kd[r][c] = U1[tt >> 24 & 0xFF] ^ U2[tt >> 16 & 0xFF] ^ U3[tt >> 8 & 0xFF] ^ U4[tt & 0xFF];\n      }\n    }\n  };\n  AES.prototype.encrypt = function (plaintext) {\n    if (plaintext.length != 16) {\n      throw new Error('invalid plaintext size (must be 16 bytes)');\n    }\n    var rounds = this._Ke.length - 1;\n    var a = [0, 0, 0, 0];\n\n    // convert plaintext to (ints ^ key)\n    var t = convertToInt32(plaintext);\n    for (var i = 0; i < 4; i++) {\n      t[i] ^= this._Ke[0][i];\n    }\n\n    // apply round transforms\n    for (var r = 1; r < rounds; r++) {\n      for (var i = 0; i < 4; i++) {\n        a[i] = T1[t[i] >> 24 & 0xff] ^ T2[t[(i + 1) % 4] >> 16 & 0xff] ^ T3[t[(i + 2) % 4] >> 8 & 0xff] ^ T4[t[(i + 3) % 4] & 0xff] ^ this._Ke[r][i];\n      }\n      t = a.slice();\n    }\n\n    // the last round is special\n    var result = createArray(16),\n      tt;\n    for (var i = 0; i < 4; i++) {\n      tt = this._Ke[rounds][i];\n      result[4 * i] = (S[t[i] >> 24 & 0xff] ^ tt >> 24) & 0xff;\n      result[4 * i + 1] = (S[t[(i + 1) % 4] >> 16 & 0xff] ^ tt >> 16) & 0xff;\n      result[4 * i + 2] = (S[t[(i + 2) % 4] >> 8 & 0xff] ^ tt >> 8) & 0xff;\n      result[4 * i + 3] = (S[t[(i + 3) % 4] & 0xff] ^ tt) & 0xff;\n    }\n    return result;\n  };\n  AES.prototype.decrypt = function (ciphertext) {\n    if (ciphertext.length != 16) {\n      throw new Error('invalid ciphertext size (must be 16 bytes)');\n    }\n    var rounds = this._Kd.length - 1;\n    var a = [0, 0, 0, 0];\n\n    // convert plaintext to (ints ^ key)\n    var t = convertToInt32(ciphertext);\n    for (var i = 0; i < 4; i++) {\n      t[i] ^= this._Kd[0][i];\n    }\n\n    // apply round transforms\n    for (var r = 1; r < rounds; r++) {\n      for (var i = 0; i < 4; i++) {\n        a[i] = T5[t[i] >> 24 & 0xff] ^ T6[t[(i + 3) % 4] >> 16 & 0xff] ^ T7[t[(i + 2) % 4] >> 8 & 0xff] ^ T8[t[(i + 1) % 4] & 0xff] ^ this._Kd[r][i];\n      }\n      t = a.slice();\n    }\n\n    // the last round is special\n    var result = createArray(16),\n      tt;\n    for (var i = 0; i < 4; i++) {\n      tt = this._Kd[rounds][i];\n      result[4 * i] = (Si[t[i] >> 24 & 0xff] ^ tt >> 24) & 0xff;\n      result[4 * i + 1] = (Si[t[(i + 3) % 4] >> 16 & 0xff] ^ tt >> 16) & 0xff;\n      result[4 * i + 2] = (Si[t[(i + 2) % 4] >> 8 & 0xff] ^ tt >> 8) & 0xff;\n      result[4 * i + 3] = (Si[t[(i + 1) % 4] & 0xff] ^ tt) & 0xff;\n    }\n    return result;\n  };\n\n  /**\n   *  Mode Of Operation - Electonic Codebook (ECB)\n   */\n  var ModeOfOperationECB = function (key) {\n    if (!(this instanceof ModeOfOperationECB)) {\n      throw Error('AES must be instanitated with `new`');\n    }\n    this.description = \"Electronic Code Block\";\n    this.name = \"ecb\";\n    this._aes = new AES(key);\n  };\n  ModeOfOperationECB.prototype.encrypt = function (plaintext) {\n    plaintext = coerceArray(plaintext);\n    if (plaintext.length % 16 !== 0) {\n      throw new Error('invalid plaintext size (must be multiple of 16 bytes)');\n    }\n    var ciphertext = createArray(plaintext.length);\n    var block = createArray(16);\n    for (var i = 0; i < plaintext.length; i += 16) {\n      copyArray(plaintext, block, 0, i, i + 16);\n      block = this._aes.encrypt(block);\n      copyArray(block, ciphertext, i);\n    }\n    return ciphertext;\n  };\n  ModeOfOperationECB.prototype.decrypt = function (ciphertext) {\n    ciphertext = coerceArray(ciphertext);\n    if (ciphertext.length % 16 !== 0) {\n      throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');\n    }\n    var plaintext = createArray(ciphertext.length);\n    var block = createArray(16);\n    for (var i = 0; i < ciphertext.length; i += 16) {\n      copyArray(ciphertext, block, 0, i, i + 16);\n      block = this._aes.decrypt(block);\n      copyArray(block, plaintext, i);\n    }\n    return plaintext;\n  };\n\n  /**\n   *  Mode Of Operation - Cipher Block Chaining (CBC)\n   */\n  var ModeOfOperationCBC = function (key, iv) {\n    if (!(this instanceof ModeOfOperationCBC)) {\n      throw Error('AES must be instanitated with `new`');\n    }\n    this.description = \"Cipher Block Chaining\";\n    this.name = \"cbc\";\n    if (!iv) {\n      iv = createArray(16);\n    } else if (iv.length != 16) {\n      throw new Error('invalid initialation vector size (must be 16 bytes)');\n    }\n    this._lastCipherblock = coerceArray(iv, true);\n    this._aes = new AES(key);\n  };\n  ModeOfOperationCBC.prototype.encrypt = function (plaintext) {\n    plaintext = coerceArray(plaintext);\n    if (plaintext.length % 16 !== 0) {\n      throw new Error('invalid plaintext size (must be multiple of 16 bytes)');\n    }\n    var ciphertext = createArray(plaintext.length);\n    var block = createArray(16);\n    for (var i = 0; i < plaintext.length; i += 16) {\n      copyArray(plaintext, block, 0, i, i + 16);\n      for (var j = 0; j < 16; j++) {\n        block[j] ^= this._lastCipherblock[j];\n      }\n      this._lastCipherblock = this._aes.encrypt(block);\n      copyArray(this._lastCipherblock, ciphertext, i);\n    }\n    return ciphertext;\n  };\n  ModeOfOperationCBC.prototype.decrypt = function (ciphertext) {\n    ciphertext = coerceArray(ciphertext);\n    if (ciphertext.length % 16 !== 0) {\n      throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');\n    }\n    var plaintext = createArray(ciphertext.length);\n    var block = createArray(16);\n    for (var i = 0; i < ciphertext.length; i += 16) {\n      copyArray(ciphertext, block, 0, i, i + 16);\n      block = this._aes.decrypt(block);\n      for (var j = 0; j < 16; j++) {\n        plaintext[i + j] = block[j] ^ this._lastCipherblock[j];\n      }\n      copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);\n    }\n    return plaintext;\n  };\n\n  /**\n   *  Mode Of Operation - Cipher Feedback (CFB)\n   */\n  var ModeOfOperationCFB = function (key, iv, segmentSize) {\n    if (!(this instanceof ModeOfOperationCFB)) {\n      throw Error('AES must be instanitated with `new`');\n    }\n    this.description = \"Cipher Feedback\";\n    this.name = \"cfb\";\n    if (!iv) {\n      iv = createArray(16);\n    } else if (iv.length != 16) {\n      throw new Error('invalid initialation vector size (must be 16 size)');\n    }\n    if (!segmentSize) {\n      segmentSize = 1;\n    }\n    this.segmentSize = segmentSize;\n    this._shiftRegister = coerceArray(iv, true);\n    this._aes = new AES(key);\n  };\n  ModeOfOperationCFB.prototype.encrypt = function (plaintext) {\n    if (plaintext.length % this.segmentSize != 0) {\n      throw new Error('invalid plaintext size (must be segmentSize bytes)');\n    }\n    var encrypted = coerceArray(plaintext, true);\n    var xorSegment;\n    for (var i = 0; i < encrypted.length; i += this.segmentSize) {\n      xorSegment = this._aes.encrypt(this._shiftRegister);\n      for (var j = 0; j < this.segmentSize; j++) {\n        encrypted[i + j] ^= xorSegment[j];\n      }\n\n      // Shift the register\n      copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);\n      copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);\n    }\n    return encrypted;\n  };\n  ModeOfOperationCFB.prototype.decrypt = function (ciphertext) {\n    if (ciphertext.length % this.segmentSize != 0) {\n      throw new Error('invalid ciphertext size (must be segmentSize bytes)');\n    }\n    var plaintext = coerceArray(ciphertext, true);\n    var xorSegment;\n    for (var i = 0; i < plaintext.length; i += this.segmentSize) {\n      xorSegment = this._aes.encrypt(this._shiftRegister);\n      for (var j = 0; j < this.segmentSize; j++) {\n        plaintext[i + j] ^= xorSegment[j];\n      }\n\n      // Shift the register\n      copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);\n      copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);\n    }\n    return plaintext;\n  };\n\n  /**\n   *  Mode Of Operation - Output Feedback (OFB)\n   */\n  var ModeOfOperationOFB = function (key, iv) {\n    if (!(this instanceof ModeOfOperationOFB)) {\n      throw Error('AES must be instanitated with `new`');\n    }\n    this.description = \"Output Feedback\";\n    this.name = \"ofb\";\n    if (!iv) {\n      iv = createArray(16);\n    } else if (iv.length != 16) {\n      throw new Error('invalid initialation vector size (must be 16 bytes)');\n    }\n    this._lastPrecipher = coerceArray(iv, true);\n    this._lastPrecipherIndex = 16;\n    this._aes = new AES(key);\n  };\n  ModeOfOperationOFB.prototype.encrypt = function (plaintext) {\n    var encrypted = coerceArray(plaintext, true);\n    for (var i = 0; i < encrypted.length; i++) {\n      if (this._lastPrecipherIndex === 16) {\n        this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);\n        this._lastPrecipherIndex = 0;\n      }\n      encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];\n    }\n    return encrypted;\n  };\n\n  // Decryption is symetric\n  ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;\n\n  /**\n   *  Counter object for CTR common mode of operation\n   */\n  var Counter = function (initialValue) {\n    if (!(this instanceof Counter)) {\n      throw Error('Counter must be instanitated with `new`');\n    }\n\n    // We allow 0, but anything false-ish uses the default 1\n    if (initialValue !== 0 && !initialValue) {\n      initialValue = 1;\n    }\n    if (typeof initialValue === 'number') {\n      this._counter = createArray(16);\n      this.setValue(initialValue);\n    } else {\n      this.setBytes(initialValue);\n    }\n  };\n  Counter.prototype.setValue = function (value) {\n    if (typeof value !== 'number' || parseInt(value) != value) {\n      throw new Error('invalid counter value (must be an integer)');\n    }\n\n    // We cannot safely handle numbers beyond the safe range for integers\n    if (value > Number.MAX_SAFE_INTEGER) {\n      throw new Error('integer value out of safe range');\n    }\n    for (var index = 15; index >= 0; --index) {\n      this._counter[index] = value % 256;\n      value = parseInt(value / 256);\n    }\n  };\n  Counter.prototype.setBytes = function (bytes) {\n    bytes = coerceArray(bytes, true);\n    if (bytes.length != 16) {\n      throw new Error('invalid counter bytes size (must be 16 bytes)');\n    }\n    this._counter = bytes;\n  };\n  Counter.prototype.increment = function () {\n    for (var i = 15; i >= 0; i--) {\n      if (this._counter[i] === 255) {\n        this._counter[i] = 0;\n      } else {\n        this._counter[i]++;\n        break;\n      }\n    }\n  };\n\n  /**\n   *  Mode Of Operation - Counter (CTR)\n   */\n  var ModeOfOperationCTR = function (key, counter) {\n    if (!(this instanceof ModeOfOperationCTR)) {\n      throw Error('AES must be instanitated with `new`');\n    }\n    this.description = \"Counter\";\n    this.name = \"ctr\";\n    if (!(counter instanceof Counter)) {\n      counter = new Counter(counter);\n    }\n    this._counter = counter;\n    this._remainingCounter = null;\n    this._remainingCounterIndex = 16;\n    this._aes = new AES(key);\n  };\n  ModeOfOperationCTR.prototype.encrypt = function (plaintext) {\n    var encrypted = coerceArray(plaintext, true);\n    for (var i = 0; i < encrypted.length; i++) {\n      if (this._remainingCounterIndex === 16) {\n        this._remainingCounter = this._aes.encrypt(this._counter._counter);\n        this._remainingCounterIndex = 0;\n        this._counter.increment();\n      }\n      encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];\n    }\n    return encrypted;\n  };\n\n  // Decryption is symetric\n  ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;\n\n  ///////////////////////\n  // Padding\n\n  // See:https://tools.ietf.org/html/rfc2315\n  function pkcs7pad(data) {\n    data = coerceArray(data, true);\n    var padder = 16 - data.length % 16;\n    var result = createArray(data.length + padder);\n    copyArray(data, result);\n    for (var i = data.length; i < result.length; i++) {\n      result[i] = padder;\n    }\n    return result;\n  }\n  function pkcs7strip(data) {\n    data = coerceArray(data, true);\n    if (data.length < 16) {\n      throw new Error('PKCS#7 invalid length');\n    }\n    var padder = data[data.length - 1];\n    if (padder > 16) {\n      throw new Error('PKCS#7 padding byte out of range');\n    }\n    var length = data.length - padder;\n    for (var i = 0; i < padder; i++) {\n      if (data[length + i] !== padder) {\n        throw new Error('PKCS#7 invalid padding byte');\n      }\n    }\n    var result = createArray(length);\n    copyArray(data, result, 0, 0, length);\n    return result;\n  }\n\n  ///////////////////////\n  // Exporting\n\n  // The block cipher\n  var aesjs = {\n    AES: AES,\n    Counter: Counter,\n    ModeOfOperation: {\n      ecb: ModeOfOperationECB,\n      cbc: ModeOfOperationCBC,\n      cfb: ModeOfOperationCFB,\n      ofb: ModeOfOperationOFB,\n      ctr: ModeOfOperationCTR\n    },\n    utils: {\n      hex: convertHex,\n      utf8: convertUtf8\n    },\n    padding: {\n      pkcs7: {\n        pad: pkcs7pad,\n        strip: pkcs7strip\n      }\n    },\n    _arrayTest: {\n      coerceArray: coerceArray,\n      createArray: createArray,\n      copyArray: copyArray\n    }\n  };\n\n  // node.js\n  if (true) {\n    module.exports = aesjs;\n\n    // RequireJS/AMD\n    // http://www.requirejs.org/docs/api.html\n    // https://github.com/amdjs/amdjs-api/wiki/AMD\n  } else {}\n})(this);\n\n//# sourceURL=webpack://mytonwallet-lib/./src/lib/aes-js/index.js?");

/***/ }),

/***/ "./src/lib/axios-fetch-adapter/index.js":
/*!**********************************************!*\
  !*** ./src/lib/axios-fetch-adapter/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fetchAdapter)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var axios_lib_core_buildFullPath__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios/lib/core/buildFullPath */ \"./node_modules/axios/lib/core/buildFullPath.js\");\n/* harmony import */ var axios_lib_core_buildFullPath__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(axios_lib_core_buildFullPath__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var axios_lib_core_settle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! axios/lib/core/settle */ \"./node_modules/axios/lib/core/settle.js\");\n/* harmony import */ var axios_lib_core_settle__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(axios_lib_core_settle__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var axios_lib_helpers_buildURL__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! axios/lib/helpers/buildURL */ \"./node_modules/axios/lib/helpers/buildURL.js\");\n/* harmony import */ var axios_lib_helpers_buildURL__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(axios_lib_helpers_buildURL__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var axios_lib_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! axios/lib/utils */ \"./node_modules/axios/lib/utils.js\");\n/* harmony import */ var axios_lib_utils__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(axios_lib_utils__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\n\n/**\n * - Create a request object\n * - Get response body\n * - Check if timeout\n */\nasync function fetchAdapter(config) {\n  const request = createRequest(config);\n  const promiseChain = [getResponse(request, config)];\n  if (config.timeout && config.timeout > 0) {\n    promiseChain.push(new Promise(res => {\n      setTimeout(() => {\n        const message = config.timeoutErrorMessage ? config.timeoutErrorMessage : `timeout of ${config.timeout}ms exceeded`;\n        res(createError(message, config, 'ECONNABORTED', request));\n      }, config.timeout);\n    }));\n  }\n  const data = await Promise.race(promiseChain);\n  return new Promise((resolve, reject) => {\n    if (data instanceof Error) {\n      reject(data);\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n      Object.prototype.toString.call(config.settle) === '[object Function]' ? config.settle(resolve, reject, data) : axios_lib_core_settle__WEBPACK_IMPORTED_MODULE_2___default()(resolve, reject, data);\n    }\n  });\n}\n\n/**\n * Fetch API stage two is to get response body. This funtion tries to retrieve\n * response body based on response's type\n */\nasync function getResponse(request, config) {\n  let stageOne;\n  try {\n    stageOne = await fetch(request);\n  } catch (e) {\n    return createError('Network Error', config, 'ERR_NETWORK', request);\n  }\n  const response = {\n    ok: stageOne.ok,\n    status: stageOne.status,\n    statusText: stageOne.statusText,\n    headers: new Headers(stageOne.headers),\n    // Make a copy of headers\n    config,\n    request\n  };\n  if (stageOne.status >= 200 && stageOne.status !== 204) {\n    switch (config.responseType) {\n      case 'arraybuffer':\n        response.data = await stageOne.arrayBuffer();\n        break;\n      case 'blob':\n        response.data = await stageOne.blob();\n        break;\n      case 'json':\n        response.data = await stageOne.json();\n        break;\n      case 'formData':\n        response.data = await stageOne.formData();\n        break;\n      default:\n        response.data = await stageOne.text();\n        break;\n    }\n  }\n  return response;\n}\n\n/**\n * This function will create a Request object based on configuration's axios\n */\nfunction createRequest(config) {\n  const headers = new Headers(config.headers);\n\n  // HTTP basic authentication\n  if (config.auth) {\n    const username = config.auth.username || '';\n    const password = config.auth.password ? decodeURI(encodeURIComponent(config.auth.password)) : '';\n    headers.set('Authorization', `Basic ${btoa(`${username}:${password}`)}`);\n  }\n  const method = config.method.toUpperCase();\n  const options = {\n    headers,\n    method\n  };\n  if (method !== 'GET' && method !== 'HEAD') {\n    options.body = config.data;\n\n    // In these cases the browser will automatically set the correct Content-Type,\n    // but only if that header hasn't been set yet. So that's why we're deleting it.\n    if ((0,axios_lib_utils__WEBPACK_IMPORTED_MODULE_4__.isFormData)(options.body) && (0,axios_lib_utils__WEBPACK_IMPORTED_MODULE_4__.isStandardBrowserEnv)()) {\n      headers.delete('Content-Type');\n    }\n  }\n  if (config.mode) {\n    options.mode = config.mode;\n  }\n  if (config.cache) {\n    options.cache = config.cache;\n  }\n  if (config.integrity) {\n    options.integrity = config.integrity;\n  }\n  if (config.redirect) {\n    options.redirect = config.redirect;\n  }\n  if (config.referrer) {\n    options.referrer = config.referrer;\n  }\n  // This config is similar to XHRs withCredentials flag, but with three available values instead of two.\n  // So if withCredentials is not set, default value 'same-origin' will be used\n  if (!(0,axios_lib_utils__WEBPACK_IMPORTED_MODULE_4__.isUndefined)(config.withCredentials)) {\n    options.credentials = config.withCredentials ? 'include' : 'omit';\n  }\n  const fullPath = axios_lib_core_buildFullPath__WEBPACK_IMPORTED_MODULE_1___default()(config.baseURL, config.url);\n  const url = axios_lib_helpers_buildURL__WEBPACK_IMPORTED_MODULE_3___default()(fullPath, config.params, config.paramsSerializer);\n\n  // Expected browser to throw error if there is any wrong configuration value\n  return new Request(url, options);\n}\n\n/**\n * Note:\n *\n *   From version >= 0.27.0, createError function is replaced by AxiosError class.\n *   So I copy the old createError function here for backward compatible.\n *\n *\n *\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nfunction createError(message, config, code, request, response) {\n  if ((axios__WEBPACK_IMPORTED_MODULE_0___default().AxiosError) && typeof (axios__WEBPACK_IMPORTED_MODULE_0___default().AxiosError) === 'function') {\n    return new (axios__WEBPACK_IMPORTED_MODULE_0___default().AxiosError)(message, (axios__WEBPACK_IMPORTED_MODULE_0___default().AxiosError)[code], config, request, response);\n  }\n  const error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n}\n\n/**\n *\n * Note:\n *\n *   This function is for backward compatible.\n *\n *\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nfunction enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n  error.toJSON = function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code,\n      // eslint-disable-next-line no-null/no-null\n      status: this.response && this.response.status ? this.response.status : null\n    };\n  };\n  return error;\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/lib/axios-fetch-adapter/index.js?");

/***/ }),

/***/ "./src/lib/axios-retry/index.js":
/*!**************************************!*\
  !*** ./src/lib/axios-retry/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.DEFAULT_OPTIONS = exports.exponentialDelay = exports.isNetworkOrIdempotentRequestError = exports.isIdempotentRequestError = exports.isSafeRequestError = exports.isRetryableError = exports.isNetworkError = exports.namespace = void 0;\nconst is_retry_allowed_1 = __importDefault(__webpack_require__(/*! ../is-retry-allowed */ \"./src/lib/is-retry-allowed/index.js\"));\nexports.namespace = 'axios-retry';\nfunction isNetworkError(error) {\n  const CODE_EXCLUDE_LIST = ['ERR_CANCELED', 'ECONNABORTED'];\n  if (error.response) {\n    return false;\n  }\n  if (!error.code) {\n    return false;\n  }\n  // Prevents retrying timed out & cancelled requests\n  if (CODE_EXCLUDE_LIST.includes(error.code)) {\n    return false;\n  }\n  // Prevents retrying unsafe errors\n  return (0, is_retry_allowed_1.default)(error);\n}\nexports.isNetworkError = isNetworkError;\nconst SAFE_HTTP_METHODS = ['get', 'head', 'options'];\nconst IDEMPOTENT_HTTP_METHODS = SAFE_HTTP_METHODS.concat(['put', 'delete']);\nfunction isRetryableError(error) {\n  return error.code !== 'ECONNABORTED' && (!error.response || error.response.status >= 500 && error.response.status <= 599);\n}\nexports.isRetryableError = isRetryableError;\nfunction isSafeRequestError(error) {\n  var _a;\n  if (!((_a = error.config) === null || _a === void 0 ? void 0 : _a.method)) {\n    // Cannot determine if the request can be retried\n    return false;\n  }\n  return isRetryableError(error) && SAFE_HTTP_METHODS.indexOf(error.config.method) !== -1;\n}\nexports.isSafeRequestError = isSafeRequestError;\nfunction isIdempotentRequestError(error) {\n  var _a;\n  if (!((_a = error.config) === null || _a === void 0 ? void 0 : _a.method)) {\n    // Cannot determine if the request can be retried\n    return false;\n  }\n  return isRetryableError(error) && IDEMPOTENT_HTTP_METHODS.indexOf(error.config.method) !== -1;\n}\nexports.isIdempotentRequestError = isIdempotentRequestError;\nfunction isNetworkOrIdempotentRequestError(error) {\n  return isNetworkError(error) || isIdempotentRequestError(error);\n}\nexports.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;\nfunction noDelay() {\n  return 0;\n}\nfunction exponentialDelay() {\n  let retryNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  let _error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  let delayFactor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n  const delay = Math.pow(2, retryNumber) * delayFactor;\n  const randomSum = delay * 0.2 * Math.random(); // 0-20% of the delay\n  return delay + randomSum;\n}\nexports.exponentialDelay = exponentialDelay;\nexports.DEFAULT_OPTIONS = {\n  retries: 3,\n  retryCondition: isNetworkOrIdempotentRequestError,\n  retryDelay: noDelay,\n  shouldResetTimeout: false,\n  onRetry: () => {}\n};\nfunction getRequestOptions(config, defaultOptions) {\n  return Object.assign(Object.assign(Object.assign({}, exports.DEFAULT_OPTIONS), defaultOptions), config[exports.namespace]);\n}\nfunction setCurrentState(config, defaultOptions) {\n  const currentState = getRequestOptions(config, defaultOptions || {});\n  currentState.retryCount = currentState.retryCount || 0;\n  currentState.lastRequestTime = currentState.lastRequestTime || Date.now();\n  config[exports.namespace] = currentState;\n  return currentState;\n}\nfunction fixConfig(axiosInstance, config) {\n  // @ts-ignore\n  if (axiosInstance.defaults.agent === config.agent) {\n    // @ts-ignore\n    delete config.agent;\n  }\n  if (axiosInstance.defaults.httpAgent === config.httpAgent) {\n    delete config.httpAgent;\n  }\n  if (axiosInstance.defaults.httpsAgent === config.httpsAgent) {\n    delete config.httpsAgent;\n  }\n}\nfunction shouldRetry(currentState, error) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      retries,\n      retryCondition\n    } = currentState;\n    const shouldRetryOrPromise = (currentState.retryCount || 0) < retries && retryCondition(error);\n    // This could be a promise\n    if (typeof shouldRetryOrPromise === 'object') {\n      try {\n        const shouldRetryPromiseResult = yield shouldRetryOrPromise;\n        // keep return true unless shouldRetryPromiseResult return false for compatibility\n        return shouldRetryPromiseResult !== false;\n      } catch (_err) {\n        return false;\n      }\n    }\n    return shouldRetryOrPromise;\n  });\n}\nconst axiosRetry = (axiosInstance, defaultOptions) => {\n  const requestInterceptorId = axiosInstance.interceptors.request.use(config => {\n    setCurrentState(config, defaultOptions);\n    return config;\n  });\n  const responseInterceptorId = axiosInstance.interceptors.response.use(null, error => __awaiter(void 0, void 0, void 0, function* () {\n    const {\n      config\n    } = error;\n    // If we have no information to retry the request\n    if (!config) {\n      return Promise.reject(error);\n    }\n    const currentState = setCurrentState(config, defaultOptions);\n    if (yield shouldRetry(currentState, error)) {\n      currentState.retryCount += 1;\n      const {\n        retryDelay,\n        shouldResetTimeout,\n        onRetry\n      } = currentState;\n      const delay = retryDelay(currentState.retryCount, error);\n      // Axios fails merging this configuration to the default configuration because it has an issue\n      // with circular structures: https://github.com/mzabriskie/axios/issues/370\n      fixConfig(axiosInstance, config);\n      if (!shouldResetTimeout && config.timeout && currentState.lastRequestTime) {\n        const lastRequestDuration = Date.now() - currentState.lastRequestTime;\n        const timeout = config.timeout - lastRequestDuration - delay;\n        if (timeout <= 0) {\n          return Promise.reject(error);\n        }\n        config.timeout = timeout;\n      }\n      config.transformRequest = [data => data];\n      yield onRetry(currentState.retryCount, error, config);\n      return new Promise(resolve => {\n        setTimeout(() => resolve(axiosInstance(config)), delay);\n      });\n    }\n    return Promise.reject(error);\n  }));\n  return {\n    requestInterceptorId,\n    responseInterceptorId\n  };\n};\n// Compatibility with CommonJS\naxiosRetry.isNetworkError = isNetworkError;\naxiosRetry.isSafeRequestError = isSafeRequestError;\naxiosRetry.isIdempotentRequestError = isIdempotentRequestError;\naxiosRetry.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;\naxiosRetry.exponentialDelay = exponentialDelay;\naxiosRetry.isRetryableError = isRetryableError;\nexports[\"default\"] = axiosRetry;\n\n//# sourceURL=webpack://mytonwallet-lib/./src/lib/axios-retry/index.js?");

/***/ }),

/***/ "./src/lib/big.js/index.js":
/*!*********************************!*\
  !*** ./src/lib/big.js/index.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Big\": () => (/* binding */ Big),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\n *  big.js v6.2.1\n *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.\n *  Copyright (c) 2022 Michael Mclaughlin\n *  https://github.com/MikeMcl/big.js/LICENCE.md\n */\n\n/************************************** EDITABLE DEFAULTS *****************************************/\n\n// The default values below must be integers within the stated ranges.\n\n/*\n * The maximum number of decimal places (DP) of the results of operations involving division:\n * div and sqrt, and pow with negative exponents.\n */\nvar DP = 20,\n  // 0 to MAX_DP\n\n  /*\n   * The rounding mode (RM) used when rounding to the above decimal places.\n   *\n   *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)\n   *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)\n   *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)\n   *  3  Away from zero.                                  (ROUND_UP)\n   */\n  RM = 1,\n  // 0, 1, 2 or 3\n\n  // The maximum value of DP and Big.DP.\n  MAX_DP = 1E6,\n  // 0 to 1000000\n\n  // The maximum magnitude of the exponent argument to the pow method.\n  MAX_POWER = 1E6,\n  // 1 to 1000000\n\n  /*\n   * The negative exponent (NE) at and beneath which toString returns exponential notation.\n   * (JavaScript numbers: -7)\n   * -1000000 is the minimum recommended exponent value of a Big.\n   */\n  NE = -7,\n  // 0 to -1000000\n\n  /*\n   * The positive exponent (PE) at and above which toString returns exponential notation.\n   * (JavaScript numbers: 21)\n   * 1000000 is the maximum recommended exponent value of a Big, but this limit is not enforced.\n   */\n  PE = 21,\n  // 0 to 1000000\n\n  /*\n   * When true, an error will be thrown if a primitive number is passed to the Big constructor,\n   * or if valueOf is called, or if toNumber is called on a Big which cannot be converted to a\n   * primitive number without a loss of precision.\n   */\n  STRICT = false,\n  // true or false\n\n  /**************************************************************************************************/\n\n  // Error messages.\n  NAME = '[big.js] ',\n  INVALID = NAME + 'Invalid ',\n  INVALID_DP = INVALID + 'decimal places',\n  INVALID_RM = INVALID + 'rounding mode',\n  DIV_BY_ZERO = NAME + 'Division by zero',\n  // The shared prototype object.\n  P = {},\n  UNDEFINED = void 0,\n  NUMERIC = /^-?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i;\n\n/*\n * Create and return a Big constructor.\n */\nfunction _Big_() {\n  /*\n   * The Big constructor and exported function.\n   * Create and return a new instance of a Big number object.\n   *\n   * n {number|string|Big} A numeric value.\n   */\n  function Big(n) {\n    var x = this;\n\n    // Enable constructor usage without new.\n    if (!(x instanceof Big)) return n === UNDEFINED ? _Big_() : new Big(n);\n\n    // Duplicate.\n    if (n instanceof Big) {\n      x.s = n.s;\n      x.e = n.e;\n      x.c = n.c.slice();\n    } else {\n      if (typeof n !== 'string') {\n        if (Big.strict === true && typeof n !== 'bigint') {\n          throw TypeError(INVALID + 'value');\n        }\n\n        // Minus zero?\n        n = n === 0 && 1 / n < 0 ? '-0' : String(n);\n      }\n      parse(x, n);\n    }\n\n    // Retain a reference to this Big constructor.\n    // Shadow Big.prototype.constructor which points to Object.\n    x.constructor = Big;\n  }\n  Big.prototype = P;\n  Big.DP = DP;\n  Big.RM = RM;\n  Big.NE = NE;\n  Big.PE = PE;\n  Big.strict = STRICT;\n  Big.roundDown = 0;\n  Big.roundHalfUp = 1;\n  Big.roundHalfEven = 2;\n  Big.roundUp = 3;\n  return Big;\n}\n\n/*\n * Parse the number or string value passed to a Big constructor.\n *\n * x {Big} A Big number instance.\n * n {number|string} A numeric value.\n */\nfunction parse(x, n) {\n  var e, i, nl;\n  if (!NUMERIC.test(n)) {\n    throw Error(INVALID + 'number');\n  }\n\n  // Determine sign.\n  x.s = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;\n\n  // Decimal point?\n  if ((e = n.indexOf('.')) > -1) n = n.replace('.', '');\n\n  // Exponential form?\n  if ((i = n.search(/e/i)) > 0) {\n    // Determine exponent.\n    if (e < 0) e = i;\n    e += +n.slice(i + 1);\n    n = n.substring(0, i);\n  } else if (e < 0) {\n    // Integer.\n    e = n.length;\n  }\n  nl = n.length;\n\n  // Determine leading zeros.\n  for (i = 0; i < nl && n.charAt(i) == '0';) ++i;\n  if (i == nl) {\n    // Zero.\n    x.c = [x.e = 0];\n  } else {\n    // Determine trailing zeros.\n    for (; nl > 0 && n.charAt(--nl) == '0';);\n    x.e = e - i - 1;\n    x.c = [];\n\n    // Convert string to array of digits without leading/trailing zeros.\n    for (e = 0; i <= nl;) x.c[e++] = +n.charAt(i++);\n  }\n  return x;\n}\n\n/*\n * Round Big x to a maximum of sd significant digits using rounding mode rm.\n *\n * x {Big} The Big to round.\n * sd {number} Significant digits: integer, 0 to MAX_DP inclusive.\n * rm {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n * [more] {boolean} Whether the result of division was truncated.\n */\nfunction round(x, sd, rm, more) {\n  var xc = x.c;\n  if (rm === UNDEFINED) rm = x.constructor.RM;\n  if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {\n    throw Error(INVALID_RM);\n  }\n  if (sd < 1) {\n    more = rm === 3 && (more || !!xc[0]) || sd === 0 && (rm === 1 && xc[0] >= 5 || rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED)));\n    xc.length = 1;\n    if (more) {\n      // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n      x.e = x.e - sd + 1;\n      xc[0] = 1;\n    } else {\n      // Zero.\n      xc[0] = x.e = 0;\n    }\n  } else if (sd < xc.length) {\n    // xc[sd] is the digit after the digit that may be rounded up.\n    more = rm === 1 && xc[sd] >= 5 || rm === 2 && (xc[sd] > 5 || xc[sd] === 5 && (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) || rm === 3 && (more || !!xc[0]);\n\n    // Remove any digits after the required precision.\n    xc.length = sd;\n\n    // Round up?\n    if (more) {\n      // Rounding up may mean the previous digit has to be rounded up.\n      for (; ++xc[--sd] > 9;) {\n        xc[sd] = 0;\n        if (sd === 0) {\n          ++x.e;\n          xc.unshift(1);\n          break;\n        }\n      }\n    }\n\n    // Remove trailing zeros.\n    for (sd = xc.length; !xc[--sd];) xc.pop();\n  }\n  return x;\n}\n\n/*\n * Return a string representing the value of Big x in normal or exponential notation.\n * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.\n */\nfunction stringify(x, doExponential, isNonzero) {\n  var e = x.e,\n    s = x.c.join(''),\n    n = s.length;\n\n  // Exponential notation?\n  if (doExponential) {\n    s = s.charAt(0) + (n > 1 ? '.' + s.slice(1) : '') + (e < 0 ? 'e' : 'e+') + e;\n\n    // Normal notation.\n  } else if (e < 0) {\n    for (; ++e;) s = '0' + s;\n    s = '0.' + s;\n  } else if (e > 0) {\n    if (++e > n) {\n      for (e -= n; e--;) s += '0';\n    } else if (e < n) {\n      s = s.slice(0, e) + '.' + s.slice(e);\n    }\n  } else if (n > 1) {\n    s = s.charAt(0) + '.' + s.slice(1);\n  }\n  return x.s < 0 && isNonzero ? '-' + s : s;\n}\n\n// Prototype/instance methods\n\n/*\n * Return a new Big whose value is the absolute value of this Big.\n */\nP.abs = function () {\n  var x = new this.constructor(this);\n  x.s = 1;\n  return x;\n};\n\n/*\n * Return 1 if the value of this Big is greater than the value of Big y,\n *       -1 if the value of this Big is less than the value of Big y, or\n *        0 if they have the same value.\n */\nP.cmp = function (y) {\n  var isneg,\n    x = this,\n    xc = x.c,\n    yc = (y = new x.constructor(y)).c,\n    i = x.s,\n    j = y.s,\n    k = x.e,\n    l = y.e;\n\n  // Either zero?\n  if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;\n\n  // Signs differ?\n  if (i != j) return i;\n  isneg = i < 0;\n\n  // Compare exponents.\n  if (k != l) return k > l ^ isneg ? 1 : -1;\n  j = (k = xc.length) < (l = yc.length) ? k : l;\n\n  // Compare digit by digit.\n  for (i = -1; ++i < j;) {\n    if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;\n  }\n\n  // Compare lengths.\n  return k == l ? 0 : k > l ^ isneg ? 1 : -1;\n};\n\n/*\n * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,\n * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\n */\nP.div = function (y) {\n  var x = this,\n    Big = x.constructor,\n    a = x.c,\n    // dividend\n    b = (y = new Big(y)).c,\n    // divisor\n    k = x.s == y.s ? 1 : -1,\n    dp = Big.DP;\n  if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\n    throw Error(INVALID_DP);\n  }\n\n  // Divisor is zero?\n  if (!b[0]) {\n    throw Error(DIV_BY_ZERO);\n  }\n\n  // Dividend is 0? Return +-0.\n  if (!a[0]) {\n    y.s = k;\n    y.c = [y.e = 0];\n    return y;\n  }\n  var bl,\n    bt,\n    n,\n    cmp,\n    ri,\n    bz = b.slice(),\n    ai = bl = b.length,\n    al = a.length,\n    r = a.slice(0, bl),\n    // remainder\n    rl = r.length,\n    q = y,\n    // quotient\n    qc = q.c = [],\n    qi = 0,\n    p = dp + (q.e = x.e - y.e) + 1; // precision of the result\n\n  q.s = k;\n  k = p < 0 ? 0 : p;\n\n  // Create version of divisor with leading zero.\n  bz.unshift(0);\n\n  // Add zeros to make remainder as long as divisor.\n  for (; rl++ < bl;) r.push(0);\n  do {\n    // n is how many times the divisor goes into current remainder.\n    for (n = 0; n < 10; n++) {\n      // Compare divisor and remainder.\n      if (bl != (rl = r.length)) {\n        cmp = bl > rl ? 1 : -1;\n      } else {\n        for (ri = -1, cmp = 0; ++ri < bl;) {\n          if (b[ri] != r[ri]) {\n            cmp = b[ri] > r[ri] ? 1 : -1;\n            break;\n          }\n        }\n      }\n\n      // If divisor < remainder, subtract divisor from remainder.\n      if (cmp < 0) {\n        // Remainder can't be more than 1 digit longer than divisor.\n        // Equalise lengths using divisor with extra leading zero?\n        for (bt = rl == bl ? b : bz; rl;) {\n          if (r[--rl] < bt[rl]) {\n            ri = rl;\n            for (; ri && !r[--ri];) r[ri] = 9;\n            --r[ri];\n            r[rl] += 10;\n          }\n          r[rl] -= bt[rl];\n        }\n        for (; !r[0];) r.shift();\n      } else {\n        break;\n      }\n    }\n\n    // Add the digit n to the result array.\n    qc[qi++] = cmp ? n : ++n;\n\n    // Update the remainder.\n    if (r[0] && cmp) r[rl] = a[ai] || 0;else r = [a[ai]];\n  } while ((ai++ < al || r[0] !== UNDEFINED) && k--);\n\n  // Leading zero? Do not remove if result is simply zero (qi == 1).\n  if (!qc[0] && qi != 1) {\n    // There can't be more than one zero.\n    qc.shift();\n    q.e--;\n    p--;\n  }\n\n  // Round?\n  if (qi > p) round(q, p, Big.RM, r[0] !== UNDEFINED);\n  return q;\n};\n\n/*\n * Return true if the value of this Big is equal to the value of Big y, otherwise return false.\n */\nP.eq = function (y) {\n  return this.cmp(y) === 0;\n};\n\n/*\n * Return true if the value of this Big is greater than the value of Big y, otherwise return\n * false.\n */\nP.gt = function (y) {\n  return this.cmp(y) > 0;\n};\n\n/*\n * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise\n * return false.\n */\nP.gte = function (y) {\n  return this.cmp(y) > -1;\n};\n\n/*\n * Return true if the value of this Big is less than the value of Big y, otherwise return false.\n */\nP.lt = function (y) {\n  return this.cmp(y) < 0;\n};\n\n/*\n * Return true if the value of this Big is less than or equal to the value of Big y, otherwise\n * return false.\n */\nP.lte = function (y) {\n  return this.cmp(y) < 1;\n};\n\n/*\n * Return a new Big whose value is the value of this Big minus the value of Big y.\n */\nP.minus = P.sub = function (y) {\n  var i,\n    j,\n    t,\n    xlty,\n    x = this,\n    Big = x.constructor,\n    a = x.s,\n    b = (y = new Big(y)).s;\n\n  // Signs differ?\n  if (a != b) {\n    y.s = -b;\n    return x.plus(y);\n  }\n  var xc = x.c.slice(),\n    xe = x.e,\n    yc = y.c,\n    ye = y.e;\n\n  // Either zero?\n  if (!xc[0] || !yc[0]) {\n    if (yc[0]) {\n      y.s = -b;\n    } else if (xc[0]) {\n      y = new Big(x);\n    } else {\n      y.s = 1;\n    }\n    return y;\n  }\n\n  // Determine which is the bigger number. Prepend zeros to equalise exponents.\n  if (a = xe - ye) {\n    if (xlty = a < 0) {\n      a = -a;\n      t = xc;\n    } else {\n      ye = xe;\n      t = yc;\n    }\n    t.reverse();\n    for (b = a; b--;) t.push(0);\n    t.reverse();\n  } else {\n    // Exponents equal. Check digit by digit.\n    j = ((xlty = xc.length < yc.length) ? xc : yc).length;\n    for (a = b = 0; b < j; b++) {\n      if (xc[b] != yc[b]) {\n        xlty = xc[b] < yc[b];\n        break;\n      }\n    }\n  }\n\n  // x < y? Point xc to the array of the bigger number.\n  if (xlty) {\n    t = xc;\n    xc = yc;\n    yc = t;\n    y.s = -y.s;\n  }\n\n  /*\n   * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only\n   * needs to start at yc.length.\n   */\n  if ((b = (j = yc.length) - (i = xc.length)) > 0) for (; b--;) xc[i++] = 0;\n\n  // Subtract yc from xc.\n  for (b = i; j > a;) {\n    if (xc[--j] < yc[j]) {\n      for (i = j; i && !xc[--i];) xc[i] = 9;\n      --xc[i];\n      xc[j] += 10;\n    }\n    xc[j] -= yc[j];\n  }\n\n  // Remove trailing zeros.\n  for (; xc[--b] === 0;) xc.pop();\n\n  // Remove leading zeros and adjust exponent accordingly.\n  for (; xc[0] === 0;) {\n    xc.shift();\n    --ye;\n  }\n  if (!xc[0]) {\n    // n - n = +0\n    y.s = 1;\n\n    // Result must be zero.\n    xc = [ye = 0];\n  }\n  y.c = xc;\n  y.e = ye;\n  return y;\n};\n\n/*\n * Return a new Big whose value is the value of this Big modulo the value of Big y.\n */\nP.mod = function (y) {\n  var ygtx,\n    x = this,\n    Big = x.constructor,\n    a = x.s,\n    b = (y = new Big(y)).s;\n  if (!y.c[0]) {\n    throw Error(DIV_BY_ZERO);\n  }\n  x.s = y.s = 1;\n  ygtx = y.cmp(x) == 1;\n  x.s = a;\n  y.s = b;\n  if (ygtx) return new Big(x);\n  a = Big.DP;\n  b = Big.RM;\n  Big.DP = Big.RM = 0;\n  x = x.div(y);\n  Big.DP = a;\n  Big.RM = b;\n  return this.minus(x.times(y));\n};\n\n/*\n * Return a new Big whose value is the value of this Big negated.\n */\nP.neg = function () {\n  var x = new this.constructor(this);\n  x.s = -x.s;\n  return x;\n};\n\n/*\n * Return a new Big whose value is the value of this Big plus the value of Big y.\n */\nP.plus = P.add = function (y) {\n  var e,\n    k,\n    t,\n    x = this,\n    Big = x.constructor;\n  y = new Big(y);\n\n  // Signs differ?\n  if (x.s != y.s) {\n    y.s = -y.s;\n    return x.minus(y);\n  }\n  var xe = x.e,\n    xc = x.c,\n    ye = y.e,\n    yc = y.c;\n\n  // Either zero?\n  if (!xc[0] || !yc[0]) {\n    if (!yc[0]) {\n      if (xc[0]) {\n        y = new Big(x);\n      } else {\n        y.s = x.s;\n      }\n    }\n    return y;\n  }\n  xc = xc.slice();\n\n  // Prepend zeros to equalise exponents.\n  // Note: reverse faster than unshifts.\n  if (e = xe - ye) {\n    if (e > 0) {\n      ye = xe;\n      t = yc;\n    } else {\n      e = -e;\n      t = xc;\n    }\n    t.reverse();\n    for (; e--;) t.push(0);\n    t.reverse();\n  }\n\n  // Point xc to the longer array.\n  if (xc.length - yc.length < 0) {\n    t = yc;\n    yc = xc;\n    xc = t;\n  }\n  e = yc.length;\n\n  // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.\n  for (k = 0; e; xc[e] %= 10) k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;\n\n  // No need to check for zero, as +x + +y != 0 && -x + -y != 0\n\n  if (k) {\n    xc.unshift(k);\n    ++ye;\n  }\n\n  // Remove trailing zeros.\n  for (e = xc.length; xc[--e] === 0;) xc.pop();\n  y.c = xc;\n  y.e = ye;\n  return y;\n};\n\n/*\n * Return a Big whose value is the value of this Big raised to the power n.\n * If n is negative, round to a maximum of Big.DP decimal places using rounding\n * mode Big.RM.\n *\n * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.\n */\nP.pow = function (n) {\n  var x = this,\n    one = new x.constructor('1'),\n    y = one,\n    isneg = n < 0;\n  if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {\n    throw Error(INVALID + 'exponent');\n  }\n  if (isneg) n = -n;\n  for (;;) {\n    if (n & 1) y = y.times(x);\n    n >>= 1;\n    if (!n) break;\n    x = x.times(x);\n  }\n  return isneg ? one.div(y) : y;\n};\n\n/*\n * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd\n * significant digits using rounding mode rm, or Big.RM if rm is not specified.\n *\n * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n */\nP.prec = function (sd, rm) {\n  if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {\n    throw Error(INVALID + 'precision');\n  }\n  return round(new this.constructor(this), sd, rm);\n};\n\n/*\n * Return a new Big whose value is the value of this Big rounded to a maximum of dp decimal places\n * using rounding mode rm, or Big.RM if rm is not specified.\n * If dp is negative, round to an integer which is a multiple of 10**-dp.\n * If dp is not specified, round to 0 decimal places.\n *\n * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n */\nP.round = function (dp, rm) {\n  if (dp === UNDEFINED) dp = 0;else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {\n    throw Error(INVALID_DP);\n  }\n  return round(new this.constructor(this), dp + this.e + 1, rm);\n};\n\n/*\n * Return a new Big whose value is the square root of the value of this Big, rounded, if\n * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\n */\nP.sqrt = function () {\n  var r,\n    c,\n    t,\n    x = this,\n    Big = x.constructor,\n    s = x.s,\n    e = x.e,\n    half = new Big('0.5');\n\n  // Zero?\n  if (!x.c[0]) return new Big(x);\n\n  // Negative?\n  if (s < 0) {\n    throw Error(NAME + 'No square root');\n  }\n\n  // Estimate.\n  s = Math.sqrt(x + '');\n\n  // Math.sqrt underflow/overflow?\n  // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.\n  if (s === 0 || s === 1 / 0) {\n    c = x.c.join('');\n    if (!(c.length + e & 1)) c += '0';\n    s = Math.sqrt(c);\n    e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);\n    r = new Big((s == 1 / 0 ? '5e' : (s = s.toExponential()).slice(0, s.indexOf('e') + 1)) + e);\n  } else {\n    r = new Big(s + '');\n  }\n  e = r.e + (Big.DP += 4);\n\n  // Newton-Raphson iteration.\n  do {\n    t = r;\n    r = half.times(t.plus(x.div(t)));\n  } while (t.c.slice(0, e).join('') !== r.c.slice(0, e).join(''));\n  return round(r, (Big.DP -= 4) + r.e + 1, Big.RM);\n};\n\n/*\n * Return a new Big whose value is the value of this Big times the value of Big y.\n */\nP.times = P.mul = function (y) {\n  var c,\n    x = this,\n    Big = x.constructor,\n    xc = x.c,\n    yc = (y = new Big(y)).c,\n    a = xc.length,\n    b = yc.length,\n    i = x.e,\n    j = y.e;\n\n  // Determine sign of result.\n  y.s = x.s == y.s ? 1 : -1;\n\n  // Return signed 0 if either 0.\n  if (!xc[0] || !yc[0]) {\n    y.c = [y.e = 0];\n    return y;\n  }\n\n  // Initialise exponent of result as x.e + y.e.\n  y.e = i + j;\n\n  // If array xc has fewer digits than yc, swap xc and yc, and lengths.\n  if (a < b) {\n    c = xc;\n    xc = yc;\n    yc = c;\n    j = a;\n    a = b;\n    b = j;\n  }\n\n  // Initialise coefficient array of result with zeros.\n  for (c = new Array(j = a + b); j--;) c[j] = 0;\n\n  // Multiply.\n\n  // i is initially xc.length.\n  for (i = b; i--;) {\n    b = 0;\n\n    // a is yc.length.\n    for (j = a + i; j > i;) {\n      // Current sum of products at this digit position, plus carry.\n      b = c[j] + yc[i] * xc[j - i - 1] + b;\n      c[j--] = b % 10;\n\n      // carry\n      b = b / 10 | 0;\n    }\n    c[j] = b;\n  }\n\n  // Increment result exponent if there is a final carry, otherwise remove leading zero.\n  if (b) ++y.e;else c.shift();\n\n  // Remove trailing zeros.\n  for (i = c.length; !c[--i];) c.pop();\n  y.c = c;\n  return y;\n};\n\n/*\n * Return a string representing the value of this Big in exponential notation rounded to dp fixed\n * decimal places using rounding mode rm, or Big.RM if rm is not specified.\n *\n * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n */\nP.toExponential = function (dp, rm) {\n  var x = this,\n    n = x.c[0];\n  if (dp !== UNDEFINED) {\n    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\n      throw Error(INVALID_DP);\n    }\n    x = round(new x.constructor(x), ++dp, rm);\n    for (; x.c.length < dp;) x.c.push(0);\n  }\n  return stringify(x, true, !!n);\n};\n\n/*\n * Return a string representing the value of this Big in normal notation rounded to dp fixed\n * decimal places using rounding mode rm, or Big.RM if rm is not specified.\n *\n * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n *\n * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\n * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\n */\nP.toFixed = function (dp, rm) {\n  var x = this,\n    n = x.c[0];\n  if (dp !== UNDEFINED) {\n    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\n      throw Error(INVALID_DP);\n    }\n    x = round(new x.constructor(x), dp + x.e + 1, rm);\n\n    // x.e may have changed if the value is rounded up.\n    for (dp = dp + x.e + 1; x.c.length < dp;) x.c.push(0);\n  }\n  return stringify(x, false, !!n);\n};\n\n/*\n * Return a string representing the value of this Big.\n * Return exponential notation if this Big has a positive exponent equal to or greater than\n * Big.PE, or a negative exponent equal to or less than Big.NE.\n * Omit the sign for negative zero.\n */\nP[Symbol.for('nodejs.util.inspect.custom')] = P.toJSON = P.toString = function () {\n  var x = this,\n    Big = x.constructor;\n  return stringify(x, x.e <= Big.NE || x.e >= Big.PE, !!x.c[0]);\n};\n\n/*\n * Return the value of this Big as a primitve number.\n */\nP.toNumber = function () {\n  var n = Number(stringify(this, true, true));\n  if (this.constructor.strict === true && !this.eq(n.toString())) {\n    throw Error(NAME + 'Imprecise conversion');\n  }\n  return n;\n};\n\n/*\n * Return a string representing the value of this Big rounded to sd significant digits using\n * rounding mode rm, or Big.RM if rm is not specified.\n * Use exponential notation if sd is less than the number of digits necessary to represent\n * the integer part of the value in normal notation.\n *\n * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n */\nP.toPrecision = function (sd, rm) {\n  var x = this,\n    Big = x.constructor,\n    n = x.c[0];\n  if (sd !== UNDEFINED) {\n    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {\n      throw Error(INVALID + 'precision');\n    }\n    x = round(new Big(x), sd, rm);\n    for (; x.c.length < sd;) x.c.push(0);\n  }\n  return stringify(x, sd <= x.e || x.e <= Big.NE || x.e >= Big.PE, !!n);\n};\n\n/*\n * Return a string representing the value of this Big.\n * Return exponential notation if this Big has a positive exponent equal to or greater than\n * Big.PE, or a negative exponent equal to or less than Big.NE.\n * Include the sign for negative zero.\n */\nP.valueOf = function () {\n  var x = this,\n    Big = x.constructor;\n  if (Big.strict === true) {\n    throw Error(NAME + 'valueOf disallowed');\n  }\n  return stringify(x, x.e <= Big.NE || x.e >= Big.PE, true);\n};\n\n// Export\n\nvar Big = _Big_();\n\n/// <reference types=\"https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/master/types/big.js/index.d.ts\" />\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Big);\n\n//# sourceURL=webpack://mytonwallet-lib/./src/lib/big.js/index.js?");

/***/ }),

/***/ "./src/lib/dexie/dexie.js":
/*!********************************!*\
  !*** ./src/lib/dexie/dexie.js ***!
  \********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 3.2.4, Tue May 30 2023\n *\n * https://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */\n\n(function (global, factory) {\n   true ? module.exports = factory() : 0;\n})(this, function () {\n  'use strict';\n\n  /*! *****************************************************************************\n  Copyright (c) Microsoft Corporation.\n  Permission to use, copy, modify, and/or distribute this software for any\n  purpose with or without fee is hereby granted.\n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n  PERFORMANCE OF THIS SOFTWARE.\n  ***************************************************************************** */\n  var __assign = function () {\n    __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n    };\n    return __assign.apply(this, arguments);\n  };\n  function __spreadArray(to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n        if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n        ar[i] = from[i];\n      }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n  }\n  var _global = typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : __webpack_require__.g;\n  var keys = Object.keys;\n  var isArray = Array.isArray;\n  if (typeof Promise !== 'undefined' && !_global.Promise) {\n    _global.Promise = Promise;\n  }\n  function extend(obj, extension) {\n    if (typeof extension !== 'object') return obj;\n    keys(extension).forEach(function (key) {\n      obj[key] = extension[key];\n    });\n    return obj;\n  }\n  var getProto = Object.getPrototypeOf;\n  var _hasOwn = {}.hasOwnProperty;\n  function hasOwn(obj, prop) {\n    return _hasOwn.call(obj, prop);\n  }\n  function props(proto, extension) {\n    if (typeof extension === 'function') extension = extension(getProto(proto));\n    (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach(function (key) {\n      setProp(proto, key, extension[key]);\n    });\n  }\n  var defineProperty = Object.defineProperty;\n  function setProp(obj, prop, functionOrGetSet, options) {\n    defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ? {\n      get: functionOrGetSet.get,\n      set: functionOrGetSet.set,\n      configurable: true\n    } : {\n      value: functionOrGetSet,\n      configurable: true,\n      writable: true\n    }, options));\n  }\n  function derive(Child) {\n    return {\n      from: function (Parent) {\n        Child.prototype = Object.create(Parent.prototype);\n        setProp(Child.prototype, \"constructor\", Child);\n        return {\n          extend: props.bind(null, Child.prototype)\n        };\n      }\n    };\n  }\n  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n  function getPropertyDescriptor(obj, prop) {\n    var pd = getOwnPropertyDescriptor(obj, prop);\n    var proto;\n    return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n  }\n  var _slice = [].slice;\n  function slice(args, start, end) {\n    return _slice.call(args, start, end);\n  }\n  function override(origFunc, overridedFactory) {\n    return overridedFactory(origFunc);\n  }\n  function assert(b) {\n    if (!b) throw new Error(\"Assertion Failed\");\n  }\n  function asap$1(fn) {\n    if (_global.setImmediate) setImmediate(fn);else setTimeout(fn, 0);\n  }\n  function arrayToObject(array, extractor) {\n    return array.reduce(function (result, item, i) {\n      var nameAndValue = extractor(item, i);\n      if (nameAndValue) result[nameAndValue[0]] = nameAndValue[1];\n      return result;\n    }, {});\n  }\n  function tryCatch(fn, onerror, args) {\n    try {\n      fn.apply(null, args);\n    } catch (ex) {\n      onerror && onerror(ex);\n    }\n  }\n  function getByKeyPath(obj, keyPath) {\n    if (hasOwn(obj, keyPath)) return obj[keyPath];\n    if (!keyPath) return obj;\n    if (typeof keyPath !== 'string') {\n      var rv = [];\n      for (var i = 0, l = keyPath.length; i < l; ++i) {\n        var val = getByKeyPath(obj, keyPath[i]);\n        rv.push(val);\n      }\n      return rv;\n    }\n    var period = keyPath.indexOf('.');\n    if (period !== -1) {\n      var innerObj = obj[keyPath.substr(0, period)];\n      return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n    }\n    return undefined;\n  }\n  function setByKeyPath(obj, keyPath, value) {\n    if (!obj || keyPath === undefined) return;\n    if ('isFrozen' in Object && Object.isFrozen(obj)) return;\n    if (typeof keyPath !== 'string' && 'length' in keyPath) {\n      assert(typeof value !== 'string' && 'length' in value);\n      for (var i = 0, l = keyPath.length; i < l; ++i) {\n        setByKeyPath(obj, keyPath[i], value[i]);\n      }\n    } else {\n      var period = keyPath.indexOf('.');\n      if (period !== -1) {\n        var currentKeyPath = keyPath.substr(0, period);\n        var remainingKeyPath = keyPath.substr(period + 1);\n        if (remainingKeyPath === \"\") {\n          if (value === undefined) {\n            if (isArray(obj) && !isNaN(parseInt(currentKeyPath))) obj.splice(currentKeyPath, 1);else delete obj[currentKeyPath];\n          } else obj[currentKeyPath] = value;\n        } else {\n          var innerObj = obj[currentKeyPath];\n          if (!innerObj || !hasOwn(obj, currentKeyPath)) innerObj = obj[currentKeyPath] = {};\n          setByKeyPath(innerObj, remainingKeyPath, value);\n        }\n      } else {\n        if (value === undefined) {\n          if (isArray(obj) && !isNaN(parseInt(keyPath))) obj.splice(keyPath, 1);else delete obj[keyPath];\n        } else obj[keyPath] = value;\n      }\n    }\n  }\n  function delByKeyPath(obj, keyPath) {\n    if (typeof keyPath === 'string') setByKeyPath(obj, keyPath, undefined);else if ('length' in keyPath) [].map.call(keyPath, function (kp) {\n      setByKeyPath(obj, kp, undefined);\n    });\n  }\n  function shallowClone(obj) {\n    var rv = {};\n    for (var m in obj) {\n      if (hasOwn(obj, m)) rv[m] = obj[m];\n    }\n    return rv;\n  }\n  var concat = [].concat;\n  function flatten(a) {\n    return concat.apply([], a);\n  }\n  var intrinsicTypeNames = \"Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\".split(',').concat(flatten([8, 16, 32, 64].map(function (num) {\n    return [\"Int\", \"Uint\", \"Float\"].map(function (t) {\n      return t + num + \"Array\";\n    });\n  }))).filter(function (t) {\n    return _global[t];\n  });\n  var intrinsicTypes = intrinsicTypeNames.map(function (t) {\n    return _global[t];\n  });\n  arrayToObject(intrinsicTypeNames, function (x) {\n    return [x, true];\n  });\n  var circularRefs = null;\n  function deepClone(any) {\n    circularRefs = typeof WeakMap !== 'undefined' && new WeakMap();\n    var rv = innerDeepClone(any);\n    circularRefs = null;\n    return rv;\n  }\n  function innerDeepClone(any) {\n    if (!any || typeof any !== 'object') return any;\n    var rv = circularRefs && circularRefs.get(any);\n    if (rv) return rv;\n    if (isArray(any)) {\n      rv = [];\n      circularRefs && circularRefs.set(any, rv);\n      for (var i = 0, l = any.length; i < l; ++i) {\n        rv.push(innerDeepClone(any[i]));\n      }\n    } else if (intrinsicTypes.indexOf(any.constructor) >= 0) {\n      rv = any;\n    } else {\n      var proto = getProto(any);\n      rv = proto === Object.prototype ? {} : Object.create(proto);\n      circularRefs && circularRefs.set(any, rv);\n      for (var prop in any) {\n        if (hasOwn(any, prop)) {\n          rv[prop] = innerDeepClone(any[prop]);\n        }\n      }\n    }\n    return rv;\n  }\n  var toString = {}.toString;\n  function toStringTag(o) {\n    return toString.call(o).slice(8, -1);\n  }\n  var iteratorSymbol = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';\n  var getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function (x) {\n    var i;\n    return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n  } : function () {\n    return null;\n  };\n  var NO_CHAR_ARRAY = {};\n  function getArrayOf(arrayLike) {\n    var i, a, x, it;\n    if (arguments.length === 1) {\n      if (isArray(arrayLike)) return arrayLike.slice();\n      if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string') return [arrayLike];\n      if (it = getIteratorOf(arrayLike)) {\n        a = [];\n        while (x = it.next(), !x.done) a.push(x.value);\n        return a;\n      }\n      if (arrayLike == null) return [arrayLike];\n      i = arrayLike.length;\n      if (typeof i === 'number') {\n        a = new Array(i);\n        while (i--) a[i] = arrayLike[i];\n        return a;\n      }\n      return [arrayLike];\n    }\n    i = arguments.length;\n    a = new Array(i);\n    while (i--) a[i] = arguments[i];\n    return a;\n  }\n  var isAsyncFunction = typeof Symbol !== 'undefined' ? function (fn) {\n    return fn[Symbol.toStringTag] === 'AsyncFunction';\n  } : function () {\n    return false;\n  };\n  var debug = typeof location !== 'undefined' && /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\n  function setDebug(value, filter) {\n    debug = value;\n    libraryFilter = filter;\n  }\n  var libraryFilter = function () {\n    return true;\n  };\n  var NEEDS_THROW_FOR_STACK = !new Error(\"\").stack;\n  function getErrorWithStack() {\n    if (NEEDS_THROW_FOR_STACK) try {\n      getErrorWithStack.arguments;\n      throw new Error();\n    } catch (e) {\n      return e;\n    }\n    return new Error();\n  }\n  function prettyStack(exception, numIgnoredFrames) {\n    var stack = exception.stack;\n    if (!stack) return \"\";\n    numIgnoredFrames = numIgnoredFrames || 0;\n    if (stack.indexOf(exception.name) === 0) numIgnoredFrames += (exception.name + exception.message).split('\\n').length;\n    return stack.split('\\n').slice(numIgnoredFrames).filter(libraryFilter).map(function (frame) {\n      return \"\\n\" + frame;\n    }).join('');\n  }\n  var dexieErrorNames = ['Modify', 'Bulk', 'OpenFailed', 'VersionChange', 'Schema', 'Upgrade', 'InvalidTable', 'MissingAPI', 'NoSuchDatabase', 'InvalidArgument', 'SubTransaction', 'Unsupported', 'Internal', 'DatabaseClosed', 'PrematureCommit', 'ForeignAwait'];\n  var idbDomErrorNames = ['Unknown', 'Constraint', 'Data', 'TransactionInactive', 'ReadOnly', 'Version', 'NotFound', 'InvalidState', 'InvalidAccess', 'Abort', 'Timeout', 'QuotaExceeded', 'Syntax', 'DataClone'];\n  var errorList = dexieErrorNames.concat(idbDomErrorNames);\n  var defaultTexts = {\n    VersionChanged: \"Database version changed by other database connection\",\n    DatabaseClosed: \"Database has been closed\",\n    Abort: \"Transaction aborted\",\n    TransactionInactive: \"Transaction has already completed or failed\",\n    MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n  };\n  function DexieError(name, msg) {\n    this._e = getErrorWithStack();\n    this.name = name;\n    this.message = msg;\n  }\n  derive(DexieError).from(Error).extend({\n    stack: {\n      get: function () {\n        return this._stack || (this._stack = this.name + \": \" + this.message + prettyStack(this._e, 2));\n      }\n    },\n    toString: function () {\n      return this.name + \": \" + this.message;\n    }\n  });\n  function getMultiErrorMessage(msg, failures) {\n    return msg + \". Errors: \" + Object.keys(failures).map(function (key) {\n      return failures[key].toString();\n    }).filter(function (v, i, s) {\n      return s.indexOf(v) === i;\n    }).join('\\n');\n  }\n  function ModifyError(msg, failures, successCount, failedKeys) {\n    this._e = getErrorWithStack();\n    this.failures = failures;\n    this.failedKeys = failedKeys;\n    this.successCount = successCount;\n    this.message = getMultiErrorMessage(msg, failures);\n  }\n  derive(ModifyError).from(DexieError);\n  function BulkError(msg, failures) {\n    this._e = getErrorWithStack();\n    this.name = \"BulkError\";\n    this.failures = Object.keys(failures).map(function (pos) {\n      return failures[pos];\n    });\n    this.failuresByPos = failures;\n    this.message = getMultiErrorMessage(msg, failures);\n  }\n  derive(BulkError).from(DexieError);\n  var errnames = errorList.reduce(function (obj, name) {\n    return obj[name] = name + \"Error\", obj;\n  }, {});\n  var BaseException = DexieError;\n  var exceptions = errorList.reduce(function (obj, name) {\n    var fullName = name + \"Error\";\n    function DexieError(msgOrInner, inner) {\n      this._e = getErrorWithStack();\n      this.name = fullName;\n      if (!msgOrInner) {\n        this.message = defaultTexts[name] || fullName;\n        this.inner = null;\n      } else if (typeof msgOrInner === 'string') {\n        this.message = \"\" + msgOrInner + (!inner ? '' : '\\n ' + inner);\n        this.inner = inner || null;\n      } else if (typeof msgOrInner === 'object') {\n        this.message = msgOrInner.name + \" \" + msgOrInner.message;\n        this.inner = msgOrInner;\n      }\n    }\n    derive(DexieError).from(BaseException);\n    obj[name] = DexieError;\n    return obj;\n  }, {});\n  exceptions.Syntax = SyntaxError;\n  exceptions.Type = TypeError;\n  exceptions.Range = RangeError;\n  var exceptionMap = idbDomErrorNames.reduce(function (obj, name) {\n    obj[name + \"Error\"] = exceptions[name];\n    return obj;\n  }, {});\n  function mapError(domError, message) {\n    if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name]) return domError;\n    var rv = new exceptionMap[domError.name](message || domError.message, domError);\n    if (\"stack\" in domError) {\n      setProp(rv, \"stack\", {\n        get: function () {\n          return this.inner.stack;\n        }\n      });\n    }\n    return rv;\n  }\n  var fullNameExceptions = errorList.reduce(function (obj, name) {\n    if ([\"Syntax\", \"Type\", \"Range\"].indexOf(name) === -1) obj[name + \"Error\"] = exceptions[name];\n    return obj;\n  }, {});\n  fullNameExceptions.ModifyError = ModifyError;\n  fullNameExceptions.DexieError = DexieError;\n  fullNameExceptions.BulkError = BulkError;\n  function nop() {}\n  function mirror(val) {\n    return val;\n  }\n  function pureFunctionChain(f1, f2) {\n    if (f1 == null || f1 === mirror) return f2;\n    return function (val) {\n      return f2(f1(val));\n    };\n  }\n  function callBoth(on1, on2) {\n    return function () {\n      on1.apply(this, arguments);\n      on2.apply(this, arguments);\n    };\n  }\n  function hookCreatingChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function () {\n      var res = f1.apply(this, arguments);\n      if (res !== undefined) arguments[0] = res;\n      var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n      this.onsuccess = null;\n      this.onerror = null;\n      var res2 = f2.apply(this, arguments);\n      if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n      if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n      return res2 !== undefined ? res2 : res;\n    };\n  }\n  function hookDeletingChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function () {\n      f1.apply(this, arguments);\n      var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n      this.onsuccess = this.onerror = null;\n      f2.apply(this, arguments);\n      if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n      if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    };\n  }\n  function hookUpdatingChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function (modifications) {\n      var res = f1.apply(this, arguments);\n      extend(modifications, res);\n      var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n      this.onsuccess = null;\n      this.onerror = null;\n      var res2 = f2.apply(this, arguments);\n      if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n      if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n      return res === undefined ? res2 === undefined ? undefined : res2 : extend(res, res2);\n    };\n  }\n  function reverseStoppableEventChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function () {\n      if (f2.apply(this, arguments) === false) return false;\n      return f1.apply(this, arguments);\n    };\n  }\n  function promisableChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function () {\n      var res = f1.apply(this, arguments);\n      if (res && typeof res.then === 'function') {\n        var thiz = this,\n          i = arguments.length,\n          args = new Array(i);\n        while (i--) args[i] = arguments[i];\n        return res.then(function () {\n          return f2.apply(thiz, args);\n        });\n      }\n      return f2.apply(this, arguments);\n    };\n  }\n  var INTERNAL = {};\n  var LONG_STACKS_CLIP_LIMIT = 100,\n    MAX_LONG_STACKS = 20,\n    ZONE_ECHO_LIMIT = 100,\n    _a$1 = typeof Promise === 'undefined' ? [] : function () {\n      var globalP = Promise.resolve();\n      if (typeof crypto === 'undefined' || !crypto.subtle) return [globalP, getProto(globalP), globalP];\n      var nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n      return [nativeP, getProto(nativeP), globalP];\n    }(),\n    resolvedNativePromise = _a$1[0],\n    nativePromiseProto = _a$1[1],\n    resolvedGlobalPromise = _a$1[2],\n    nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\n  var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\n  var patchGlobalPromise = !!resolvedGlobalPromise;\n  var stack_being_generated = false;\n  var schedulePhysicalTick = resolvedGlobalPromise ? function () {\n    resolvedGlobalPromise.then(physicalTick);\n  } : _global.setImmediate ? setImmediate.bind(null, physicalTick) : _global.MutationObserver ? function () {\n    var hiddenDiv = document.createElement(\"div\");\n    new MutationObserver(function () {\n      physicalTick();\n      hiddenDiv = null;\n    }).observe(hiddenDiv, {\n      attributes: true\n    });\n    hiddenDiv.setAttribute('i', '1');\n  } : function () {\n    setTimeout(physicalTick, 0);\n  };\n  var asap = function (callback, args) {\n    microtickQueue.push([callback, args]);\n    if (needsNewPhysicalTick) {\n      schedulePhysicalTick();\n      needsNewPhysicalTick = false;\n    }\n  };\n  var isOutsideMicroTick = true,\n    needsNewPhysicalTick = true,\n    unhandledErrors = [],\n    rejectingErrors = [],\n    currentFulfiller = null,\n    rejectionMapper = mirror;\n  var globalPSD = {\n    id: 'global',\n    global: true,\n    ref: 0,\n    unhandleds: [],\n    onunhandled: globalError,\n    pgp: false,\n    env: {},\n    finalize: function () {\n      this.unhandleds.forEach(function (uh) {\n        try {\n          globalError(uh[0], uh[1]);\n        } catch (e) {}\n      });\n    }\n  };\n  var PSD = globalPSD;\n  var microtickQueue = [];\n  var numScheduledCalls = 0;\n  var tickFinalizers = [];\n  function DexiePromise(fn) {\n    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');\n    this._listeners = [];\n    this.onuncatched = nop;\n    this._lib = false;\n    var psd = this._PSD = PSD;\n    if (debug) {\n      this._stackHolder = getErrorWithStack();\n      this._prev = null;\n      this._numPrev = 0;\n    }\n    if (typeof fn !== 'function') {\n      if (fn !== INTERNAL) throw new TypeError('Not a function');\n      this._state = arguments[1];\n      this._value = arguments[2];\n      if (this._state === false) handleRejection(this, this._value);\n      return;\n    }\n    this._state = null;\n    this._value = null;\n    ++psd.ref;\n    executePromiseTask(this, fn);\n  }\n  var thenProp = {\n    get: function () {\n      var psd = PSD,\n        microTaskId = totalEchoes;\n      function then(onFulfilled, onRejected) {\n        var _this = this;\n        var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n        var cleanup = possibleAwait && !decrementExpectedAwaits();\n        var rv = new DexiePromise(function (resolve, reject) {\n          propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n        });\n        debug && linkToPreviousPromise(rv, this);\n        return rv;\n      }\n      then.prototype = INTERNAL;\n      return then;\n    },\n    set: function (value) {\n      setProp(this, 'then', value && value.prototype === INTERNAL ? thenProp : {\n        get: function () {\n          return value;\n        },\n        set: thenProp.set\n      });\n    }\n  };\n  props(DexiePromise.prototype, {\n    then: thenProp,\n    _then: function (onFulfilled, onRejected) {\n      propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n    },\n    catch: function (onRejected) {\n      if (arguments.length === 1) return this.then(null, onRejected);\n      var type = arguments[0],\n        handler = arguments[1];\n      return typeof type === 'function' ? this.then(null, function (err) {\n        return err instanceof type ? handler(err) : PromiseReject(err);\n      }) : this.then(null, function (err) {\n        return err && err.name === type ? handler(err) : PromiseReject(err);\n      });\n    },\n    finally: function (onFinally) {\n      return this.then(function (value) {\n        onFinally();\n        return value;\n      }, function (err) {\n        onFinally();\n        return PromiseReject(err);\n      });\n    },\n    stack: {\n      get: function () {\n        if (this._stack) return this._stack;\n        try {\n          stack_being_generated = true;\n          var stacks = getStack(this, [], MAX_LONG_STACKS);\n          var stack = stacks.join(\"\\nFrom previous: \");\n          if (this._state !== null) this._stack = stack;\n          return stack;\n        } finally {\n          stack_being_generated = false;\n        }\n      }\n    },\n    timeout: function (ms, msg) {\n      var _this = this;\n      return ms < Infinity ? new DexiePromise(function (resolve, reject) {\n        var handle = setTimeout(function () {\n          return reject(new exceptions.Timeout(msg));\n        }, ms);\n        _this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n      }) : this;\n    }\n  });\n  if (typeof Symbol !== 'undefined' && Symbol.toStringTag) setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');\n  globalPSD.env = snapShot();\n  function Listener(onFulfilled, onRejected, resolve, reject, zone) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.resolve = resolve;\n    this.reject = reject;\n    this.psd = zone;\n  }\n  props(DexiePromise, {\n    all: function () {\n      var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n      return new DexiePromise(function (resolve, reject) {\n        if (values.length === 0) resolve([]);\n        var remaining = values.length;\n        values.forEach(function (a, i) {\n          return DexiePromise.resolve(a).then(function (x) {\n            values[i] = x;\n            if (! --remaining) resolve(values);\n          }, reject);\n        });\n      });\n    },\n    resolve: function (value) {\n      if (value instanceof DexiePromise) return value;\n      if (value && typeof value.then === 'function') return new DexiePromise(function (resolve, reject) {\n        value.then(resolve, reject);\n      });\n      var rv = new DexiePromise(INTERNAL, true, value);\n      linkToPreviousPromise(rv, currentFulfiller);\n      return rv;\n    },\n    reject: PromiseReject,\n    race: function () {\n      var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n      return new DexiePromise(function (resolve, reject) {\n        values.map(function (value) {\n          return DexiePromise.resolve(value).then(resolve, reject);\n        });\n      });\n    },\n    PSD: {\n      get: function () {\n        return PSD;\n      },\n      set: function (value) {\n        return PSD = value;\n      }\n    },\n    totalEchoes: {\n      get: function () {\n        return totalEchoes;\n      }\n    },\n    newPSD: newScope,\n    usePSD: usePSD,\n    scheduler: {\n      get: function () {\n        return asap;\n      },\n      set: function (value) {\n        asap = value;\n      }\n    },\n    rejectionMapper: {\n      get: function () {\n        return rejectionMapper;\n      },\n      set: function (value) {\n        rejectionMapper = value;\n      }\n    },\n    follow: function (fn, zoneProps) {\n      return new DexiePromise(function (resolve, reject) {\n        return newScope(function (resolve, reject) {\n          var psd = PSD;\n          psd.unhandleds = [];\n          psd.onunhandled = reject;\n          psd.finalize = callBoth(function () {\n            var _this = this;\n            run_at_end_of_this_or_next_physical_tick(function () {\n              _this.unhandleds.length === 0 ? resolve() : reject(_this.unhandleds[0]);\n            });\n          }, psd.finalize);\n          fn();\n        }, zoneProps, resolve, reject);\n      });\n    }\n  });\n  if (NativePromise) {\n    if (NativePromise.allSettled) setProp(DexiePromise, \"allSettled\", function () {\n      var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n      return new DexiePromise(function (resolve) {\n        if (possiblePromises.length === 0) resolve([]);\n        var remaining = possiblePromises.length;\n        var results = new Array(remaining);\n        possiblePromises.forEach(function (p, i) {\n          return DexiePromise.resolve(p).then(function (value) {\n            return results[i] = {\n              status: \"fulfilled\",\n              value: value\n            };\n          }, function (reason) {\n            return results[i] = {\n              status: \"rejected\",\n              reason: reason\n            };\n          }).then(function () {\n            return --remaining || resolve(results);\n          });\n        });\n      });\n    });\n    if (NativePromise.any && typeof AggregateError !== 'undefined') setProp(DexiePromise, \"any\", function () {\n      var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n      return new DexiePromise(function (resolve, reject) {\n        if (possiblePromises.length === 0) reject(new AggregateError([]));\n        var remaining = possiblePromises.length;\n        var failures = new Array(remaining);\n        possiblePromises.forEach(function (p, i) {\n          return DexiePromise.resolve(p).then(function (value) {\n            return resolve(value);\n          }, function (failure) {\n            failures[i] = failure;\n            if (! --remaining) reject(new AggregateError(failures));\n          });\n        });\n      });\n    });\n  }\n  function executePromiseTask(promise, fn) {\n    try {\n      fn(function (value) {\n        if (promise._state !== null) return;\n        if (value === promise) throw new TypeError('A promise cannot be resolved with itself.');\n        var shouldExecuteTick = promise._lib && beginMicroTickScope();\n        if (value && typeof value.then === 'function') {\n          executePromiseTask(promise, function (resolve, reject) {\n            value instanceof DexiePromise ? value._then(resolve, reject) : value.then(resolve, reject);\n          });\n        } else {\n          promise._state = true;\n          promise._value = value;\n          propagateAllListeners(promise);\n        }\n        if (shouldExecuteTick) endMicroTickScope();\n      }, handleRejection.bind(null, promise));\n    } catch (ex) {\n      handleRejection(promise, ex);\n    }\n  }\n  function handleRejection(promise, reason) {\n    rejectingErrors.push(reason);\n    if (promise._state !== null) return;\n    var shouldExecuteTick = promise._lib && beginMicroTickScope();\n    reason = rejectionMapper(reason);\n    promise._state = false;\n    promise._value = reason;\n    debug && reason !== null && typeof reason === 'object' && !reason._promise && tryCatch(function () {\n      var origProp = getPropertyDescriptor(reason, \"stack\");\n      reason._promise = promise;\n      setProp(reason, \"stack\", {\n        get: function () {\n          return stack_being_generated ? origProp && (origProp.get ? origProp.get.apply(reason) : origProp.value) : promise.stack;\n        }\n      });\n    });\n    addPossiblyUnhandledError(promise);\n    propagateAllListeners(promise);\n    if (shouldExecuteTick) endMicroTickScope();\n  }\n  function propagateAllListeners(promise) {\n    var listeners = promise._listeners;\n    promise._listeners = [];\n    for (var i = 0, len = listeners.length; i < len; ++i) {\n      propagateToListener(promise, listeners[i]);\n    }\n    var psd = promise._PSD;\n    --psd.ref || psd.finalize();\n    if (numScheduledCalls === 0) {\n      ++numScheduledCalls;\n      asap(function () {\n        if (--numScheduledCalls === 0) finalizePhysicalTick();\n      }, []);\n    }\n  }\n  function propagateToListener(promise, listener) {\n    if (promise._state === null) {\n      promise._listeners.push(listener);\n      return;\n    }\n    var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n    if (cb === null) {\n      return (promise._state ? listener.resolve : listener.reject)(promise._value);\n    }\n    ++listener.psd.ref;\n    ++numScheduledCalls;\n    asap(callListener, [cb, promise, listener]);\n  }\n  function callListener(cb, promise, listener) {\n    try {\n      currentFulfiller = promise;\n      var ret,\n        value = promise._value;\n      if (promise._state) {\n        ret = cb(value);\n      } else {\n        if (rejectingErrors.length) rejectingErrors = [];\n        ret = cb(value);\n        if (rejectingErrors.indexOf(value) === -1) markErrorAsHandled(promise);\n      }\n      listener.resolve(ret);\n    } catch (e) {\n      listener.reject(e);\n    } finally {\n      currentFulfiller = null;\n      if (--numScheduledCalls === 0) finalizePhysicalTick();\n      --listener.psd.ref || listener.psd.finalize();\n    }\n  }\n  function getStack(promise, stacks, limit) {\n    if (stacks.length === limit) return stacks;\n    var stack = \"\";\n    if (promise._state === false) {\n      var failure = promise._value,\n        errorName,\n        message;\n      if (failure != null) {\n        errorName = failure.name || \"Error\";\n        message = failure.message || failure;\n        stack = prettyStack(failure, 0);\n      } else {\n        errorName = failure;\n        message = \"\";\n      }\n      stacks.push(errorName + (message ? \": \" + message : \"\") + stack);\n    }\n    if (debug) {\n      stack = prettyStack(promise._stackHolder, 2);\n      if (stack && stacks.indexOf(stack) === -1) stacks.push(stack);\n      if (promise._prev) getStack(promise._prev, stacks, limit);\n    }\n    return stacks;\n  }\n  function linkToPreviousPromise(promise, prev) {\n    var numPrev = prev ? prev._numPrev + 1 : 0;\n    if (numPrev < LONG_STACKS_CLIP_LIMIT) {\n      promise._prev = prev;\n      promise._numPrev = numPrev;\n    }\n  }\n  function physicalTick() {\n    beginMicroTickScope() && endMicroTickScope();\n  }\n  function beginMicroTickScope() {\n    var wasRootExec = isOutsideMicroTick;\n    isOutsideMicroTick = false;\n    needsNewPhysicalTick = false;\n    return wasRootExec;\n  }\n  function endMicroTickScope() {\n    var callbacks, i, l;\n    do {\n      while (microtickQueue.length > 0) {\n        callbacks = microtickQueue;\n        microtickQueue = [];\n        l = callbacks.length;\n        for (i = 0; i < l; ++i) {\n          var item = callbacks[i];\n          item[0].apply(null, item[1]);\n        }\n      }\n    } while (microtickQueue.length > 0);\n    isOutsideMicroTick = true;\n    needsNewPhysicalTick = true;\n  }\n  function finalizePhysicalTick() {\n    var unhandledErrs = unhandledErrors;\n    unhandledErrors = [];\n    unhandledErrs.forEach(function (p) {\n      p._PSD.onunhandled.call(null, p._value, p);\n    });\n    var finalizers = tickFinalizers.slice(0);\n    var i = finalizers.length;\n    while (i) finalizers[--i]();\n  }\n  function run_at_end_of_this_or_next_physical_tick(fn) {\n    function finalizer() {\n      fn();\n      tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n    }\n    tickFinalizers.push(finalizer);\n    ++numScheduledCalls;\n    asap(function () {\n      if (--numScheduledCalls === 0) finalizePhysicalTick();\n    }, []);\n  }\n  function addPossiblyUnhandledError(promise) {\n    if (!unhandledErrors.some(function (p) {\n      return p._value === promise._value;\n    })) unhandledErrors.push(promise);\n  }\n  function markErrorAsHandled(promise) {\n    var i = unhandledErrors.length;\n    while (i) if (unhandledErrors[--i]._value === promise._value) {\n      unhandledErrors.splice(i, 1);\n      return;\n    }\n  }\n  function PromiseReject(reason) {\n    return new DexiePromise(INTERNAL, false, reason);\n  }\n  function wrap(fn, errorCatcher) {\n    var psd = PSD;\n    return function () {\n      var wasRootExec = beginMicroTickScope(),\n        outerScope = PSD;\n      try {\n        switchToZone(psd, true);\n        return fn.apply(this, arguments);\n      } catch (e) {\n        errorCatcher && errorCatcher(e);\n      } finally {\n        switchToZone(outerScope, false);\n        if (wasRootExec) endMicroTickScope();\n      }\n    };\n  }\n  var task = {\n    awaits: 0,\n    echoes: 0,\n    id: 0\n  };\n  var taskCounter = 0;\n  var zoneStack = [];\n  var zoneEchoes = 0;\n  var totalEchoes = 0;\n  var zone_id_counter = 0;\n  function newScope(fn, props, a1, a2) {\n    var parent = PSD,\n      psd = Object.create(parent);\n    psd.parent = parent;\n    psd.ref = 0;\n    psd.global = false;\n    psd.id = ++zone_id_counter;\n    var globalEnv = globalPSD.env;\n    psd.env = patchGlobalPromise ? {\n      Promise: DexiePromise,\n      PromiseProp: {\n        value: DexiePromise,\n        configurable: true,\n        writable: true\n      },\n      all: DexiePromise.all,\n      race: DexiePromise.race,\n      allSettled: DexiePromise.allSettled,\n      any: DexiePromise.any,\n      resolve: DexiePromise.resolve,\n      reject: DexiePromise.reject,\n      nthen: getPatchedPromiseThen(globalEnv.nthen, psd),\n      gthen: getPatchedPromiseThen(globalEnv.gthen, psd)\n    } : {};\n    if (props) extend(psd, props);\n    ++parent.ref;\n    psd.finalize = function () {\n      --this.parent.ref || this.parent.finalize();\n    };\n    var rv = usePSD(psd, fn, a1, a2);\n    if (psd.ref === 0) psd.finalize();\n    return rv;\n  }\n  function incrementExpectedAwaits() {\n    if (!task.id) task.id = ++taskCounter;\n    ++task.awaits;\n    task.echoes += ZONE_ECHO_LIMIT;\n    return task.id;\n  }\n  function decrementExpectedAwaits() {\n    if (!task.awaits) return false;\n    if (--task.awaits === 0) task.id = 0;\n    task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n    return true;\n  }\n  if (('' + nativePromiseThen).indexOf('[native code]') === -1) {\n    incrementExpectedAwaits = decrementExpectedAwaits = nop;\n  }\n  function onPossibleParallellAsync(possiblePromise) {\n    if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n      incrementExpectedAwaits();\n      return possiblePromise.then(function (x) {\n        decrementExpectedAwaits();\n        return x;\n      }, function (e) {\n        decrementExpectedAwaits();\n        return rejection(e);\n      });\n    }\n    return possiblePromise;\n  }\n  function zoneEnterEcho(targetZone) {\n    ++totalEchoes;\n    if (!task.echoes || --task.echoes === 0) {\n      task.echoes = task.id = 0;\n    }\n    zoneStack.push(PSD);\n    switchToZone(targetZone, true);\n  }\n  function zoneLeaveEcho() {\n    var zone = zoneStack[zoneStack.length - 1];\n    zoneStack.pop();\n    switchToZone(zone, false);\n  }\n  function switchToZone(targetZone, bEnteringZone) {\n    var currentZone = PSD;\n    if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (! --zoneEchoes || targetZone !== PSD)) {\n      enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n    }\n    if (targetZone === PSD) return;\n    PSD = targetZone;\n    if (currentZone === globalPSD) globalPSD.env = snapShot();\n    if (patchGlobalPromise) {\n      var GlobalPromise_1 = globalPSD.env.Promise;\n      var targetEnv = targetZone.env;\n      nativePromiseProto.then = targetEnv.nthen;\n      GlobalPromise_1.prototype.then = targetEnv.gthen;\n      if (currentZone.global || targetZone.global) {\n        Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);\n        GlobalPromise_1.all = targetEnv.all;\n        GlobalPromise_1.race = targetEnv.race;\n        GlobalPromise_1.resolve = targetEnv.resolve;\n        GlobalPromise_1.reject = targetEnv.reject;\n        if (targetEnv.allSettled) GlobalPromise_1.allSettled = targetEnv.allSettled;\n        if (targetEnv.any) GlobalPromise_1.any = targetEnv.any;\n      }\n    }\n  }\n  function snapShot() {\n    var GlobalPromise = _global.Promise;\n    return patchGlobalPromise ? {\n      Promise: GlobalPromise,\n      PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n      all: GlobalPromise.all,\n      race: GlobalPromise.race,\n      allSettled: GlobalPromise.allSettled,\n      any: GlobalPromise.any,\n      resolve: GlobalPromise.resolve,\n      reject: GlobalPromise.reject,\n      nthen: nativePromiseProto.then,\n      gthen: GlobalPromise.prototype.then\n    } : {};\n  }\n  function usePSD(psd, fn, a1, a2, a3) {\n    var outerScope = PSD;\n    try {\n      switchToZone(psd, true);\n      return fn(a1, a2, a3);\n    } finally {\n      switchToZone(outerScope, false);\n    }\n  }\n  function enqueueNativeMicroTask(job) {\n    nativePromiseThen.call(resolvedNativePromise, job);\n  }\n  function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n    return typeof fn !== 'function' ? fn : function () {\n      var outerZone = PSD;\n      if (possibleAwait) incrementExpectedAwaits();\n      switchToZone(zone, true);\n      try {\n        return fn.apply(this, arguments);\n      } finally {\n        switchToZone(outerZone, false);\n        if (cleanup) enqueueNativeMicroTask(decrementExpectedAwaits);\n      }\n    };\n  }\n  function getPatchedPromiseThen(origThen, zone) {\n    return function (onResolved, onRejected) {\n      return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));\n    };\n  }\n  var UNHANDLEDREJECTION = \"unhandledrejection\";\n  function globalError(err, promise) {\n    var rv;\n    try {\n      rv = promise.onuncatched(err);\n    } catch (e) {}\n    if (rv !== false) try {\n      var event,\n        eventData = {\n          promise: promise,\n          reason: err\n        };\n      if (_global.document && document.createEvent) {\n        event = document.createEvent('Event');\n        event.initEvent(UNHANDLEDREJECTION, true, true);\n        extend(event, eventData);\n      } else if (_global.CustomEvent) {\n        event = new CustomEvent(UNHANDLEDREJECTION, {\n          detail: eventData\n        });\n        extend(event, eventData);\n      }\n      if (event && _global.dispatchEvent) {\n        dispatchEvent(event);\n        if (!_global.PromiseRejectionEvent && _global.onunhandledrejection) try {\n          _global.onunhandledrejection(event);\n        } catch (_) {}\n      }\n      if (debug && event && !event.defaultPrevented) {\n        console.warn(\"Unhandled rejection: \" + (err.stack || err));\n      }\n    } catch (e) {}\n  }\n  var rejection = DexiePromise.reject;\n  function tempTransaction(db, mode, storeNames, fn) {\n    if (!db.idbdb || !db._state.openComplete && !PSD.letThrough && !db._vip) {\n      if (db._state.openComplete) {\n        return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n      }\n      if (!db._state.isBeingOpened) {\n        if (!db._options.autoOpen) return rejection(new exceptions.DatabaseClosed());\n        db.open().catch(nop);\n      }\n      return db._state.dbReadyPromise.then(function () {\n        return tempTransaction(db, mode, storeNames, fn);\n      });\n    } else {\n      var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n      try {\n        trans.create();\n        db._state.PR1398_maxLoop = 3;\n      } catch (ex) {\n        if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n          console.warn('Dexie: Need to reopen db');\n          db._close();\n          return db.open().then(function () {\n            return tempTransaction(db, mode, storeNames, fn);\n          });\n        }\n        return rejection(ex);\n      }\n      return trans._promise(mode, function (resolve, reject) {\n        return newScope(function () {\n          PSD.trans = trans;\n          return fn(resolve, reject, trans);\n        });\n      }).then(function (result) {\n        return trans._completion.then(function () {\n          return result;\n        });\n      });\n    }\n  }\n  var DEXIE_VERSION = '3.2.4';\n  var maxString = String.fromCharCode(65535);\n  var minKey = -Infinity;\n  var INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\n  var STRING_EXPECTED = \"String expected.\";\n  var connections = [];\n  var isIEOrEdge = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);\n  var hasIEDeleteObjectStoreBug = isIEOrEdge;\n  var hangsOnDeleteLargeKeyRange = isIEOrEdge;\n  var dexieStackFrameFilter = function (frame) {\n    return !/(dexie\\.js|dexie\\.min\\.js)/.test(frame);\n  };\n  var DBNAMES_DB = '__dbnames';\n  var READONLY = 'readonly';\n  var READWRITE = 'readwrite';\n  function combine(filter1, filter2) {\n    return filter1 ? filter2 ? function () {\n      return filter1.apply(this, arguments) && filter2.apply(this, arguments);\n    } : filter1 : filter2;\n  }\n  var AnyRange = {\n    type: 3,\n    lower: -Infinity,\n    lowerOpen: false,\n    upper: [[]],\n    upperOpen: false\n  };\n  function workaroundForUndefinedPrimKey(keyPath) {\n    return typeof keyPath === \"string\" && !/\\./.test(keyPath) ? function (obj) {\n      if (obj[keyPath] === undefined && keyPath in obj) {\n        obj = deepClone(obj);\n        delete obj[keyPath];\n      }\n      return obj;\n    } : function (obj) {\n      return obj;\n    };\n  }\n  var Table = function () {\n    function Table() {}\n    Table.prototype._trans = function (mode, fn, writeLocked) {\n      var trans = this._tx || PSD.trans;\n      var tableName = this.name;\n      function checkTableInTransaction(resolve, reject, trans) {\n        if (!trans.schema[tableName]) throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n        return fn(trans.idbtrans, trans);\n      }\n      var wasRootExec = beginMicroTickScope();\n      try {\n        return trans && trans.db === this.db ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(function () {\n          return trans._promise(mode, checkTableInTransaction, writeLocked);\n        }, {\n          trans: trans,\n          transless: PSD.transless || PSD\n        }) : tempTransaction(this.db, mode, [this.name], checkTableInTransaction);\n      } finally {\n        if (wasRootExec) endMicroTickScope();\n      }\n    };\n    Table.prototype.get = function (keyOrCrit, cb) {\n      var _this = this;\n      if (keyOrCrit && keyOrCrit.constructor === Object) return this.where(keyOrCrit).first(cb);\n      return this._trans('readonly', function (trans) {\n        return _this.core.get({\n          trans: trans,\n          key: keyOrCrit\n        }).then(function (res) {\n          return _this.hook.reading.fire(res);\n        });\n      }).then(cb);\n    };\n    Table.prototype.where = function (indexOrCrit) {\n      if (typeof indexOrCrit === 'string') return new this.db.WhereClause(this, indexOrCrit);\n      if (isArray(indexOrCrit)) return new this.db.WhereClause(this, \"[\" + indexOrCrit.join('+') + \"]\");\n      var keyPaths = keys(indexOrCrit);\n      if (keyPaths.length === 1) return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);\n      var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function (ix) {\n        return ix.compound && keyPaths.every(function (keyPath) {\n          return ix.keyPath.indexOf(keyPath) >= 0;\n        }) && ix.keyPath.every(function (keyPath) {\n          return keyPaths.indexOf(keyPath) >= 0;\n        });\n      })[0];\n      if (compoundIndex && this.db._maxKey !== maxString) return this.where(compoundIndex.name).equals(compoundIndex.keyPath.map(function (kp) {\n        return indexOrCrit[kp];\n      }));\n      if (!compoundIndex && debug) console.warn(\"The query \" + JSON.stringify(indexOrCrit) + \" on \" + this.name + \" would benefit of a \" + (\"compound index [\" + keyPaths.join('+') + \"]\"));\n      var idxByName = this.schema.idxByName;\n      var idb = this.db._deps.indexedDB;\n      function equals(a, b) {\n        try {\n          return idb.cmp(a, b) === 0;\n        } catch (e) {\n          return false;\n        }\n      }\n      var _a = keyPaths.reduce(function (_a, keyPath) {\n          var prevIndex = _a[0],\n            prevFilterFn = _a[1];\n          var index = idxByName[keyPath];\n          var value = indexOrCrit[keyPath];\n          return [prevIndex || index, prevIndex || !index ? combine(prevFilterFn, index && index.multi ? function (x) {\n            var prop = getByKeyPath(x, keyPath);\n            return isArray(prop) && prop.some(function (item) {\n              return equals(value, item);\n            });\n          } : function (x) {\n            return equals(value, getByKeyPath(x, keyPath));\n          }) : prevFilterFn];\n        }, [null, null]),\n        idx = _a[0],\n        filterFunction = _a[1];\n      return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals('');\n    };\n    Table.prototype.filter = function (filterFunction) {\n      return this.toCollection().and(filterFunction);\n    };\n    Table.prototype.count = function (thenShortcut) {\n      return this.toCollection().count(thenShortcut);\n    };\n    Table.prototype.offset = function (offset) {\n      return this.toCollection().offset(offset);\n    };\n    Table.prototype.limit = function (numRows) {\n      return this.toCollection().limit(numRows);\n    };\n    Table.prototype.each = function (callback) {\n      return this.toCollection().each(callback);\n    };\n    Table.prototype.toArray = function (thenShortcut) {\n      return this.toCollection().toArray(thenShortcut);\n    };\n    Table.prototype.toCollection = function () {\n      return new this.db.Collection(new this.db.WhereClause(this));\n    };\n    Table.prototype.orderBy = function (index) {\n      return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ? \"[\" + index.join('+') + \"]\" : index));\n    };\n    Table.prototype.reverse = function () {\n      return this.toCollection().reverse();\n    };\n    Table.prototype.mapToClass = function (constructor) {\n      this.schema.mappedClass = constructor;\n      var readHook = function (obj) {\n        if (!obj) return obj;\n        var res = Object.create(constructor.prototype);\n        for (var m in obj) if (hasOwn(obj, m)) try {\n          res[m] = obj[m];\n        } catch (_) {}\n        return res;\n      };\n      if (this.schema.readHook) {\n        this.hook.reading.unsubscribe(this.schema.readHook);\n      }\n      this.schema.readHook = readHook;\n      this.hook(\"reading\", readHook);\n      return constructor;\n    };\n    Table.prototype.defineClass = function () {\n      function Class(content) {\n        extend(this, content);\n      }\n      return this.mapToClass(Class);\n    };\n    Table.prototype.add = function (obj, key) {\n      var _this = this;\n      var _a = this.schema.primKey,\n        auto = _a.auto,\n        keyPath = _a.keyPath;\n      var objToAdd = obj;\n      if (keyPath && auto) {\n        objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n      }\n      return this._trans('readwrite', function (trans) {\n        return _this.core.mutate({\n          trans: trans,\n          type: 'add',\n          keys: key != null ? [key] : null,\n          values: [objToAdd]\n        });\n      }).then(function (res) {\n        return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult;\n      }).then(function (lastResult) {\n        if (keyPath) {\n          try {\n            setByKeyPath(obj, keyPath, lastResult);\n          } catch (_) {}\n        }\n        return lastResult;\n      });\n    };\n    Table.prototype.update = function (keyOrObject, modifications) {\n      if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\n        var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n        if (key === undefined) return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n        try {\n          if (typeof modifications !== \"function\") {\n            keys(modifications).forEach(function (keyPath) {\n              setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);\n            });\n          } else {\n            modifications(keyOrObject, {\n              value: keyOrObject,\n              primKey: key\n            });\n          }\n        } catch (_a) {}\n        return this.where(\":id\").equals(key).modify(modifications);\n      } else {\n        return this.where(\":id\").equals(keyOrObject).modify(modifications);\n      }\n    };\n    Table.prototype.put = function (obj, key) {\n      var _this = this;\n      var _a = this.schema.primKey,\n        auto = _a.auto,\n        keyPath = _a.keyPath;\n      var objToAdd = obj;\n      if (keyPath && auto) {\n        objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n      }\n      return this._trans('readwrite', function (trans) {\n        return _this.core.mutate({\n          trans: trans,\n          type: 'put',\n          values: [objToAdd],\n          keys: key != null ? [key] : null\n        });\n      }).then(function (res) {\n        return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult;\n      }).then(function (lastResult) {\n        if (keyPath) {\n          try {\n            setByKeyPath(obj, keyPath, lastResult);\n          } catch (_) {}\n        }\n        return lastResult;\n      });\n    };\n    Table.prototype.delete = function (key) {\n      var _this = this;\n      return this._trans('readwrite', function (trans) {\n        return _this.core.mutate({\n          trans: trans,\n          type: 'delete',\n          keys: [key]\n        });\n      }).then(function (res) {\n        return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined;\n      });\n    };\n    Table.prototype.clear = function () {\n      var _this = this;\n      return this._trans('readwrite', function (trans) {\n        return _this.core.mutate({\n          trans: trans,\n          type: 'deleteRange',\n          range: AnyRange\n        });\n      }).then(function (res) {\n        return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined;\n      });\n    };\n    Table.prototype.bulkGet = function (keys) {\n      var _this = this;\n      return this._trans('readonly', function (trans) {\n        return _this.core.getMany({\n          keys: keys,\n          trans: trans\n        }).then(function (result) {\n          return result.map(function (res) {\n            return _this.hook.reading.fire(res);\n          });\n        });\n      });\n    };\n    Table.prototype.bulkAdd = function (objects, keysOrOptions, options) {\n      var _this = this;\n      var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n      options = options || (keys ? undefined : keysOrOptions);\n      var wantResults = options ? options.allKeys : undefined;\n      return this._trans('readwrite', function (trans) {\n        var _a = _this.schema.primKey,\n          auto = _a.auto,\n          keyPath = _a.keyPath;\n        if (keyPath && keys) throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n        if (keys && keys.length !== objects.length) throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n        var numObjects = objects.length;\n        var objectsToAdd = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;\n        return _this.core.mutate({\n          trans: trans,\n          type: 'add',\n          keys: keys,\n          values: objectsToAdd,\n          wantResults: wantResults\n        }).then(function (_a) {\n          var numFailures = _a.numFailures,\n            results = _a.results,\n            lastResult = _a.lastResult,\n            failures = _a.failures;\n          var result = wantResults ? results : lastResult;\n          if (numFailures === 0) return result;\n          throw new BulkError(_this.name + \".bulkAdd(): \" + numFailures + \" of \" + numObjects + \" operations failed\", failures);\n        });\n      });\n    };\n    Table.prototype.bulkPut = function (objects, keysOrOptions, options) {\n      var _this = this;\n      var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n      options = options || (keys ? undefined : keysOrOptions);\n      var wantResults = options ? options.allKeys : undefined;\n      return this._trans('readwrite', function (trans) {\n        var _a = _this.schema.primKey,\n          auto = _a.auto,\n          keyPath = _a.keyPath;\n        if (keyPath && keys) throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n        if (keys && keys.length !== objects.length) throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n        var numObjects = objects.length;\n        var objectsToPut = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;\n        return _this.core.mutate({\n          trans: trans,\n          type: 'put',\n          keys: keys,\n          values: objectsToPut,\n          wantResults: wantResults\n        }).then(function (_a) {\n          var numFailures = _a.numFailures,\n            results = _a.results,\n            lastResult = _a.lastResult,\n            failures = _a.failures;\n          var result = wantResults ? results : lastResult;\n          if (numFailures === 0) return result;\n          throw new BulkError(_this.name + \".bulkPut(): \" + numFailures + \" of \" + numObjects + \" operations failed\", failures);\n        });\n      });\n    };\n    Table.prototype.bulkDelete = function (keys) {\n      var _this = this;\n      var numKeys = keys.length;\n      return this._trans('readwrite', function (trans) {\n        return _this.core.mutate({\n          trans: trans,\n          type: 'delete',\n          keys: keys\n        });\n      }).then(function (_a) {\n        var numFailures = _a.numFailures,\n          lastResult = _a.lastResult,\n          failures = _a.failures;\n        if (numFailures === 0) return lastResult;\n        throw new BulkError(_this.name + \".bulkDelete(): \" + numFailures + \" of \" + numKeys + \" operations failed\", failures);\n      });\n    };\n    return Table;\n  }();\n  function Events(ctx) {\n    var evs = {};\n    var rv = function (eventName, subscriber) {\n      if (subscriber) {\n        var i = arguments.length,\n          args = new Array(i - 1);\n        while (--i) args[i - 1] = arguments[i];\n        evs[eventName].subscribe.apply(null, args);\n        return ctx;\n      } else if (typeof eventName === 'string') {\n        return evs[eventName];\n      }\n    };\n    rv.addEventType = add;\n    for (var i = 1, l = arguments.length; i < l; ++i) {\n      add(arguments[i]);\n    }\n    return rv;\n    function add(eventName, chainFunction, defaultFunction) {\n      if (typeof eventName === 'object') return addConfiguredEvents(eventName);\n      if (!chainFunction) chainFunction = reverseStoppableEventChain;\n      if (!defaultFunction) defaultFunction = nop;\n      var context = {\n        subscribers: [],\n        fire: defaultFunction,\n        subscribe: function (cb) {\n          if (context.subscribers.indexOf(cb) === -1) {\n            context.subscribers.push(cb);\n            context.fire = chainFunction(context.fire, cb);\n          }\n        },\n        unsubscribe: function (cb) {\n          context.subscribers = context.subscribers.filter(function (fn) {\n            return fn !== cb;\n          });\n          context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n        }\n      };\n      evs[eventName] = rv[eventName] = context;\n      return context;\n    }\n    function addConfiguredEvents(cfg) {\n      keys(cfg).forEach(function (eventName) {\n        var args = cfg[eventName];\n        if (isArray(args)) {\n          add(eventName, cfg[eventName][0], cfg[eventName][1]);\n        } else if (args === 'asap') {\n          var context = add(eventName, mirror, function fire() {\n            var i = arguments.length,\n              args = new Array(i);\n            while (i--) args[i] = arguments[i];\n            context.subscribers.forEach(function (fn) {\n              asap$1(function fireEvent() {\n                fn.apply(null, args);\n              });\n            });\n          });\n        } else throw new exceptions.InvalidArgument(\"Invalid event config\");\n      });\n    }\n  }\n  function makeClassConstructor(prototype, constructor) {\n    derive(constructor).from({\n      prototype: prototype\n    });\n    return constructor;\n  }\n  function createTableConstructor(db) {\n    return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n      this.db = db;\n      this._tx = trans;\n      this.name = name;\n      this.schema = tableSchema;\n      this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n        \"creating\": [hookCreatingChain, nop],\n        \"reading\": [pureFunctionChain, mirror],\n        \"updating\": [hookUpdatingChain, nop],\n        \"deleting\": [hookDeletingChain, nop]\n      });\n    });\n  }\n  function isPlainKeyRange(ctx, ignoreLimitFilter) {\n    return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n  }\n  function addFilter(ctx, fn) {\n    ctx.filter = combine(ctx.filter, fn);\n  }\n  function addReplayFilter(ctx, factory, isLimitFilter) {\n    var curr = ctx.replayFilter;\n    ctx.replayFilter = curr ? function () {\n      return combine(curr(), factory());\n    } : factory;\n    ctx.justLimit = isLimitFilter && !curr;\n  }\n  function addMatchFilter(ctx, fn) {\n    ctx.isMatch = combine(ctx.isMatch, fn);\n  }\n  function getIndexOrStore(ctx, coreSchema) {\n    if (ctx.isPrimKey) return coreSchema.primaryKey;\n    var index = coreSchema.getIndexByKeyPath(ctx.index);\n    if (!index) throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n    return index;\n  }\n  function openCursor(ctx, coreTable, trans) {\n    var index = getIndexOrStore(ctx, coreTable.schema);\n    return coreTable.openCursor({\n      trans: trans,\n      values: !ctx.keysOnly,\n      reverse: ctx.dir === 'prev',\n      unique: !!ctx.unique,\n      query: {\n        index: index,\n        range: ctx.range\n      }\n    });\n  }\n  function iter(ctx, fn, coreTrans, coreTable) {\n    var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n    if (!ctx.or) {\n      return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n    } else {\n      var set_1 = {};\n      var union = function (item, cursor, advance) {\n        if (!filter || filter(cursor, advance, function (result) {\n          return cursor.stop(result);\n        }, function (err) {\n          return cursor.fail(err);\n        })) {\n          var primaryKey = cursor.primaryKey;\n          var key = '' + primaryKey;\n          if (key === '[object ArrayBuffer]') key = '' + new Uint8Array(primaryKey);\n          if (!hasOwn(set_1, key)) {\n            set_1[key] = true;\n            fn(item, cursor, advance);\n          }\n        }\n      };\n      return Promise.all([ctx.or._iterate(union, coreTrans), iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)]);\n    }\n  }\n  function iterate(cursorPromise, filter, fn, valueMapper) {\n    var mappedFn = valueMapper ? function (x, c, a) {\n      return fn(valueMapper(x), c, a);\n    } : fn;\n    var wrappedFn = wrap(mappedFn);\n    return cursorPromise.then(function (cursor) {\n      if (cursor) {\n        return cursor.start(function () {\n          var c = function () {\n            return cursor.continue();\n          };\n          if (!filter || filter(cursor, function (advancer) {\n            return c = advancer;\n          }, function (val) {\n            cursor.stop(val);\n            c = nop;\n          }, function (e) {\n            cursor.fail(e);\n            c = nop;\n          })) wrappedFn(cursor.value, cursor, function (advancer) {\n            return c = advancer;\n          });\n          c();\n        });\n      }\n    });\n  }\n  function cmp(a, b) {\n    try {\n      var ta = type(a);\n      var tb = type(b);\n      if (ta !== tb) {\n        if (ta === 'Array') return 1;\n        if (tb === 'Array') return -1;\n        if (ta === 'binary') return 1;\n        if (tb === 'binary') return -1;\n        if (ta === 'string') return 1;\n        if (tb === 'string') return -1;\n        if (ta === 'Date') return 1;\n        if (tb !== 'Date') return NaN;\n        return -1;\n      }\n      switch (ta) {\n        case 'number':\n        case 'Date':\n        case 'string':\n          return a > b ? 1 : a < b ? -1 : 0;\n        case 'binary':\n          {\n            return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n          }\n        case 'Array':\n          return compareArrays(a, b);\n      }\n    } catch (_a) {}\n    return NaN;\n  }\n  function compareArrays(a, b) {\n    var al = a.length;\n    var bl = b.length;\n    var l = al < bl ? al : bl;\n    for (var i = 0; i < l; ++i) {\n      var res = cmp(a[i], b[i]);\n      if (res !== 0) return res;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n  }\n  function compareUint8Arrays(a, b) {\n    var al = a.length;\n    var bl = b.length;\n    var l = al < bl ? al : bl;\n    for (var i = 0; i < l; ++i) {\n      if (a[i] !== b[i]) return a[i] < b[i] ? -1 : 1;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n  }\n  function type(x) {\n    var t = typeof x;\n    if (t !== 'object') return t;\n    if (ArrayBuffer.isView(x)) return 'binary';\n    var tsTag = toStringTag(x);\n    return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;\n  }\n  function getUint8Array(a) {\n    if (a instanceof Uint8Array) return a;\n    if (ArrayBuffer.isView(a)) return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n    return new Uint8Array(a);\n  }\n  var Collection = function () {\n    function Collection() {}\n    Collection.prototype._read = function (fn, cb) {\n      var ctx = this._ctx;\n      return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans('readonly', fn).then(cb);\n    };\n    Collection.prototype._write = function (fn) {\n      var ctx = this._ctx;\n      return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans('readwrite', fn, \"locked\");\n    };\n    Collection.prototype._addAlgorithm = function (fn) {\n      var ctx = this._ctx;\n      ctx.algorithm = combine(ctx.algorithm, fn);\n    };\n    Collection.prototype._iterate = function (fn, coreTrans) {\n      return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n    };\n    Collection.prototype.clone = function (props) {\n      var rv = Object.create(this.constructor.prototype),\n        ctx = Object.create(this._ctx);\n      if (props) extend(ctx, props);\n      rv._ctx = ctx;\n      return rv;\n    };\n    Collection.prototype.raw = function () {\n      this._ctx.valueMapper = null;\n      return this;\n    };\n    Collection.prototype.each = function (fn) {\n      var ctx = this._ctx;\n      return this._read(function (trans) {\n        return iter(ctx, fn, trans, ctx.table.core);\n      });\n    };\n    Collection.prototype.count = function (cb) {\n      var _this = this;\n      return this._read(function (trans) {\n        var ctx = _this._ctx;\n        var coreTable = ctx.table.core;\n        if (isPlainKeyRange(ctx, true)) {\n          return coreTable.count({\n            trans: trans,\n            query: {\n              index: getIndexOrStore(ctx, coreTable.schema),\n              range: ctx.range\n            }\n          }).then(function (count) {\n            return Math.min(count, ctx.limit);\n          });\n        } else {\n          var count = 0;\n          return iter(ctx, function () {\n            ++count;\n            return false;\n          }, trans, coreTable).then(function () {\n            return count;\n          });\n        }\n      }).then(cb);\n    };\n    Collection.prototype.sortBy = function (keyPath, cb) {\n      var parts = keyPath.split('.').reverse(),\n        lastPart = parts[0],\n        lastIndex = parts.length - 1;\n      function getval(obj, i) {\n        if (i) return getval(obj[parts[i]], i - 1);\n        return obj[lastPart];\n      }\n      var order = this._ctx.dir === \"next\" ? 1 : -1;\n      function sorter(a, b) {\n        var aVal = getval(a, lastIndex),\n          bVal = getval(b, lastIndex);\n        return aVal < bVal ? -order : aVal > bVal ? order : 0;\n      }\n      return this.toArray(function (a) {\n        return a.sort(sorter);\n      }).then(cb);\n    };\n    Collection.prototype.toArray = function (cb) {\n      var _this = this;\n      return this._read(function (trans) {\n        var ctx = _this._ctx;\n        if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n          var valueMapper_1 = ctx.valueMapper;\n          var index = getIndexOrStore(ctx, ctx.table.core.schema);\n          return ctx.table.core.query({\n            trans: trans,\n            limit: ctx.limit,\n            values: true,\n            query: {\n              index: index,\n              range: ctx.range\n            }\n          }).then(function (_a) {\n            var result = _a.result;\n            return valueMapper_1 ? result.map(valueMapper_1) : result;\n          });\n        } else {\n          var a_1 = [];\n          return iter(ctx, function (item) {\n            return a_1.push(item);\n          }, trans, ctx.table.core).then(function () {\n            return a_1;\n          });\n        }\n      }, cb);\n    };\n    Collection.prototype.offset = function (offset) {\n      var ctx = this._ctx;\n      if (offset <= 0) return this;\n      ctx.offset += offset;\n      if (isPlainKeyRange(ctx)) {\n        addReplayFilter(ctx, function () {\n          var offsetLeft = offset;\n          return function (cursor, advance) {\n            if (offsetLeft === 0) return true;\n            if (offsetLeft === 1) {\n              --offsetLeft;\n              return false;\n            }\n            advance(function () {\n              cursor.advance(offsetLeft);\n              offsetLeft = 0;\n            });\n            return false;\n          };\n        });\n      } else {\n        addReplayFilter(ctx, function () {\n          var offsetLeft = offset;\n          return function () {\n            return --offsetLeft < 0;\n          };\n        });\n      }\n      return this;\n    };\n    Collection.prototype.limit = function (numRows) {\n      this._ctx.limit = Math.min(this._ctx.limit, numRows);\n      addReplayFilter(this._ctx, function () {\n        var rowsLeft = numRows;\n        return function (cursor, advance, resolve) {\n          if (--rowsLeft <= 0) advance(resolve);\n          return rowsLeft >= 0;\n        };\n      }, true);\n      return this;\n    };\n    Collection.prototype.until = function (filterFunction, bIncludeStopEntry) {\n      addFilter(this._ctx, function (cursor, advance, resolve) {\n        if (filterFunction(cursor.value)) {\n          advance(resolve);\n          return bIncludeStopEntry;\n        } else {\n          return true;\n        }\n      });\n      return this;\n    };\n    Collection.prototype.first = function (cb) {\n      return this.limit(1).toArray(function (a) {\n        return a[0];\n      }).then(cb);\n    };\n    Collection.prototype.last = function (cb) {\n      return this.reverse().first(cb);\n    };\n    Collection.prototype.filter = function (filterFunction) {\n      addFilter(this._ctx, function (cursor) {\n        return filterFunction(cursor.value);\n      });\n      addMatchFilter(this._ctx, filterFunction);\n      return this;\n    };\n    Collection.prototype.and = function (filter) {\n      return this.filter(filter);\n    };\n    Collection.prototype.or = function (indexName) {\n      return new this.db.WhereClause(this._ctx.table, indexName, this);\n    };\n    Collection.prototype.reverse = function () {\n      this._ctx.dir = this._ctx.dir === \"prev\" ? \"next\" : \"prev\";\n      if (this._ondirectionchange) this._ondirectionchange(this._ctx.dir);\n      return this;\n    };\n    Collection.prototype.desc = function () {\n      return this.reverse();\n    };\n    Collection.prototype.eachKey = function (cb) {\n      var ctx = this._ctx;\n      ctx.keysOnly = !ctx.isMatch;\n      return this.each(function (val, cursor) {\n        cb(cursor.key, cursor);\n      });\n    };\n    Collection.prototype.eachUniqueKey = function (cb) {\n      this._ctx.unique = \"unique\";\n      return this.eachKey(cb);\n    };\n    Collection.prototype.eachPrimaryKey = function (cb) {\n      var ctx = this._ctx;\n      ctx.keysOnly = !ctx.isMatch;\n      return this.each(function (val, cursor) {\n        cb(cursor.primaryKey, cursor);\n      });\n    };\n    Collection.prototype.keys = function (cb) {\n      var ctx = this._ctx;\n      ctx.keysOnly = !ctx.isMatch;\n      var a = [];\n      return this.each(function (item, cursor) {\n        a.push(cursor.key);\n      }).then(function () {\n        return a;\n      }).then(cb);\n    };\n    Collection.prototype.primaryKeys = function (cb) {\n      var ctx = this._ctx;\n      if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n        return this._read(function (trans) {\n          var index = getIndexOrStore(ctx, ctx.table.core.schema);\n          return ctx.table.core.query({\n            trans: trans,\n            values: false,\n            limit: ctx.limit,\n            query: {\n              index: index,\n              range: ctx.range\n            }\n          });\n        }).then(function (_a) {\n          var result = _a.result;\n          return result;\n        }).then(cb);\n      }\n      ctx.keysOnly = !ctx.isMatch;\n      var a = [];\n      return this.each(function (item, cursor) {\n        a.push(cursor.primaryKey);\n      }).then(function () {\n        return a;\n      }).then(cb);\n    };\n    Collection.prototype.uniqueKeys = function (cb) {\n      this._ctx.unique = \"unique\";\n      return this.keys(cb);\n    };\n    Collection.prototype.firstKey = function (cb) {\n      return this.limit(1).keys(function (a) {\n        return a[0];\n      }).then(cb);\n    };\n    Collection.prototype.lastKey = function (cb) {\n      return this.reverse().firstKey(cb);\n    };\n    Collection.prototype.distinct = function () {\n      var ctx = this._ctx,\n        idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n      if (!idx || !idx.multi) return this;\n      var set = {};\n      addFilter(this._ctx, function (cursor) {\n        var strKey = cursor.primaryKey.toString();\n        var found = hasOwn(set, strKey);\n        set[strKey] = true;\n        return !found;\n      });\n      return this;\n    };\n    Collection.prototype.modify = function (changes) {\n      var _this = this;\n      var ctx = this._ctx;\n      return this._write(function (trans) {\n        var modifyer;\n        if (typeof changes === 'function') {\n          modifyer = changes;\n        } else {\n          var keyPaths = keys(changes);\n          var numKeys = keyPaths.length;\n          modifyer = function (item) {\n            var anythingModified = false;\n            for (var i = 0; i < numKeys; ++i) {\n              var keyPath = keyPaths[i],\n                val = changes[keyPath];\n              if (getByKeyPath(item, keyPath) !== val) {\n                setByKeyPath(item, keyPath, val);\n                anythingModified = true;\n              }\n            }\n            return anythingModified;\n          };\n        }\n        var coreTable = ctx.table.core;\n        var _a = coreTable.schema.primaryKey,\n          outbound = _a.outbound,\n          extractKey = _a.extractKey;\n        var limit = _this.db._options.modifyChunkSize || 200;\n        var totalFailures = [];\n        var successCount = 0;\n        var failedKeys = [];\n        var applyMutateResult = function (expectedCount, res) {\n          var failures = res.failures,\n            numFailures = res.numFailures;\n          successCount += expectedCount - numFailures;\n          for (var _i = 0, _a = keys(failures); _i < _a.length; _i++) {\n            var pos = _a[_i];\n            totalFailures.push(failures[pos]);\n          }\n        };\n        return _this.clone().primaryKeys().then(function (keys) {\n          var nextChunk = function (offset) {\n            var count = Math.min(limit, keys.length - offset);\n            return coreTable.getMany({\n              trans: trans,\n              keys: keys.slice(offset, offset + count),\n              cache: \"immutable\"\n            }).then(function (values) {\n              var addValues = [];\n              var putValues = [];\n              var putKeys = outbound ? [] : null;\n              var deleteKeys = [];\n              for (var i = 0; i < count; ++i) {\n                var origValue = values[i];\n                var ctx_1 = {\n                  value: deepClone(origValue),\n                  primKey: keys[offset + i]\n                };\n                if (modifyer.call(ctx_1, ctx_1.value, ctx_1) !== false) {\n                  if (ctx_1.value == null) {\n                    deleteKeys.push(keys[offset + i]);\n                  } else if (!outbound && cmp(extractKey(origValue), extractKey(ctx_1.value)) !== 0) {\n                    deleteKeys.push(keys[offset + i]);\n                    addValues.push(ctx_1.value);\n                  } else {\n                    putValues.push(ctx_1.value);\n                    if (outbound) putKeys.push(keys[offset + i]);\n                  }\n                }\n              }\n              var criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== 'function' || changes === deleteCallback) && {\n                index: ctx.index,\n                range: ctx.range\n              };\n              return Promise.resolve(addValues.length > 0 && coreTable.mutate({\n                trans: trans,\n                type: 'add',\n                values: addValues\n              }).then(function (res) {\n                for (var pos in res.failures) {\n                  deleteKeys.splice(parseInt(pos), 1);\n                }\n                applyMutateResult(addValues.length, res);\n              })).then(function () {\n                return (putValues.length > 0 || criteria && typeof changes === 'object') && coreTable.mutate({\n                  trans: trans,\n                  type: 'put',\n                  keys: putKeys,\n                  values: putValues,\n                  criteria: criteria,\n                  changeSpec: typeof changes !== 'function' && changes\n                }).then(function (res) {\n                  return applyMutateResult(putValues.length, res);\n                });\n              }).then(function () {\n                return (deleteKeys.length > 0 || criteria && changes === deleteCallback) && coreTable.mutate({\n                  trans: trans,\n                  type: 'delete',\n                  keys: deleteKeys,\n                  criteria: criteria\n                }).then(function (res) {\n                  return applyMutateResult(deleteKeys.length, res);\n                });\n              }).then(function () {\n                return keys.length > offset + count && nextChunk(offset + limit);\n              });\n            });\n          };\n          return nextChunk(0).then(function () {\n            if (totalFailures.length > 0) throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n            return keys.length;\n          });\n        });\n      });\n    };\n    Collection.prototype.delete = function () {\n      var ctx = this._ctx,\n        range = ctx.range;\n      if (isPlainKeyRange(ctx) && (ctx.isPrimKey && !hangsOnDeleteLargeKeyRange || range.type === 3)) {\n        return this._write(function (trans) {\n          var primaryKey = ctx.table.core.schema.primaryKey;\n          var coreRange = range;\n          return ctx.table.core.count({\n            trans: trans,\n            query: {\n              index: primaryKey,\n              range: coreRange\n            }\n          }).then(function (count) {\n            return ctx.table.core.mutate({\n              trans: trans,\n              type: 'deleteRange',\n              range: coreRange\n            }).then(function (_a) {\n              var failures = _a.failures;\n              _a.lastResult;\n              _a.results;\n              var numFailures = _a.numFailures;\n              if (numFailures) throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map(function (pos) {\n                return failures[pos];\n              }), count - numFailures);\n              return count - numFailures;\n            });\n          });\n        });\n      }\n      return this.modify(deleteCallback);\n    };\n    return Collection;\n  }();\n  var deleteCallback = function (value, ctx) {\n    return ctx.value = null;\n  };\n  function createCollectionConstructor(db) {\n    return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n      this.db = db;\n      var keyRange = AnyRange,\n        error = null;\n      if (keyRangeGenerator) try {\n        keyRange = keyRangeGenerator();\n      } catch (ex) {\n        error = ex;\n      }\n      var whereCtx = whereClause._ctx;\n      var table = whereCtx.table;\n      var readingHook = table.hook.reading.fire;\n      this._ctx = {\n        table: table,\n        index: whereCtx.index,\n        isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,\n        range: keyRange,\n        keysOnly: false,\n        dir: \"next\",\n        unique: \"\",\n        algorithm: null,\n        filter: null,\n        replayFilter: null,\n        justLimit: true,\n        isMatch: null,\n        offset: 0,\n        limit: Infinity,\n        error: error,\n        or: whereCtx.or,\n        valueMapper: readingHook !== mirror ? readingHook : null\n      };\n    });\n  }\n  function simpleCompare(a, b) {\n    return a < b ? -1 : a === b ? 0 : 1;\n  }\n  function simpleCompareReverse(a, b) {\n    return a > b ? -1 : a === b ? 0 : 1;\n  }\n  function fail(collectionOrWhereClause, err, T) {\n    var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;\n    collection._ctx.error = T ? new T(err) : new TypeError(err);\n    return collection;\n  }\n  function emptyCollection(whereClause) {\n    return new whereClause.Collection(whereClause, function () {\n      return rangeEqual(\"\");\n    }).limit(0);\n  }\n  function upperFactory(dir) {\n    return dir === \"next\" ? function (s) {\n      return s.toUpperCase();\n    } : function (s) {\n      return s.toLowerCase();\n    };\n  }\n  function lowerFactory(dir) {\n    return dir === \"next\" ? function (s) {\n      return s.toLowerCase();\n    } : function (s) {\n      return s.toUpperCase();\n    };\n  }\n  function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n    var length = Math.min(key.length, lowerNeedle.length);\n    var llp = -1;\n    for (var i = 0; i < length; ++i) {\n      var lwrKeyChar = lowerKey[i];\n      if (lwrKeyChar !== lowerNeedle[i]) {\n        if (cmp(key[i], upperNeedle[i]) < 0) return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n        if (cmp(key[i], lowerNeedle[i]) < 0) return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n        if (llp >= 0) return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n        return null;\n      }\n      if (cmp(key[i], lwrKeyChar) < 0) llp = i;\n    }\n    if (length < lowerNeedle.length && dir === \"next\") return key + upperNeedle.substr(key.length);\n    if (length < key.length && dir === \"prev\") return key.substr(0, upperNeedle.length);\n    return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);\n  }\n  function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n    var upper,\n      lower,\n      compare,\n      upperNeedles,\n      lowerNeedles,\n      direction,\n      nextKeySuffix,\n      needlesLen = needles.length;\n    if (!needles.every(function (s) {\n      return typeof s === 'string';\n    })) {\n      return fail(whereClause, STRING_EXPECTED);\n    }\n    function initDirection(dir) {\n      upper = upperFactory(dir);\n      lower = lowerFactory(dir);\n      compare = dir === \"next\" ? simpleCompare : simpleCompareReverse;\n      var needleBounds = needles.map(function (needle) {\n        return {\n          lower: lower(needle),\n          upper: upper(needle)\n        };\n      }).sort(function (a, b) {\n        return compare(a.lower, b.lower);\n      });\n      upperNeedles = needleBounds.map(function (nb) {\n        return nb.upper;\n      });\n      lowerNeedles = needleBounds.map(function (nb) {\n        return nb.lower;\n      });\n      direction = dir;\n      nextKeySuffix = dir === \"next\" ? \"\" : suffix;\n    }\n    initDirection(\"next\");\n    var c = new whereClause.Collection(whereClause, function () {\n      return createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix);\n    });\n    c._ondirectionchange = function (direction) {\n      initDirection(direction);\n    };\n    var firstPossibleNeedle = 0;\n    c._addAlgorithm(function (cursor, advance, resolve) {\n      var key = cursor.key;\n      if (typeof key !== 'string') return false;\n      var lowerKey = lower(key);\n      if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n        return true;\n      } else {\n        var lowestPossibleCasing = null;\n        for (var i = firstPossibleNeedle; i < needlesLen; ++i) {\n          var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n          if (casing === null && lowestPossibleCasing === null) firstPossibleNeedle = i + 1;else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n            lowestPossibleCasing = casing;\n          }\n        }\n        if (lowestPossibleCasing !== null) {\n          advance(function () {\n            cursor.continue(lowestPossibleCasing + nextKeySuffix);\n          });\n        } else {\n          advance(resolve);\n        }\n        return false;\n      }\n    });\n    return c;\n  }\n  function createRange(lower, upper, lowerOpen, upperOpen) {\n    return {\n      type: 2,\n      lower: lower,\n      upper: upper,\n      lowerOpen: lowerOpen,\n      upperOpen: upperOpen\n    };\n  }\n  function rangeEqual(value) {\n    return {\n      type: 1,\n      lower: value,\n      upper: value\n    };\n  }\n  var WhereClause = function () {\n    function WhereClause() {}\n    Object.defineProperty(WhereClause.prototype, \"Collection\", {\n      get: function () {\n        return this._ctx.table.db.Collection;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    WhereClause.prototype.between = function (lower, upper, includeLower, includeUpper) {\n      includeLower = includeLower !== false;\n      includeUpper = includeUpper === true;\n      try {\n        if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)) return emptyCollection(this);\n        return new this.Collection(this, function () {\n          return createRange(lower, upper, !includeLower, !includeUpper);\n        });\n      } catch (e) {\n        return fail(this, INVALID_KEY_ARGUMENT);\n      }\n    };\n    WhereClause.prototype.equals = function (value) {\n      if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n      return new this.Collection(this, function () {\n        return rangeEqual(value);\n      });\n    };\n    WhereClause.prototype.above = function (value) {\n      if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n      return new this.Collection(this, function () {\n        return createRange(value, undefined, true);\n      });\n    };\n    WhereClause.prototype.aboveOrEqual = function (value) {\n      if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n      return new this.Collection(this, function () {\n        return createRange(value, undefined, false);\n      });\n    };\n    WhereClause.prototype.below = function (value) {\n      if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n      return new this.Collection(this, function () {\n        return createRange(undefined, value, false, true);\n      });\n    };\n    WhereClause.prototype.belowOrEqual = function (value) {\n      if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n      return new this.Collection(this, function () {\n        return createRange(undefined, value);\n      });\n    };\n    WhereClause.prototype.startsWith = function (str) {\n      if (typeof str !== 'string') return fail(this, STRING_EXPECTED);\n      return this.between(str, str + maxString, true, true);\n    };\n    WhereClause.prototype.startsWithIgnoreCase = function (str) {\n      if (str === \"\") return this.startsWith(str);\n      return addIgnoreCaseAlgorithm(this, function (x, a) {\n        return x.indexOf(a[0]) === 0;\n      }, [str], maxString);\n    };\n    WhereClause.prototype.equalsIgnoreCase = function (str) {\n      return addIgnoreCaseAlgorithm(this, function (x, a) {\n        return x === a[0];\n      }, [str], \"\");\n    };\n    WhereClause.prototype.anyOfIgnoreCase = function () {\n      var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n      if (set.length === 0) return emptyCollection(this);\n      return addIgnoreCaseAlgorithm(this, function (x, a) {\n        return a.indexOf(x) !== -1;\n      }, set, \"\");\n    };\n    WhereClause.prototype.startsWithAnyOfIgnoreCase = function () {\n      var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n      if (set.length === 0) return emptyCollection(this);\n      return addIgnoreCaseAlgorithm(this, function (x, a) {\n        return a.some(function (n) {\n          return x.indexOf(n) === 0;\n        });\n      }, set, maxString);\n    };\n    WhereClause.prototype.anyOf = function () {\n      var _this = this;\n      var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n      var compare = this._cmp;\n      try {\n        set.sort(compare);\n      } catch (e) {\n        return fail(this, INVALID_KEY_ARGUMENT);\n      }\n      if (set.length === 0) return emptyCollection(this);\n      var c = new this.Collection(this, function () {\n        return createRange(set[0], set[set.length - 1]);\n      });\n      c._ondirectionchange = function (direction) {\n        compare = direction === \"next\" ? _this._ascending : _this._descending;\n        set.sort(compare);\n      };\n      var i = 0;\n      c._addAlgorithm(function (cursor, advance, resolve) {\n        var key = cursor.key;\n        while (compare(key, set[i]) > 0) {\n          ++i;\n          if (i === set.length) {\n            advance(resolve);\n            return false;\n          }\n        }\n        if (compare(key, set[i]) === 0) {\n          return true;\n        } else {\n          advance(function () {\n            cursor.continue(set[i]);\n          });\n          return false;\n        }\n      });\n      return c;\n    };\n    WhereClause.prototype.notEqual = function (value) {\n      return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], {\n        includeLowers: false,\n        includeUppers: false\n      });\n    };\n    WhereClause.prototype.noneOf = function () {\n      var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n      if (set.length === 0) return new this.Collection(this);\n      try {\n        set.sort(this._ascending);\n      } catch (e) {\n        return fail(this, INVALID_KEY_ARGUMENT);\n      }\n      var ranges = set.reduce(function (res, val) {\n        return res ? res.concat([[res[res.length - 1][1], val]]) : [[minKey, val]];\n      }, null);\n      ranges.push([set[set.length - 1], this.db._maxKey]);\n      return this.inAnyRange(ranges, {\n        includeLowers: false,\n        includeUppers: false\n      });\n    };\n    WhereClause.prototype.inAnyRange = function (ranges, options) {\n      var _this = this;\n      var cmp = this._cmp,\n        ascending = this._ascending,\n        descending = this._descending,\n        min = this._min,\n        max = this._max;\n      if (ranges.length === 0) return emptyCollection(this);\n      if (!ranges.every(function (range) {\n        return range[0] !== undefined && range[1] !== undefined && ascending(range[0], range[1]) <= 0;\n      })) {\n        return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n      }\n      var includeLowers = !options || options.includeLowers !== false;\n      var includeUppers = options && options.includeUppers === true;\n      function addRange(ranges, newRange) {\n        var i = 0,\n          l = ranges.length;\n        for (; i < l; ++i) {\n          var range = ranges[i];\n          if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n            range[0] = min(range[0], newRange[0]);\n            range[1] = max(range[1], newRange[1]);\n            break;\n          }\n        }\n        if (i === l) ranges.push(newRange);\n        return ranges;\n      }\n      var sortDirection = ascending;\n      function rangeSorter(a, b) {\n        return sortDirection(a[0], b[0]);\n      }\n      var set;\n      try {\n        set = ranges.reduce(addRange, []);\n        set.sort(rangeSorter);\n      } catch (ex) {\n        return fail(this, INVALID_KEY_ARGUMENT);\n      }\n      var rangePos = 0;\n      var keyIsBeyondCurrentEntry = includeUppers ? function (key) {\n        return ascending(key, set[rangePos][1]) > 0;\n      } : function (key) {\n        return ascending(key, set[rangePos][1]) >= 0;\n      };\n      var keyIsBeforeCurrentEntry = includeLowers ? function (key) {\n        return descending(key, set[rangePos][0]) > 0;\n      } : function (key) {\n        return descending(key, set[rangePos][0]) >= 0;\n      };\n      function keyWithinCurrentRange(key) {\n        return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n      }\n      var checkKey = keyIsBeyondCurrentEntry;\n      var c = new this.Collection(this, function () {\n        return createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers);\n      });\n      c._ondirectionchange = function (direction) {\n        if (direction === \"next\") {\n          checkKey = keyIsBeyondCurrentEntry;\n          sortDirection = ascending;\n        } else {\n          checkKey = keyIsBeforeCurrentEntry;\n          sortDirection = descending;\n        }\n        set.sort(rangeSorter);\n      };\n      c._addAlgorithm(function (cursor, advance, resolve) {\n        var key = cursor.key;\n        while (checkKey(key)) {\n          ++rangePos;\n          if (rangePos === set.length) {\n            advance(resolve);\n            return false;\n          }\n        }\n        if (keyWithinCurrentRange(key)) {\n          return true;\n        } else if (_this._cmp(key, set[rangePos][1]) === 0 || _this._cmp(key, set[rangePos][0]) === 0) {\n          return false;\n        } else {\n          advance(function () {\n            if (sortDirection === ascending) cursor.continue(set[rangePos][0]);else cursor.continue(set[rangePos][1]);\n          });\n          return false;\n        }\n      });\n      return c;\n    };\n    WhereClause.prototype.startsWithAnyOf = function () {\n      var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n      if (!set.every(function (s) {\n        return typeof s === 'string';\n      })) {\n        return fail(this, \"startsWithAnyOf() only works with strings\");\n      }\n      if (set.length === 0) return emptyCollection(this);\n      return this.inAnyRange(set.map(function (str) {\n        return [str, str + maxString];\n      }));\n    };\n    return WhereClause;\n  }();\n  function createWhereClauseConstructor(db) {\n    return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n      this.db = db;\n      this._ctx = {\n        table: table,\n        index: index === \":id\" ? null : index,\n        or: orCollection\n      };\n      var indexedDB = db._deps.indexedDB;\n      if (!indexedDB) throw new exceptions.MissingAPI();\n      this._cmp = this._ascending = indexedDB.cmp.bind(indexedDB);\n      this._descending = function (a, b) {\n        return indexedDB.cmp(b, a);\n      };\n      this._max = function (a, b) {\n        return indexedDB.cmp(a, b) > 0 ? a : b;\n      };\n      this._min = function (a, b) {\n        return indexedDB.cmp(a, b) < 0 ? a : b;\n      };\n      this._IDBKeyRange = db._deps.IDBKeyRange;\n    });\n  }\n  function eventRejectHandler(reject) {\n    return wrap(function (event) {\n      preventDefault(event);\n      reject(event.target.error);\n      return false;\n    });\n  }\n  function preventDefault(event) {\n    if (event.stopPropagation) event.stopPropagation();\n    if (event.preventDefault) event.preventDefault();\n  }\n  var DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';\n  var STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';\n  var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\n  var Transaction = function () {\n    function Transaction() {}\n    Transaction.prototype._lock = function () {\n      assert(!PSD.global);\n      ++this._reculock;\n      if (this._reculock === 1 && !PSD.global) PSD.lockOwnerFor = this;\n      return this;\n    };\n    Transaction.prototype._unlock = function () {\n      assert(!PSD.global);\n      if (--this._reculock === 0) {\n        if (!PSD.global) PSD.lockOwnerFor = null;\n        while (this._blockedFuncs.length > 0 && !this._locked()) {\n          var fnAndPSD = this._blockedFuncs.shift();\n          try {\n            usePSD(fnAndPSD[1], fnAndPSD[0]);\n          } catch (e) {}\n        }\n      }\n      return this;\n    };\n    Transaction.prototype._locked = function () {\n      return this._reculock && PSD.lockOwnerFor !== this;\n    };\n    Transaction.prototype.create = function (idbtrans) {\n      var _this = this;\n      if (!this.mode) return this;\n      var idbdb = this.db.idbdb;\n      var dbOpenError = this.db._state.dbOpenError;\n      assert(!this.idbtrans);\n      if (!idbtrans && !idbdb) {\n        switch (dbOpenError && dbOpenError.name) {\n          case \"DatabaseClosedError\":\n            throw new exceptions.DatabaseClosed(dbOpenError);\n          case \"MissingAPIError\":\n            throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n          default:\n            throw new exceptions.OpenFailed(dbOpenError);\n        }\n      }\n      if (!this.active) throw new exceptions.TransactionInactive();\n      assert(this._completion._state === null);\n      idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, {\n        durability: this.chromeTransactionDurability\n      }) : idbdb.transaction(this.storeNames, this.mode, {\n        durability: this.chromeTransactionDurability\n      }));\n      idbtrans.onerror = wrap(function (ev) {\n        preventDefault(ev);\n        _this._reject(idbtrans.error);\n      });\n      idbtrans.onabort = wrap(function (ev) {\n        preventDefault(ev);\n        _this.active && _this._reject(new exceptions.Abort(idbtrans.error));\n        _this.active = false;\n        _this.on(\"abort\").fire(ev);\n      });\n      idbtrans.oncomplete = wrap(function () {\n        _this.active = false;\n        _this._resolve();\n        if ('mutatedParts' in idbtrans) {\n          globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n        }\n      });\n      return this;\n    };\n    Transaction.prototype._promise = function (mode, fn, bWriteLock) {\n      var _this = this;\n      if (mode === 'readwrite' && this.mode !== 'readwrite') return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n      if (!this.active) return rejection(new exceptions.TransactionInactive());\n      if (this._locked()) {\n        return new DexiePromise(function (resolve, reject) {\n          _this._blockedFuncs.push([function () {\n            _this._promise(mode, fn, bWriteLock).then(resolve, reject);\n          }, PSD]);\n        });\n      } else if (bWriteLock) {\n        return newScope(function () {\n          var p = new DexiePromise(function (resolve, reject) {\n            _this._lock();\n            var rv = fn(resolve, reject, _this);\n            if (rv && rv.then) rv.then(resolve, reject);\n          });\n          p.finally(function () {\n            return _this._unlock();\n          });\n          p._lib = true;\n          return p;\n        });\n      } else {\n        var p = new DexiePromise(function (resolve, reject) {\n          var rv = fn(resolve, reject, _this);\n          if (rv && rv.then) rv.then(resolve, reject);\n        });\n        p._lib = true;\n        return p;\n      }\n    };\n    Transaction.prototype._root = function () {\n      return this.parent ? this.parent._root() : this;\n    };\n    Transaction.prototype.waitFor = function (promiseLike) {\n      var root = this._root();\n      var promise = DexiePromise.resolve(promiseLike);\n      if (root._waitingFor) {\n        root._waitingFor = root._waitingFor.then(function () {\n          return promise;\n        });\n      } else {\n        root._waitingFor = promise;\n        root._waitingQueue = [];\n        var store = root.idbtrans.objectStore(root.storeNames[0]);\n        (function spin() {\n          ++root._spinCount;\n          while (root._waitingQueue.length) root._waitingQueue.shift()();\n          if (root._waitingFor) store.get(-Infinity).onsuccess = spin;\n        })();\n      }\n      var currentWaitPromise = root._waitingFor;\n      return new DexiePromise(function (resolve, reject) {\n        promise.then(function (res) {\n          return root._waitingQueue.push(wrap(resolve.bind(null, res)));\n        }, function (err) {\n          return root._waitingQueue.push(wrap(reject.bind(null, err)));\n        }).finally(function () {\n          if (root._waitingFor === currentWaitPromise) {\n            root._waitingFor = null;\n          }\n        });\n      });\n    };\n    Transaction.prototype.abort = function () {\n      if (this.active) {\n        this.active = false;\n        if (this.idbtrans) this.idbtrans.abort();\n        this._reject(new exceptions.Abort());\n      }\n    };\n    Transaction.prototype.table = function (tableName) {\n      var memoizedTables = this._memoizedTables || (this._memoizedTables = {});\n      if (hasOwn(memoizedTables, tableName)) return memoizedTables[tableName];\n      var tableSchema = this.schema[tableName];\n      if (!tableSchema) {\n        throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n      }\n      var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n      transactionBoundTable.core = this.db.core.table(tableName);\n      memoizedTables[tableName] = transactionBoundTable;\n      return transactionBoundTable;\n    };\n    return Transaction;\n  }();\n  function createTransactionConstructor(db) {\n    return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n      var _this = this;\n      this.db = db;\n      this.mode = mode;\n      this.storeNames = storeNames;\n      this.schema = dbschema;\n      this.chromeTransactionDurability = chromeTransactionDurability;\n      this.idbtrans = null;\n      this.on = Events(this, \"complete\", \"error\", \"abort\");\n      this.parent = parent || null;\n      this.active = true;\n      this._reculock = 0;\n      this._blockedFuncs = [];\n      this._resolve = null;\n      this._reject = null;\n      this._waitingFor = null;\n      this._waitingQueue = null;\n      this._spinCount = 0;\n      this._completion = new DexiePromise(function (resolve, reject) {\n        _this._resolve = resolve;\n        _this._reject = reject;\n      });\n      this._completion.then(function () {\n        _this.active = false;\n        _this.on.complete.fire();\n      }, function (e) {\n        var wasActive = _this.active;\n        _this.active = false;\n        _this.on.error.fire(e);\n        _this.parent ? _this.parent._reject(e) : wasActive && _this.idbtrans && _this.idbtrans.abort();\n        return rejection(e);\n      });\n    });\n  }\n  function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {\n    return {\n      name: name,\n      keyPath: keyPath,\n      unique: unique,\n      multi: multi,\n      auto: auto,\n      compound: compound,\n      src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath)\n    };\n  }\n  function nameFromKeyPath(keyPath) {\n    return typeof keyPath === 'string' ? keyPath : keyPath ? '[' + [].join.call(keyPath, '+') + ']' : \"\";\n  }\n  function createTableSchema(name, primKey, indexes) {\n    return {\n      name: name,\n      primKey: primKey,\n      indexes: indexes,\n      mappedClass: null,\n      idxByName: arrayToObject(indexes, function (index) {\n        return [index.name, index];\n      })\n    };\n  }\n  function safariMultiStoreFix(storeNames) {\n    return storeNames.length === 1 ? storeNames[0] : storeNames;\n  }\n  var getMaxKey = function (IdbKeyRange) {\n    try {\n      IdbKeyRange.only([[]]);\n      getMaxKey = function () {\n        return [[]];\n      };\n      return [[]];\n    } catch (e) {\n      getMaxKey = function () {\n        return maxString;\n      };\n      return maxString;\n    }\n  };\n  function getKeyExtractor(keyPath) {\n    if (keyPath == null) {\n      return function () {\n        return undefined;\n      };\n    } else if (typeof keyPath === 'string') {\n      return getSinglePathKeyExtractor(keyPath);\n    } else {\n      return function (obj) {\n        return getByKeyPath(obj, keyPath);\n      };\n    }\n  }\n  function getSinglePathKeyExtractor(keyPath) {\n    var split = keyPath.split('.');\n    if (split.length === 1) {\n      return function (obj) {\n        return obj[keyPath];\n      };\n    } else {\n      return function (obj) {\n        return getByKeyPath(obj, keyPath);\n      };\n    }\n  }\n  function arrayify(arrayLike) {\n    return [].slice.call(arrayLike);\n  }\n  var _id_counter = 0;\n  function getKeyPathAlias(keyPath) {\n    return keyPath == null ? \":id\" : typeof keyPath === 'string' ? keyPath : \"[\" + keyPath.join('+') + \"]\";\n  }\n  function createDBCore(db, IdbKeyRange, tmpTrans) {\n    function extractSchema(db, trans) {\n      var tables = arrayify(db.objectStoreNames);\n      return {\n        schema: {\n          name: db.name,\n          tables: tables.map(function (table) {\n            return trans.objectStore(table);\n          }).map(function (store) {\n            var keyPath = store.keyPath,\n              autoIncrement = store.autoIncrement;\n            var compound = isArray(keyPath);\n            var outbound = keyPath == null;\n            var indexByKeyPath = {};\n            var result = {\n              name: store.name,\n              primaryKey: {\n                name: null,\n                isPrimaryKey: true,\n                outbound: outbound,\n                compound: compound,\n                keyPath: keyPath,\n                autoIncrement: autoIncrement,\n                unique: true,\n                extractKey: getKeyExtractor(keyPath)\n              },\n              indexes: arrayify(store.indexNames).map(function (indexName) {\n                return store.index(indexName);\n              }).map(function (index) {\n                var name = index.name,\n                  unique = index.unique,\n                  multiEntry = index.multiEntry,\n                  keyPath = index.keyPath;\n                var compound = isArray(keyPath);\n                var result = {\n                  name: name,\n                  compound: compound,\n                  keyPath: keyPath,\n                  unique: unique,\n                  multiEntry: multiEntry,\n                  extractKey: getKeyExtractor(keyPath)\n                };\n                indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n                return result;\n              }),\n              getIndexByKeyPath: function (keyPath) {\n                return indexByKeyPath[getKeyPathAlias(keyPath)];\n              }\n            };\n            indexByKeyPath[\":id\"] = result.primaryKey;\n            if (keyPath != null) {\n              indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n            }\n            return result;\n          })\n        },\n        hasGetAll: tables.length > 0 && 'getAll' in trans.objectStore(tables[0]) && !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n      };\n    }\n    function makeIDBKeyRange(range) {\n      if (range.type === 3) return null;\n      if (range.type === 4) throw new Error(\"Cannot convert never type to IDBKeyRange\");\n      var lower = range.lower,\n        upper = range.upper,\n        lowerOpen = range.lowerOpen,\n        upperOpen = range.upperOpen;\n      var idbRange = lower === undefined ? upper === undefined ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === undefined ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n      return idbRange;\n    }\n    function createDbCoreTable(tableSchema) {\n      var tableName = tableSchema.name;\n      function mutate(_a) {\n        var trans = _a.trans,\n          type = _a.type,\n          keys = _a.keys,\n          values = _a.values,\n          range = _a.range;\n        return new Promise(function (resolve, reject) {\n          resolve = wrap(resolve);\n          var store = trans.objectStore(tableName);\n          var outbound = store.keyPath == null;\n          var isAddOrPut = type === \"put\" || type === \"add\";\n          if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange') throw new Error(\"Invalid operation type: \" + type);\n          var length = (keys || values || {\n            length: 1\n          }).length;\n          if (keys && values && keys.length !== values.length) {\n            throw new Error(\"Given keys array must have same length as given values array.\");\n          }\n          if (length === 0) return resolve({\n            numFailures: 0,\n            failures: {},\n            results: [],\n            lastResult: undefined\n          });\n          var req;\n          var reqs = [];\n          var failures = [];\n          var numFailures = 0;\n          var errorHandler = function (event) {\n            ++numFailures;\n            preventDefault(event);\n          };\n          if (type === 'deleteRange') {\n            if (range.type === 4) return resolve({\n              numFailures: numFailures,\n              failures: failures,\n              results: [],\n              lastResult: undefined\n            });\n            if (range.type === 3) reqs.push(req = store.clear());else reqs.push(req = store.delete(makeIDBKeyRange(range)));\n          } else {\n            var _a = isAddOrPut ? outbound ? [values, keys] : [values, null] : [keys, null],\n              args1 = _a[0],\n              args2 = _a[1];\n            if (isAddOrPut) {\n              for (var i = 0; i < length; ++i) {\n                reqs.push(req = args2 && args2[i] !== undefined ? store[type](args1[i], args2[i]) : store[type](args1[i]));\n                req.onerror = errorHandler;\n              }\n            } else {\n              for (var i = 0; i < length; ++i) {\n                reqs.push(req = store[type](args1[i]));\n                req.onerror = errorHandler;\n              }\n            }\n          }\n          var done = function (event) {\n            var lastResult = event.target.result;\n            reqs.forEach(function (req, i) {\n              return req.error != null && (failures[i] = req.error);\n            });\n            resolve({\n              numFailures: numFailures,\n              failures: failures,\n              results: type === \"delete\" ? keys : reqs.map(function (req) {\n                return req.result;\n              }),\n              lastResult: lastResult\n            });\n          };\n          req.onerror = function (event) {\n            errorHandler(event);\n            done(event);\n          };\n          req.onsuccess = done;\n        });\n      }\n      function openCursor(_a) {\n        var trans = _a.trans,\n          values = _a.values,\n          query = _a.query,\n          reverse = _a.reverse,\n          unique = _a.unique;\n        return new Promise(function (resolve, reject) {\n          resolve = wrap(resolve);\n          var index = query.index,\n            range = query.range;\n          var store = trans.objectStore(tableName);\n          var source = index.isPrimaryKey ? store : store.index(index.name);\n          var direction = reverse ? unique ? \"prevunique\" : \"prev\" : unique ? \"nextunique\" : \"next\";\n          var req = values || !('openKeyCursor' in source) ? source.openCursor(makeIDBKeyRange(range), direction) : source.openKeyCursor(makeIDBKeyRange(range), direction);\n          req.onerror = eventRejectHandler(reject);\n          req.onsuccess = wrap(function (ev) {\n            var cursor = req.result;\n            if (!cursor) {\n              resolve(null);\n              return;\n            }\n            cursor.___id = ++_id_counter;\n            cursor.done = false;\n            var _cursorContinue = cursor.continue.bind(cursor);\n            var _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n            if (_cursorContinuePrimaryKey) _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n            var _cursorAdvance = cursor.advance.bind(cursor);\n            var doThrowCursorIsNotStarted = function () {\n              throw new Error(\"Cursor not started\");\n            };\n            var doThrowCursorIsStopped = function () {\n              throw new Error(\"Cursor not stopped\");\n            };\n            cursor.trans = trans;\n            cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n            cursor.fail = wrap(reject);\n            cursor.next = function () {\n              var _this = this;\n              var gotOne = 1;\n              return this.start(function () {\n                return gotOne-- ? _this.continue() : _this.stop();\n              }).then(function () {\n                return _this;\n              });\n            };\n            cursor.start = function (callback) {\n              var iterationPromise = new Promise(function (resolveIteration, rejectIteration) {\n                resolveIteration = wrap(resolveIteration);\n                req.onerror = eventRejectHandler(rejectIteration);\n                cursor.fail = rejectIteration;\n                cursor.stop = function (value) {\n                  cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n                  resolveIteration(value);\n                };\n              });\n              var guardedCallback = function () {\n                if (req.result) {\n                  try {\n                    callback();\n                  } catch (err) {\n                    cursor.fail(err);\n                  }\n                } else {\n                  cursor.done = true;\n                  cursor.start = function () {\n                    throw new Error(\"Cursor behind last entry\");\n                  };\n                  cursor.stop();\n                }\n              };\n              req.onsuccess = wrap(function (ev) {\n                req.onsuccess = guardedCallback;\n                guardedCallback();\n              });\n              cursor.continue = _cursorContinue;\n              cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n              cursor.advance = _cursorAdvance;\n              guardedCallback();\n              return iterationPromise;\n            };\n            resolve(cursor);\n          }, reject);\n        });\n      }\n      function query(hasGetAll) {\n        return function (request) {\n          return new Promise(function (resolve, reject) {\n            resolve = wrap(resolve);\n            var trans = request.trans,\n              values = request.values,\n              limit = request.limit,\n              query = request.query;\n            var nonInfinitLimit = limit === Infinity ? undefined : limit;\n            var index = query.index,\n              range = query.range;\n            var store = trans.objectStore(tableName);\n            var source = index.isPrimaryKey ? store : store.index(index.name);\n            var idbKeyRange = makeIDBKeyRange(range);\n            if (limit === 0) return resolve({\n              result: []\n            });\n            if (hasGetAll) {\n              var req = values ? source.getAll(idbKeyRange, nonInfinitLimit) : source.getAllKeys(idbKeyRange, nonInfinitLimit);\n              req.onsuccess = function (event) {\n                return resolve({\n                  result: event.target.result\n                });\n              };\n              req.onerror = eventRejectHandler(reject);\n            } else {\n              var count_1 = 0;\n              var req_1 = values || !('openKeyCursor' in source) ? source.openCursor(idbKeyRange) : source.openKeyCursor(idbKeyRange);\n              var result_1 = [];\n              req_1.onsuccess = function (event) {\n                var cursor = req_1.result;\n                if (!cursor) return resolve({\n                  result: result_1\n                });\n                result_1.push(values ? cursor.value : cursor.primaryKey);\n                if (++count_1 === limit) return resolve({\n                  result: result_1\n                });\n                cursor.continue();\n              };\n              req_1.onerror = eventRejectHandler(reject);\n            }\n          });\n        };\n      }\n      return {\n        name: tableName,\n        schema: tableSchema,\n        mutate: mutate,\n        getMany: function (_a) {\n          var trans = _a.trans,\n            keys = _a.keys;\n          return new Promise(function (resolve, reject) {\n            resolve = wrap(resolve);\n            var store = trans.objectStore(tableName);\n            var length = keys.length;\n            var result = new Array(length);\n            var keyCount = 0;\n            var callbackCount = 0;\n            var req;\n            var successHandler = function (event) {\n              var req = event.target;\n              if ((result[req._pos] = req.result) != null) ;\n              if (++callbackCount === keyCount) resolve(result);\n            };\n            var errorHandler = eventRejectHandler(reject);\n            for (var i = 0; i < length; ++i) {\n              var key = keys[i];\n              if (key != null) {\n                req = store.get(keys[i]);\n                req._pos = i;\n                req.onsuccess = successHandler;\n                req.onerror = errorHandler;\n                ++keyCount;\n              }\n            }\n            if (keyCount === 0) resolve(result);\n          });\n        },\n        get: function (_a) {\n          var trans = _a.trans,\n            key = _a.key;\n          return new Promise(function (resolve, reject) {\n            resolve = wrap(resolve);\n            var store = trans.objectStore(tableName);\n            var req = store.get(key);\n            req.onsuccess = function (event) {\n              return resolve(event.target.result);\n            };\n            req.onerror = eventRejectHandler(reject);\n          });\n        },\n        query: query(hasGetAll),\n        openCursor: openCursor,\n        count: function (_a) {\n          var query = _a.query,\n            trans = _a.trans;\n          var index = query.index,\n            range = query.range;\n          return new Promise(function (resolve, reject) {\n            var store = trans.objectStore(tableName);\n            var source = index.isPrimaryKey ? store : store.index(index.name);\n            var idbKeyRange = makeIDBKeyRange(range);\n            var req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n            req.onsuccess = wrap(function (ev) {\n              return resolve(ev.target.result);\n            });\n            req.onerror = eventRejectHandler(reject);\n          });\n        }\n      };\n    }\n    var _a = extractSchema(db, tmpTrans),\n      schema = _a.schema,\n      hasGetAll = _a.hasGetAll;\n    var tables = schema.tables.map(function (tableSchema) {\n      return createDbCoreTable(tableSchema);\n    });\n    var tableMap = {};\n    tables.forEach(function (table) {\n      return tableMap[table.name] = table;\n    });\n    return {\n      stack: \"dbcore\",\n      transaction: db.transaction.bind(db),\n      table: function (name) {\n        var result = tableMap[name];\n        if (!result) throw new Error(\"Table '\" + name + \"' not found\");\n        return tableMap[name];\n      },\n      MIN_KEY: -Infinity,\n      MAX_KEY: getMaxKey(IdbKeyRange),\n      schema: schema\n    };\n  }\n  function createMiddlewareStack(stackImpl, middlewares) {\n    return middlewares.reduce(function (down, _a) {\n      var create = _a.create;\n      return __assign(__assign({}, down), create(down));\n    }, stackImpl);\n  }\n  function createMiddlewareStacks(middlewares, idbdb, _a, tmpTrans) {\n    var IDBKeyRange = _a.IDBKeyRange;\n    _a.indexedDB;\n    var dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n    return {\n      dbcore: dbcore\n    };\n  }\n  function generateMiddlewareStacks(_a, tmpTrans) {\n    var db = _a._novip;\n    var idbdb = tmpTrans.db;\n    var stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n    db.core = stacks.dbcore;\n    db.tables.forEach(function (table) {\n      var tableName = table.name;\n      if (db.core.schema.tables.some(function (tbl) {\n        return tbl.name === tableName;\n      })) {\n        table.core = db.core.table(tableName);\n        if (db[tableName] instanceof db.Table) {\n          db[tableName].core = table.core;\n        }\n      }\n    });\n  }\n  function setApiOnPlace(_a, objs, tableNames, dbschema) {\n    var db = _a._novip;\n    tableNames.forEach(function (tableName) {\n      var schema = dbschema[tableName];\n      objs.forEach(function (obj) {\n        var propDesc = getPropertyDescriptor(obj, tableName);\n        if (!propDesc || \"value\" in propDesc && propDesc.value === undefined) {\n          if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n            setProp(obj, tableName, {\n              get: function () {\n                return this.table(tableName);\n              },\n              set: function (value) {\n                defineProperty(this, tableName, {\n                  value: value,\n                  writable: true,\n                  configurable: true,\n                  enumerable: true\n                });\n              }\n            });\n          } else {\n            obj[tableName] = new db.Table(tableName, schema);\n          }\n        }\n      });\n    });\n  }\n  function removeTablesApi(_a, objs) {\n    var db = _a._novip;\n    objs.forEach(function (obj) {\n      for (var key in obj) {\n        if (obj[key] instanceof db.Table) delete obj[key];\n      }\n    });\n  }\n  function lowerVersionFirst(a, b) {\n    return a._cfg.version - b._cfg.version;\n  }\n  function runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n    var globalSchema = db._dbSchema;\n    var trans = db._createTransaction('readwrite', db._storeNames, globalSchema);\n    trans.create(idbUpgradeTrans);\n    trans._completion.catch(reject);\n    var rejectTransaction = trans._reject.bind(trans);\n    var transless = PSD.transless || PSD;\n    newScope(function () {\n      PSD.trans = trans;\n      PSD.transless = transless;\n      if (oldVersion === 0) {\n        keys(globalSchema).forEach(function (tableName) {\n          createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n        });\n        generateMiddlewareStacks(db, idbUpgradeTrans);\n        DexiePromise.follow(function () {\n          return db.on.populate.fire(trans);\n        }).catch(rejectTransaction);\n      } else updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);\n    });\n  }\n  function updateTablesAndIndexes(_a, oldVersion, trans, idbUpgradeTrans) {\n    var db = _a._novip;\n    var queue = [];\n    var versions = db._versions;\n    var globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n    var anyContentUpgraderHasRun = false;\n    var versToRun = versions.filter(function (v) {\n      return v._cfg.version >= oldVersion;\n    });\n    versToRun.forEach(function (version) {\n      queue.push(function () {\n        var oldSchema = globalSchema;\n        var newSchema = version._cfg.dbschema;\n        adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n        adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n        globalSchema = db._dbSchema = newSchema;\n        var diff = getSchemaDiff(oldSchema, newSchema);\n        diff.add.forEach(function (tuple) {\n          createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n        });\n        diff.change.forEach(function (change) {\n          if (change.recreate) {\n            throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n          } else {\n            var store_1 = idbUpgradeTrans.objectStore(change.name);\n            change.add.forEach(function (idx) {\n              return addIndex(store_1, idx);\n            });\n            change.change.forEach(function (idx) {\n              store_1.deleteIndex(idx.name);\n              addIndex(store_1, idx);\n            });\n            change.del.forEach(function (idxName) {\n              return store_1.deleteIndex(idxName);\n            });\n          }\n        });\n        var contentUpgrade = version._cfg.contentUpgrade;\n        if (contentUpgrade && version._cfg.version > oldVersion) {\n          generateMiddlewareStacks(db, idbUpgradeTrans);\n          trans._memoizedTables = {};\n          anyContentUpgraderHasRun = true;\n          var upgradeSchema_1 = shallowClone(newSchema);\n          diff.del.forEach(function (table) {\n            upgradeSchema_1[table] = oldSchema[table];\n          });\n          removeTablesApi(db, [db.Transaction.prototype]);\n          setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema_1), upgradeSchema_1);\n          trans.schema = upgradeSchema_1;\n          var contentUpgradeIsAsync_1 = isAsyncFunction(contentUpgrade);\n          if (contentUpgradeIsAsync_1) {\n            incrementExpectedAwaits();\n          }\n          var returnValue_1;\n          var promiseFollowed = DexiePromise.follow(function () {\n            returnValue_1 = contentUpgrade(trans);\n            if (returnValue_1) {\n              if (contentUpgradeIsAsync_1) {\n                var decrementor = decrementExpectedAwaits.bind(null, null);\n                returnValue_1.then(decrementor, decrementor);\n              }\n            }\n          });\n          return returnValue_1 && typeof returnValue_1.then === 'function' ? DexiePromise.resolve(returnValue_1) : promiseFollowed.then(function () {\n            return returnValue_1;\n          });\n        }\n      });\n      queue.push(function (idbtrans) {\n        if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {\n          var newSchema = version._cfg.dbschema;\n          deleteRemovedTables(newSchema, idbtrans);\n        }\n        removeTablesApi(db, [db.Transaction.prototype]);\n        setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);\n        trans.schema = db._dbSchema;\n      });\n    });\n    function runQueue() {\n      return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();\n    }\n    return runQueue().then(function () {\n      createMissingTables(globalSchema, idbUpgradeTrans);\n    });\n  }\n  function getSchemaDiff(oldSchema, newSchema) {\n    var diff = {\n      del: [],\n      add: [],\n      change: []\n    };\n    var table;\n    for (table in oldSchema) {\n      if (!newSchema[table]) diff.del.push(table);\n    }\n    for (table in newSchema) {\n      var oldDef = oldSchema[table],\n        newDef = newSchema[table];\n      if (!oldDef) {\n        diff.add.push([table, newDef]);\n      } else {\n        var change = {\n          name: table,\n          def: newDef,\n          recreate: false,\n          del: [],\n          add: [],\n          change: []\n        };\n        if ('' + (oldDef.primKey.keyPath || '') !== '' + (newDef.primKey.keyPath || '') || oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge) {\n          change.recreate = true;\n          diff.change.push(change);\n        } else {\n          var oldIndexes = oldDef.idxByName;\n          var newIndexes = newDef.idxByName;\n          var idxName = void 0;\n          for (idxName in oldIndexes) {\n            if (!newIndexes[idxName]) change.del.push(idxName);\n          }\n          for (idxName in newIndexes) {\n            var oldIdx = oldIndexes[idxName],\n              newIdx = newIndexes[idxName];\n            if (!oldIdx) change.add.push(newIdx);else if (oldIdx.src !== newIdx.src) change.change.push(newIdx);\n          }\n          if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n            diff.change.push(change);\n          }\n        }\n      }\n    }\n    return diff;\n  }\n  function createTable(idbtrans, tableName, primKey, indexes) {\n    var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? {\n      keyPath: primKey.keyPath,\n      autoIncrement: primKey.auto\n    } : {\n      autoIncrement: primKey.auto\n    });\n    indexes.forEach(function (idx) {\n      return addIndex(store, idx);\n    });\n    return store;\n  }\n  function createMissingTables(newSchema, idbtrans) {\n    keys(newSchema).forEach(function (tableName) {\n      if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n        createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n      }\n    });\n  }\n  function deleteRemovedTables(newSchema, idbtrans) {\n    [].slice.call(idbtrans.db.objectStoreNames).forEach(function (storeName) {\n      return newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName);\n    });\n  }\n  function addIndex(store, idx) {\n    store.createIndex(idx.name, idx.keyPath, {\n      unique: idx.unique,\n      multiEntry: idx.multi\n    });\n  }\n  function buildGlobalSchema(db, idbdb, tmpTrans) {\n    var globalSchema = {};\n    var dbStoreNames = slice(idbdb.objectStoreNames, 0);\n    dbStoreNames.forEach(function (storeName) {\n      var store = tmpTrans.objectStore(storeName);\n      var keyPath = store.keyPath;\n      var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n      var indexes = [];\n      for (var j = 0; j < store.indexNames.length; ++j) {\n        var idbindex = store.index(store.indexNames[j]);\n        keyPath = idbindex.keyPath;\n        var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n        indexes.push(index);\n      }\n      globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n    });\n    return globalSchema;\n  }\n  function readGlobalSchema(_a, idbdb, tmpTrans) {\n    var db = _a._novip;\n    db.verno = idbdb.version / 10;\n    var globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n    db._storeNames = slice(idbdb.objectStoreNames, 0);\n    setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);\n  }\n  function verifyInstalledSchema(db, tmpTrans) {\n    var installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n    var diff = getSchemaDiff(installedSchema, db._dbSchema);\n    return !(diff.add.length || diff.change.some(function (ch) {\n      return ch.add.length || ch.change.length;\n    }));\n  }\n  function adjustToExistingIndexNames(_a, schema, idbtrans) {\n    var db = _a._novip;\n    var storeNames = idbtrans.db.objectStoreNames;\n    for (var i = 0; i < storeNames.length; ++i) {\n      var storeName = storeNames[i];\n      var store = idbtrans.objectStore(storeName);\n      db._hasGetAll = 'getAll' in store;\n      for (var j = 0; j < store.indexNames.length; ++j) {\n        var indexName = store.indexNames[j];\n        var keyPath = store.index(indexName).keyPath;\n        var dexieName = typeof keyPath === 'string' ? keyPath : \"[\" + slice(keyPath).join('+') + \"]\";\n        if (schema[storeName]) {\n          var indexSpec = schema[storeName].idxByName[dexieName];\n          if (indexSpec) {\n            indexSpec.name = indexName;\n            delete schema[storeName].idxByName[dexieName];\n            schema[storeName].idxByName[indexName] = indexSpec;\n          }\n        }\n      }\n    }\n    if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n      db._hasGetAll = false;\n    }\n  }\n  function parseIndexSyntax(primKeyAndIndexes) {\n    return primKeyAndIndexes.split(',').map(function (index, indexNum) {\n      index = index.trim();\n      var name = index.replace(/([&*]|\\+\\+)/g, \"\");\n      var keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split('+') : name;\n      return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0);\n    });\n  }\n  var Version = function () {\n    function Version() {}\n    Version.prototype._parseStoresSpec = function (stores, outSchema) {\n      keys(stores).forEach(function (tableName) {\n        if (stores[tableName] !== null) {\n          var indexes = parseIndexSyntax(stores[tableName]);\n          var primKey = indexes.shift();\n          if (primKey.multi) throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n          indexes.forEach(function (idx) {\n            if (idx.auto) throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n            if (!idx.keyPath) throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n          });\n          outSchema[tableName] = createTableSchema(tableName, primKey, indexes);\n        }\n      });\n    };\n    Version.prototype.stores = function (stores) {\n      var db = this.db;\n      this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, stores) : stores;\n      var versions = db._versions;\n      var storesSpec = {};\n      var dbschema = {};\n      versions.forEach(function (version) {\n        extend(storesSpec, version._cfg.storesSource);\n        dbschema = version._cfg.dbschema = {};\n        version._parseStoresSpec(storesSpec, dbschema);\n      });\n      db._dbSchema = dbschema;\n      removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);\n      setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\n      db._storeNames = keys(dbschema);\n      return this;\n    };\n    Version.prototype.upgrade = function (upgradeFunction) {\n      this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n      return this;\n    };\n    return Version;\n  }();\n  function createVersionConstructor(db) {\n    return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n      this.db = db;\n      this._cfg = {\n        version: versionNumber,\n        storesSource: null,\n        dbschema: {},\n        tables: {},\n        contentUpgrade: null\n      };\n    });\n  }\n  function getDbNamesTable(indexedDB, IDBKeyRange) {\n    var dbNamesDB = indexedDB[\"_dbNamesDB\"];\n    if (!dbNamesDB) {\n      dbNamesDB = indexedDB[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n        addons: [],\n        indexedDB: indexedDB,\n        IDBKeyRange: IDBKeyRange\n      });\n      dbNamesDB.version(1).stores({\n        dbnames: \"name\"\n      });\n    }\n    return dbNamesDB.table(\"dbnames\");\n  }\n  function hasDatabasesNative(indexedDB) {\n    return indexedDB && typeof indexedDB.databases === \"function\";\n  }\n  function getDatabaseNames(_a) {\n    var indexedDB = _a.indexedDB,\n      IDBKeyRange = _a.IDBKeyRange;\n    return hasDatabasesNative(indexedDB) ? Promise.resolve(indexedDB.databases()).then(function (infos) {\n      return infos.map(function (info) {\n        return info.name;\n      }).filter(function (name) {\n        return name !== DBNAMES_DB;\n      });\n    }) : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();\n  }\n  function _onDatabaseCreated(_a, name) {\n    var indexedDB = _a.indexedDB,\n      IDBKeyRange = _a.IDBKeyRange;\n    !hasDatabasesNative(indexedDB) && name !== DBNAMES_DB && getDbNamesTable(indexedDB, IDBKeyRange).put({\n      name: name\n    }).catch(nop);\n  }\n  function _onDatabaseDeleted(_a, name) {\n    var indexedDB = _a.indexedDB,\n      IDBKeyRange = _a.IDBKeyRange;\n    !hasDatabasesNative(indexedDB) && name !== DBNAMES_DB && getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);\n  }\n  function vip(fn) {\n    return newScope(function () {\n      PSD.letThrough = true;\n      return fn();\n    });\n  }\n  function idbReady() {\n    var isSafari = !navigator.userAgentData && /Safari\\//.test(navigator.userAgent) && !/Chrom(e|ium)\\//.test(navigator.userAgent);\n    if (!isSafari || !indexedDB.databases) return Promise.resolve();\n    var intervalId;\n    return new Promise(function (resolve) {\n      var tryIdb = function () {\n        return indexedDB.databases().finally(resolve);\n      };\n      intervalId = setInterval(tryIdb, 100);\n      tryIdb();\n    }).finally(function () {\n      return clearInterval(intervalId);\n    });\n  }\n  function dexieOpen(db) {\n    var state = db._state;\n    var indexedDB = db._deps.indexedDB;\n    if (state.isBeingOpened || db.idbdb) return state.dbReadyPromise.then(function () {\n      return state.dbOpenError ? rejection(state.dbOpenError) : db;\n    });\n    debug && (state.openCanceller._stackHolder = getErrorWithStack());\n    state.isBeingOpened = true;\n    state.dbOpenError = null;\n    state.openComplete = false;\n    var openCanceller = state.openCanceller;\n    function throwIfCancelled() {\n      if (state.openCanceller !== openCanceller) throw new exceptions.DatabaseClosed('db.open() was cancelled');\n    }\n    var resolveDbReady = state.dbReadyResolve,\n      upgradeTransaction = null,\n      wasCreated = false;\n    return DexiePromise.race([openCanceller, (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(function () {\n      return new DexiePromise(function (resolve, reject) {\n        throwIfCancelled();\n        if (!indexedDB) throw new exceptions.MissingAPI();\n        var dbName = db.name;\n        var req = state.autoSchema ? indexedDB.open(dbName) : indexedDB.open(dbName, Math.round(db.verno * 10));\n        if (!req) throw new exceptions.MissingAPI();\n        req.onerror = eventRejectHandler(reject);\n        req.onblocked = wrap(db._fireOnBlocked);\n        req.onupgradeneeded = wrap(function (e) {\n          upgradeTransaction = req.transaction;\n          if (state.autoSchema && !db._options.allowEmptyDB) {\n            req.onerror = preventDefault;\n            upgradeTransaction.abort();\n            req.result.close();\n            var delreq = indexedDB.deleteDatabase(dbName);\n            delreq.onsuccess = delreq.onerror = wrap(function () {\n              reject(new exceptions.NoSuchDatabase(\"Database \" + dbName + \" doesnt exist\"));\n            });\n          } else {\n            upgradeTransaction.onerror = eventRejectHandler(reject);\n            var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n            wasCreated = oldVer < 1;\n            db._novip.idbdb = req.result;\n            runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n          }\n        }, reject);\n        req.onsuccess = wrap(function () {\n          upgradeTransaction = null;\n          var idbdb = db._novip.idbdb = req.result;\n          var objectStoreNames = slice(idbdb.objectStoreNames);\n          if (objectStoreNames.length > 0) try {\n            var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');\n            if (state.autoSchema) readGlobalSchema(db, idbdb, tmpTrans);else {\n              adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n              if (!verifyInstalledSchema(db, tmpTrans)) {\n                console.warn(\"Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.\");\n              }\n            }\n            generateMiddlewareStacks(db, tmpTrans);\n          } catch (e) {}\n          connections.push(db);\n          idbdb.onversionchange = wrap(function (ev) {\n            state.vcFired = true;\n            db.on(\"versionchange\").fire(ev);\n          });\n          idbdb.onclose = wrap(function (ev) {\n            db.on(\"close\").fire(ev);\n          });\n          if (wasCreated) _onDatabaseCreated(db._deps, dbName);\n          resolve();\n        }, reject);\n      });\n    })]).then(function () {\n      throwIfCancelled();\n      state.onReadyBeingFired = [];\n      return DexiePromise.resolve(vip(function () {\n        return db.on.ready.fire(db.vip);\n      })).then(function fireRemainders() {\n        if (state.onReadyBeingFired.length > 0) {\n          var remainders_1 = state.onReadyBeingFired.reduce(promisableChain, nop);\n          state.onReadyBeingFired = [];\n          return DexiePromise.resolve(vip(function () {\n            return remainders_1(db.vip);\n          })).then(fireRemainders);\n        }\n      });\n    }).finally(function () {\n      state.onReadyBeingFired = null;\n      state.isBeingOpened = false;\n    }).then(function () {\n      return db;\n    }).catch(function (err) {\n      state.dbOpenError = err;\n      try {\n        upgradeTransaction && upgradeTransaction.abort();\n      } catch (_a) {}\n      if (openCanceller === state.openCanceller) {\n        db._close();\n      }\n      return rejection(err);\n    }).finally(function () {\n      state.openComplete = true;\n      resolveDbReady();\n    });\n  }\n  function awaitIterator(iterator) {\n    var callNext = function (result) {\n        return iterator.next(result);\n      },\n      doThrow = function (error) {\n        return iterator.throw(error);\n      },\n      onSuccess = step(callNext),\n      onError = step(doThrow);\n    function step(getNext) {\n      return function (val) {\n        var next = getNext(val),\n          value = next.value;\n        return next.done ? value : !value || typeof value.then !== 'function' ? isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);\n      };\n    }\n    return step(callNext)();\n  }\n  function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n    var i = arguments.length;\n    if (i < 2) throw new exceptions.InvalidArgument(\"Too few arguments\");\n    var args = new Array(i - 1);\n    while (--i) args[i - 1] = arguments[i];\n    scopeFunc = args.pop();\n    var tables = flatten(args);\n    return [mode, tables, scopeFunc];\n  }\n  function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n    return DexiePromise.resolve().then(function () {\n      var transless = PSD.transless || PSD;\n      var trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n      var zoneProps = {\n        trans: trans,\n        transless: transless\n      };\n      if (parentTransaction) {\n        trans.idbtrans = parentTransaction.idbtrans;\n      } else {\n        try {\n          trans.create();\n          db._state.PR1398_maxLoop = 3;\n        } catch (ex) {\n          if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n            console.warn('Dexie: Need to reopen db');\n            db._close();\n            return db.open().then(function () {\n              return enterTransactionScope(db, mode, storeNames, null, scopeFunc);\n            });\n          }\n          return rejection(ex);\n        }\n      }\n      var scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n      if (scopeFuncIsAsync) {\n        incrementExpectedAwaits();\n      }\n      var returnValue;\n      var promiseFollowed = DexiePromise.follow(function () {\n        returnValue = scopeFunc.call(trans, trans);\n        if (returnValue) {\n          if (scopeFuncIsAsync) {\n            var decrementor = decrementExpectedAwaits.bind(null, null);\n            returnValue.then(decrementor, decrementor);\n          } else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\n            returnValue = awaitIterator(returnValue);\n          }\n        }\n      }, zoneProps);\n      return (returnValue && typeof returnValue.then === 'function' ? DexiePromise.resolve(returnValue).then(function (x) {\n        return trans.active ? x : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\"));\n      }) : promiseFollowed.then(function () {\n        return returnValue;\n      })).then(function (x) {\n        if (parentTransaction) trans._resolve();\n        return trans._completion.then(function () {\n          return x;\n        });\n      }).catch(function (e) {\n        trans._reject(e);\n        return rejection(e);\n      });\n    });\n  }\n  function pad(a, value, count) {\n    var result = isArray(a) ? a.slice() : [a];\n    for (var i = 0; i < count; ++i) result.push(value);\n    return result;\n  }\n  function createVirtualIndexMiddleware(down) {\n    return __assign(__assign({}, down), {\n      table: function (tableName) {\n        var table = down.table(tableName);\n        var schema = table.schema;\n        var indexLookup = {};\n        var allVirtualIndexes = [];\n        function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n          var keyPathAlias = getKeyPathAlias(keyPath);\n          var indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];\n          var keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;\n          var isVirtual = keyTail > 0;\n          var virtualIndex = __assign(__assign({}, lowLevelIndex), {\n            isVirtual: isVirtual,\n            keyTail: keyTail,\n            keyLength: keyLength,\n            extractKey: getKeyExtractor(keyPath),\n            unique: !isVirtual && lowLevelIndex.unique\n          });\n          indexList.push(virtualIndex);\n          if (!virtualIndex.isPrimaryKey) {\n            allVirtualIndexes.push(virtualIndex);\n          }\n          if (keyLength > 1) {\n            var virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);\n            addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n          }\n          indexList.sort(function (a, b) {\n            return a.keyTail - b.keyTail;\n          });\n          return virtualIndex;\n        }\n        var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n        indexLookup[\":id\"] = [primaryKey];\n        for (var _i = 0, _a = schema.indexes; _i < _a.length; _i++) {\n          var index = _a[_i];\n          addVirtualIndexes(index.keyPath, 0, index);\n        }\n        function findBestIndex(keyPath) {\n          var result = indexLookup[getKeyPathAlias(keyPath)];\n          return result && result[0];\n        }\n        function translateRange(range, keyTail) {\n          return {\n            type: range.type === 1 ? 2 : range.type,\n            lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n            lowerOpen: true,\n            upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n            upperOpen: true\n          };\n        }\n        function translateRequest(req) {\n          var index = req.query.index;\n          return index.isVirtual ? __assign(__assign({}, req), {\n            query: {\n              index: index,\n              range: translateRange(req.query.range, index.keyTail)\n            }\n          }) : req;\n        }\n        var result = __assign(__assign({}, table), {\n          schema: __assign(__assign({}, schema), {\n            primaryKey: primaryKey,\n            indexes: allVirtualIndexes,\n            getIndexByKeyPath: findBestIndex\n          }),\n          count: function (req) {\n            return table.count(translateRequest(req));\n          },\n          query: function (req) {\n            return table.query(translateRequest(req));\n          },\n          openCursor: function (req) {\n            var _a = req.query.index,\n              keyTail = _a.keyTail,\n              isVirtual = _a.isVirtual,\n              keyLength = _a.keyLength;\n            if (!isVirtual) return table.openCursor(req);\n            function createVirtualCursor(cursor) {\n              function _continue(key) {\n                key != null ? cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor.continue(cursor.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor.continue();\n              }\n              var virtualCursor = Object.create(cursor, {\n                continue: {\n                  value: _continue\n                },\n                continuePrimaryKey: {\n                  value: function (key, primaryKey) {\n                    cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n                  }\n                },\n                primaryKey: {\n                  get: function () {\n                    return cursor.primaryKey;\n                  }\n                },\n                key: {\n                  get: function () {\n                    var key = cursor.key;\n                    return keyLength === 1 ? key[0] : key.slice(0, keyLength);\n                  }\n                },\n                value: {\n                  get: function () {\n                    return cursor.value;\n                  }\n                }\n              });\n              return virtualCursor;\n            }\n            return table.openCursor(translateRequest(req)).then(function (cursor) {\n              return cursor && createVirtualCursor(cursor);\n            });\n          }\n        });\n        return result;\n      }\n    });\n  }\n  var virtualIndexMiddleware = {\n    stack: \"dbcore\",\n    name: \"VirtualIndexMiddleware\",\n    level: 1,\n    create: createVirtualIndexMiddleware\n  };\n  function getObjectDiff(a, b, rv, prfx) {\n    rv = rv || {};\n    prfx = prfx || '';\n    keys(a).forEach(function (prop) {\n      if (!hasOwn(b, prop)) {\n        rv[prfx + prop] = undefined;\n      } else {\n        var ap = a[prop],\n          bp = b[prop];\n        if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {\n          var apTypeName = toStringTag(ap);\n          var bpTypeName = toStringTag(bp);\n          if (apTypeName !== bpTypeName) {\n            rv[prfx + prop] = b[prop];\n          } else if (apTypeName === 'Object') {\n            getObjectDiff(ap, bp, rv, prfx + prop + '.');\n          } else if (ap !== bp) {\n            rv[prfx + prop] = b[prop];\n          }\n        } else if (ap !== bp) rv[prfx + prop] = b[prop];\n      }\n    });\n    keys(b).forEach(function (prop) {\n      if (!hasOwn(a, prop)) {\n        rv[prfx + prop] = b[prop];\n      }\n    });\n    return rv;\n  }\n  function getEffectiveKeys(primaryKey, req) {\n    if (req.type === 'delete') return req.keys;\n    return req.keys || req.values.map(primaryKey.extractKey);\n  }\n  var hooksMiddleware = {\n    stack: \"dbcore\",\n    name: \"HooksMiddleware\",\n    level: 2,\n    create: function (downCore) {\n      return __assign(__assign({}, downCore), {\n        table: function (tableName) {\n          var downTable = downCore.table(tableName);\n          var primaryKey = downTable.schema.primaryKey;\n          var tableMiddleware = __assign(__assign({}, downTable), {\n            mutate: function (req) {\n              var dxTrans = PSD.trans;\n              var _a = dxTrans.table(tableName).hook,\n                deleting = _a.deleting,\n                creating = _a.creating,\n                updating = _a.updating;\n              switch (req.type) {\n                case 'add':\n                  if (creating.fire === nop) break;\n                  return dxTrans._promise('readwrite', function () {\n                    return addPutOrDelete(req);\n                  }, true);\n                case 'put':\n                  if (creating.fire === nop && updating.fire === nop) break;\n                  return dxTrans._promise('readwrite', function () {\n                    return addPutOrDelete(req);\n                  }, true);\n                case 'delete':\n                  if (deleting.fire === nop) break;\n                  return dxTrans._promise('readwrite', function () {\n                    return addPutOrDelete(req);\n                  }, true);\n                case 'deleteRange':\n                  if (deleting.fire === nop) break;\n                  return dxTrans._promise('readwrite', function () {\n                    return deleteRange(req);\n                  }, true);\n              }\n              return downTable.mutate(req);\n              function addPutOrDelete(req) {\n                var dxTrans = PSD.trans;\n                var keys = req.keys || getEffectiveKeys(primaryKey, req);\n                if (!keys) throw new Error(\"Keys missing\");\n                req = req.type === 'add' || req.type === 'put' ? __assign(__assign({}, req), {\n                  keys: keys\n                }) : __assign({}, req);\n                if (req.type !== 'delete') req.values = __spreadArray([], req.values, true);\n                if (req.keys) req.keys = __spreadArray([], req.keys, true);\n                return getExistingValues(downTable, req, keys).then(function (existingValues) {\n                  var contexts = keys.map(function (key, i) {\n                    var existingValue = existingValues[i];\n                    var ctx = {\n                      onerror: null,\n                      onsuccess: null\n                    };\n                    if (req.type === 'delete') {\n                      deleting.fire.call(ctx, key, existingValue, dxTrans);\n                    } else if (req.type === 'add' || existingValue === undefined) {\n                      var generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n                      if (key == null && generatedPrimaryKey != null) {\n                        key = generatedPrimaryKey;\n                        req.keys[i] = key;\n                        if (!primaryKey.outbound) {\n                          setByKeyPath(req.values[i], primaryKey.keyPath, key);\n                        }\n                      }\n                    } else {\n                      var objectDiff = getObjectDiff(existingValue, req.values[i]);\n                      var additionalChanges_1 = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n                      if (additionalChanges_1) {\n                        var requestedValue_1 = req.values[i];\n                        Object.keys(additionalChanges_1).forEach(function (keyPath) {\n                          if (hasOwn(requestedValue_1, keyPath)) {\n                            requestedValue_1[keyPath] = additionalChanges_1[keyPath];\n                          } else {\n                            setByKeyPath(requestedValue_1, keyPath, additionalChanges_1[keyPath]);\n                          }\n                        });\n                      }\n                    }\n                    return ctx;\n                  });\n                  return downTable.mutate(req).then(function (_a) {\n                    var failures = _a.failures,\n                      results = _a.results,\n                      numFailures = _a.numFailures,\n                      lastResult = _a.lastResult;\n                    for (var i = 0; i < keys.length; ++i) {\n                      var primKey = results ? results[i] : keys[i];\n                      var ctx = contexts[i];\n                      if (primKey == null) {\n                        ctx.onerror && ctx.onerror(failures[i]);\n                      } else {\n                        ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ? req.values[i] : primKey);\n                      }\n                    }\n                    return {\n                      failures: failures,\n                      results: results,\n                      numFailures: numFailures,\n                      lastResult: lastResult\n                    };\n                  }).catch(function (error) {\n                    contexts.forEach(function (ctx) {\n                      return ctx.onerror && ctx.onerror(error);\n                    });\n                    return Promise.reject(error);\n                  });\n                });\n              }\n              function deleteRange(req) {\n                return deleteNextChunk(req.trans, req.range, 10000);\n              }\n              function deleteNextChunk(trans, range, limit) {\n                return downTable.query({\n                  trans: trans,\n                  values: false,\n                  query: {\n                    index: primaryKey,\n                    range: range\n                  },\n                  limit: limit\n                }).then(function (_a) {\n                  var result = _a.result;\n                  return addPutOrDelete({\n                    type: 'delete',\n                    keys: result,\n                    trans: trans\n                  }).then(function (res) {\n                    if (res.numFailures > 0) return Promise.reject(res.failures[0]);\n                    if (result.length < limit) {\n                      return {\n                        failures: [],\n                        numFailures: 0,\n                        lastResult: undefined\n                      };\n                    } else {\n                      return deleteNextChunk(trans, __assign(__assign({}, range), {\n                        lower: result[result.length - 1],\n                        lowerOpen: true\n                      }), limit);\n                    }\n                  });\n                });\n              }\n            }\n          });\n          return tableMiddleware;\n        }\n      });\n    }\n  };\n  function getExistingValues(table, req, effectiveKeys) {\n    return req.type === \"add\" ? Promise.resolve([]) : table.getMany({\n      trans: req.trans,\n      keys: effectiveKeys,\n      cache: \"immutable\"\n    });\n  }\n  function getFromTransactionCache(keys, cache, clone) {\n    try {\n      if (!cache) return null;\n      if (cache.keys.length < keys.length) return null;\n      var result = [];\n      for (var i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {\n        if (cmp(cache.keys[i], keys[j]) !== 0) continue;\n        result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n        ++j;\n      }\n      return result.length === keys.length ? result : null;\n    } catch (_a) {\n      return null;\n    }\n  }\n  var cacheExistingValuesMiddleware = {\n    stack: \"dbcore\",\n    level: -1,\n    create: function (core) {\n      return {\n        table: function (tableName) {\n          var table = core.table(tableName);\n          return __assign(__assign({}, table), {\n            getMany: function (req) {\n              if (!req.cache) {\n                return table.getMany(req);\n              }\n              var cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n              if (cachedResult) {\n                return DexiePromise.resolve(cachedResult);\n              }\n              return table.getMany(req).then(function (res) {\n                req.trans[\"_cache\"] = {\n                  keys: req.keys,\n                  values: req.cache === \"clone\" ? deepClone(res) : res\n                };\n                return res;\n              });\n            },\n            mutate: function (req) {\n              if (req.type !== \"add\") req.trans[\"_cache\"] = null;\n              return table.mutate(req);\n            }\n          });\n        }\n      };\n    }\n  };\n  var _a;\n  function isEmptyRange(node) {\n    return !(\"from\" in node);\n  }\n  var RangeSet = function (fromOrTree, to) {\n    if (this) {\n      extend(this, arguments.length ? {\n        d: 1,\n        from: fromOrTree,\n        to: arguments.length > 1 ? to : fromOrTree\n      } : {\n        d: 0\n      });\n    } else {\n      var rv = new RangeSet();\n      if (fromOrTree && \"d\" in fromOrTree) {\n        extend(rv, fromOrTree);\n      }\n      return rv;\n    }\n  };\n  props(RangeSet.prototype, (_a = {\n    add: function (rangeSet) {\n      mergeRanges(this, rangeSet);\n      return this;\n    },\n    addKey: function (key) {\n      addRange(this, key, key);\n      return this;\n    },\n    addKeys: function (keys) {\n      var _this = this;\n      keys.forEach(function (key) {\n        return addRange(_this, key, key);\n      });\n      return this;\n    }\n  }, _a[iteratorSymbol] = function () {\n    return getRangeSetIterator(this);\n  }, _a));\n  function addRange(target, from, to) {\n    var diff = cmp(from, to);\n    if (isNaN(diff)) return;\n    if (diff > 0) throw RangeError();\n    if (isEmptyRange(target)) return extend(target, {\n      from: from,\n      to: to,\n      d: 1\n    });\n    var left = target.l;\n    var right = target.r;\n    if (cmp(to, target.from) < 0) {\n      left ? addRange(left, from, to) : target.l = {\n        from: from,\n        to: to,\n        d: 1,\n        l: null,\n        r: null\n      };\n      return rebalance(target);\n    }\n    if (cmp(from, target.to) > 0) {\n      right ? addRange(right, from, to) : target.r = {\n        from: from,\n        to: to,\n        d: 1,\n        l: null,\n        r: null\n      };\n      return rebalance(target);\n    }\n    if (cmp(from, target.from) < 0) {\n      target.from = from;\n      target.l = null;\n      target.d = right ? right.d + 1 : 1;\n    }\n    if (cmp(to, target.to) > 0) {\n      target.to = to;\n      target.r = null;\n      target.d = target.l ? target.l.d + 1 : 1;\n    }\n    var rightWasCutOff = !target.r;\n    if (left && !target.l) {\n      mergeRanges(target, left);\n    }\n    if (right && rightWasCutOff) {\n      mergeRanges(target, right);\n    }\n  }\n  function mergeRanges(target, newSet) {\n    function _addRangeSet(target, _a) {\n      var from = _a.from,\n        to = _a.to,\n        l = _a.l,\n        r = _a.r;\n      addRange(target, from, to);\n      if (l) _addRangeSet(target, l);\n      if (r) _addRangeSet(target, r);\n    }\n    if (!isEmptyRange(newSet)) _addRangeSet(target, newSet);\n  }\n  function rangesOverlap(rangeSet1, rangeSet2) {\n    var i1 = getRangeSetIterator(rangeSet2);\n    var nextResult1 = i1.next();\n    if (nextResult1.done) return false;\n    var a = nextResult1.value;\n    var i2 = getRangeSetIterator(rangeSet1);\n    var nextResult2 = i2.next(a.from);\n    var b = nextResult2.value;\n    while (!nextResult1.done && !nextResult2.done) {\n      if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0) return true;\n      cmp(a.from, b.from) < 0 ? a = (nextResult1 = i1.next(b.from)).value : b = (nextResult2 = i2.next(a.from)).value;\n    }\n    return false;\n  }\n  function getRangeSetIterator(node) {\n    var state = isEmptyRange(node) ? null : {\n      s: 0,\n      n: node\n    };\n    return {\n      next: function (key) {\n        var keyProvided = arguments.length > 0;\n        while (state) {\n          switch (state.s) {\n            case 0:\n              state.s = 1;\n              if (keyProvided) {\n                while (state.n.l && cmp(key, state.n.from) < 0) state = {\n                  up: state,\n                  n: state.n.l,\n                  s: 1\n                };\n              } else {\n                while (state.n.l) state = {\n                  up: state,\n                  n: state.n.l,\n                  s: 1\n                };\n              }\n            case 1:\n              state.s = 2;\n              if (!keyProvided || cmp(key, state.n.to) <= 0) return {\n                value: state.n,\n                done: false\n              };\n            case 2:\n              if (state.n.r) {\n                state.s = 3;\n                state = {\n                  up: state,\n                  n: state.n.r,\n                  s: 0\n                };\n                continue;\n              }\n            case 3:\n              state = state.up;\n          }\n        }\n        return {\n          done: true\n        };\n      }\n    };\n  }\n  function rebalance(target) {\n    var _a, _b;\n    var diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n    var r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n    if (r) {\n      var l = r === \"r\" ? \"l\" : \"r\";\n      var rootClone = __assign({}, target);\n      var oldRootRight = target[r];\n      target.from = oldRootRight.from;\n      target.to = oldRootRight.to;\n      target[r] = oldRootRight[r];\n      rootClone[r] = oldRootRight[l];\n      target[l] = rootClone;\n      rootClone.d = computeDepth(rootClone);\n    }\n    target.d = computeDepth(target);\n  }\n  function computeDepth(_a) {\n    var r = _a.r,\n      l = _a.l;\n    return (r ? l ? Math.max(r.d, l.d) : r.d : l ? l.d : 0) + 1;\n  }\n  var observabilityMiddleware = {\n    stack: \"dbcore\",\n    level: 0,\n    create: function (core) {\n      var dbName = core.schema.name;\n      var FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n      return __assign(__assign({}, core), {\n        table: function (tableName) {\n          var table = core.table(tableName);\n          var schema = table.schema;\n          var primaryKey = schema.primaryKey;\n          var extractKey = primaryKey.extractKey,\n            outbound = primaryKey.outbound;\n          var tableClone = __assign(__assign({}, table), {\n            mutate: function (req) {\n              var trans = req.trans;\n              var mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});\n              var getRangeSet = function (indexName) {\n                var part = \"idb://\" + dbName + \"/\" + tableName + \"/\" + indexName;\n                return mutatedParts[part] || (mutatedParts[part] = new RangeSet());\n              };\n              var pkRangeSet = getRangeSet(\"\");\n              var delsRangeSet = getRangeSet(\":dels\");\n              var type = req.type;\n              var _a = req.type === \"deleteRange\" ? [req.range] : req.type === \"delete\" ? [req.keys] : req.values.length < 50 ? [[], req.values] : [],\n                keys = _a[0],\n                newObjs = _a[1];\n              var oldCache = req.trans[\"_cache\"];\n              return table.mutate(req).then(function (res) {\n                if (isArray(keys)) {\n                  if (type !== \"delete\") keys = res.results;\n                  pkRangeSet.addKeys(keys);\n                  var oldObjs = getFromTransactionCache(keys, oldCache);\n                  if (!oldObjs && type !== \"add\") {\n                    delsRangeSet.addKeys(keys);\n                  }\n                  if (oldObjs || newObjs) {\n                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n                  }\n                } else if (keys) {\n                  var range = {\n                    from: keys.lower,\n                    to: keys.upper\n                  };\n                  delsRangeSet.add(range);\n                  pkRangeSet.add(range);\n                } else {\n                  pkRangeSet.add(FULL_RANGE);\n                  delsRangeSet.add(FULL_RANGE);\n                  schema.indexes.forEach(function (idx) {\n                    return getRangeSet(idx.name).add(FULL_RANGE);\n                  });\n                }\n                return res;\n              });\n            }\n          });\n          var getRange = function (_a) {\n            var _b, _c;\n            var _d = _a.query,\n              index = _d.index,\n              range = _d.range;\n            return [index, new RangeSet((_b = range.lower) !== null && _b !== void 0 ? _b : core.MIN_KEY, (_c = range.upper) !== null && _c !== void 0 ? _c : core.MAX_KEY)];\n          };\n          var readSubscribers = {\n            get: function (req) {\n              return [primaryKey, new RangeSet(req.key)];\n            },\n            getMany: function (req) {\n              return [primaryKey, new RangeSet().addKeys(req.keys)];\n            },\n            count: getRange,\n            query: getRange,\n            openCursor: getRange\n          };\n          keys(readSubscribers).forEach(function (method) {\n            tableClone[method] = function (req) {\n              var subscr = PSD.subscr;\n              if (subscr) {\n                var getRangeSet = function (indexName) {\n                  var part = \"idb://\" + dbName + \"/\" + tableName + \"/\" + indexName;\n                  return subscr[part] || (subscr[part] = new RangeSet());\n                };\n                var pkRangeSet_1 = getRangeSet(\"\");\n                var delsRangeSet_1 = getRangeSet(\":dels\");\n                var _a = readSubscribers[method](req),\n                  queriedIndex = _a[0],\n                  queriedRanges = _a[1];\n                getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n                if (!queriedIndex.isPrimaryKey) {\n                  if (method === \"count\") {\n                    delsRangeSet_1.add(FULL_RANGE);\n                  } else {\n                    var keysPromise_1 = method === \"query\" && outbound && req.values && table.query(__assign(__assign({}, req), {\n                      values: false\n                    }));\n                    return table[method].apply(this, arguments).then(function (res) {\n                      if (method === \"query\") {\n                        if (outbound && req.values) {\n                          return keysPromise_1.then(function (_a) {\n                            var resultingKeys = _a.result;\n                            pkRangeSet_1.addKeys(resultingKeys);\n                            return res;\n                          });\n                        }\n                        var pKeys = req.values ? res.result.map(extractKey) : res.result;\n                        if (req.values) {\n                          pkRangeSet_1.addKeys(pKeys);\n                        } else {\n                          delsRangeSet_1.addKeys(pKeys);\n                        }\n                      } else if (method === \"openCursor\") {\n                        var cursor_1 = res;\n                        var wantValues_1 = req.values;\n                        return cursor_1 && Object.create(cursor_1, {\n                          key: {\n                            get: function () {\n                              delsRangeSet_1.addKey(cursor_1.primaryKey);\n                              return cursor_1.key;\n                            }\n                          },\n                          primaryKey: {\n                            get: function () {\n                              var pkey = cursor_1.primaryKey;\n                              delsRangeSet_1.addKey(pkey);\n                              return pkey;\n                            }\n                          },\n                          value: {\n                            get: function () {\n                              wantValues_1 && pkRangeSet_1.addKey(cursor_1.primaryKey);\n                              return cursor_1.value;\n                            }\n                          }\n                        });\n                      }\n                      return res;\n                    });\n                  }\n                }\n              }\n              return table[method].apply(this, arguments);\n            };\n          });\n          return tableClone;\n        }\n      });\n    }\n  };\n  function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n    function addAffectedIndex(ix) {\n      var rangeSet = getRangeSet(ix.name || \"\");\n      function extractKey(obj) {\n        return obj != null ? ix.extractKey(obj) : null;\n      }\n      var addKeyOrKeys = function (key) {\n        return ix.multiEntry && isArray(key) ? key.forEach(function (key) {\n          return rangeSet.addKey(key);\n        }) : rangeSet.addKey(key);\n      };\n      (oldObjs || newObjs).forEach(function (_, i) {\n        var oldKey = oldObjs && extractKey(oldObjs[i]);\n        var newKey = newObjs && extractKey(newObjs[i]);\n        if (cmp(oldKey, newKey) !== 0) {\n          if (oldKey != null) addKeyOrKeys(oldKey);\n          if (newKey != null) addKeyOrKeys(newKey);\n        }\n      });\n    }\n    schema.indexes.forEach(addAffectedIndex);\n  }\n  var Dexie$1 = function () {\n    function Dexie(name, options) {\n      var _this = this;\n      this._middlewares = {};\n      this.verno = 0;\n      var deps = Dexie.dependencies;\n      this._options = options = __assign({\n        addons: Dexie.addons,\n        autoOpen: true,\n        indexedDB: deps.indexedDB,\n        IDBKeyRange: deps.IDBKeyRange\n      }, options);\n      this._deps = {\n        indexedDB: options.indexedDB,\n        IDBKeyRange: options.IDBKeyRange\n      };\n      var addons = options.addons;\n      this._dbSchema = {};\n      this._versions = [];\n      this._storeNames = [];\n      this._allTables = {};\n      this.idbdb = null;\n      this._novip = this;\n      var state = {\n        dbOpenError: null,\n        isBeingOpened: false,\n        onReadyBeingFired: null,\n        openComplete: false,\n        dbReadyResolve: nop,\n        dbReadyPromise: null,\n        cancelOpen: nop,\n        openCanceller: null,\n        autoSchema: true,\n        PR1398_maxLoop: 3\n      };\n      state.dbReadyPromise = new DexiePromise(function (resolve) {\n        state.dbReadyResolve = resolve;\n      });\n      state.openCanceller = new DexiePromise(function (_, reject) {\n        state.cancelOpen = reject;\n      });\n      this._state = state;\n      this.name = name;\n      this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", {\n        ready: [promisableChain, nop]\n      });\n      this.on.ready.subscribe = override(this.on.ready.subscribe, function (subscribe) {\n        return function (subscriber, bSticky) {\n          Dexie.vip(function () {\n            var state = _this._state;\n            if (state.openComplete) {\n              if (!state.dbOpenError) DexiePromise.resolve().then(subscriber);\n              if (bSticky) subscribe(subscriber);\n            } else if (state.onReadyBeingFired) {\n              state.onReadyBeingFired.push(subscriber);\n              if (bSticky) subscribe(subscriber);\n            } else {\n              subscribe(subscriber);\n              var db_1 = _this;\n              if (!bSticky) subscribe(function unsubscribe() {\n                db_1.on.ready.unsubscribe(subscriber);\n                db_1.on.ready.unsubscribe(unsubscribe);\n              });\n            }\n          });\n        };\n      });\n      this.Collection = createCollectionConstructor(this);\n      this.Table = createTableConstructor(this);\n      this.Transaction = createTransactionConstructor(this);\n      this.Version = createVersionConstructor(this);\n      this.WhereClause = createWhereClauseConstructor(this);\n      this.on(\"versionchange\", function (ev) {\n        if (ev.newVersion > 0) console.warn(\"Another connection wants to upgrade database '\" + _this.name + \"'. Closing db now to resume the upgrade.\");else console.warn(\"Another connection wants to delete database '\" + _this.name + \"'. Closing db now to resume the delete request.\");\n        _this.close();\n      });\n      this.on(\"blocked\", function (ev) {\n        if (!ev.newVersion || ev.newVersion < ev.oldVersion) console.warn(\"Dexie.delete('\" + _this.name + \"') was blocked\");else console.warn(\"Upgrade '\" + _this.name + \"' blocked by other connection holding version \" + ev.oldVersion / 10);\n      });\n      this._maxKey = getMaxKey(options.IDBKeyRange);\n      this._createTransaction = function (mode, storeNames, dbschema, parentTransaction) {\n        return new _this.Transaction(mode, storeNames, dbschema, _this._options.chromeTransactionDurability, parentTransaction);\n      };\n      this._fireOnBlocked = function (ev) {\n        _this.on(\"blocked\").fire(ev);\n        connections.filter(function (c) {\n          return c.name === _this.name && c !== _this && !c._state.vcFired;\n        }).map(function (c) {\n          return c.on(\"versionchange\").fire(ev);\n        });\n      };\n      this.use(virtualIndexMiddleware);\n      this.use(hooksMiddleware);\n      this.use(observabilityMiddleware);\n      this.use(cacheExistingValuesMiddleware);\n      this.vip = Object.create(this, {\n        _vip: {\n          value: true\n        }\n      });\n      addons.forEach(function (addon) {\n        return addon(_this);\n      });\n    }\n    Dexie.prototype.version = function (versionNumber) {\n      if (isNaN(versionNumber) || versionNumber < 0.1) throw new exceptions.Type(\"Given version is not a positive number\");\n      versionNumber = Math.round(versionNumber * 10) / 10;\n      if (this.idbdb || this._state.isBeingOpened) throw new exceptions.Schema(\"Cannot add version when database is open\");\n      this.verno = Math.max(this.verno, versionNumber);\n      var versions = this._versions;\n      var versionInstance = versions.filter(function (v) {\n        return v._cfg.version === versionNumber;\n      })[0];\n      if (versionInstance) return versionInstance;\n      versionInstance = new this.Version(versionNumber);\n      versions.push(versionInstance);\n      versions.sort(lowerVersionFirst);\n      versionInstance.stores({});\n      this._state.autoSchema = false;\n      return versionInstance;\n    };\n    Dexie.prototype._whenReady = function (fn) {\n      var _this = this;\n      return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn() : new DexiePromise(function (resolve, reject) {\n        if (_this._state.openComplete) {\n          return reject(new exceptions.DatabaseClosed(_this._state.dbOpenError));\n        }\n        if (!_this._state.isBeingOpened) {\n          if (!_this._options.autoOpen) {\n            reject(new exceptions.DatabaseClosed());\n            return;\n          }\n          _this.open().catch(nop);\n        }\n        _this._state.dbReadyPromise.then(resolve, reject);\n      }).then(fn);\n    };\n    Dexie.prototype.use = function (_a) {\n      var stack = _a.stack,\n        create = _a.create,\n        level = _a.level,\n        name = _a.name;\n      if (name) this.unuse({\n        stack: stack,\n        name: name\n      });\n      var middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n      middlewares.push({\n        stack: stack,\n        create: create,\n        level: level == null ? 10 : level,\n        name: name\n      });\n      middlewares.sort(function (a, b) {\n        return a.level - b.level;\n      });\n      return this;\n    };\n    Dexie.prototype.unuse = function (_a) {\n      var stack = _a.stack,\n        name = _a.name,\n        create = _a.create;\n      if (stack && this._middlewares[stack]) {\n        this._middlewares[stack] = this._middlewares[stack].filter(function (mw) {\n          return create ? mw.create !== create : name ? mw.name !== name : false;\n        });\n      }\n      return this;\n    };\n    Dexie.prototype.open = function () {\n      return dexieOpen(this);\n    };\n    Dexie.prototype._close = function () {\n      var state = this._state;\n      var idx = connections.indexOf(this);\n      if (idx >= 0) connections.splice(idx, 1);\n      if (this.idbdb) {\n        try {\n          this.idbdb.close();\n        } catch (e) {}\n        this._novip.idbdb = null;\n      }\n      state.dbReadyPromise = new DexiePromise(function (resolve) {\n        state.dbReadyResolve = resolve;\n      });\n      state.openCanceller = new DexiePromise(function (_, reject) {\n        state.cancelOpen = reject;\n      });\n    };\n    Dexie.prototype.close = function () {\n      this._close();\n      var state = this._state;\n      this._options.autoOpen = false;\n      state.dbOpenError = new exceptions.DatabaseClosed();\n      if (state.isBeingOpened) state.cancelOpen(state.dbOpenError);\n    };\n    Dexie.prototype.delete = function () {\n      var _this = this;\n      var hasArguments = arguments.length > 0;\n      var state = this._state;\n      return new DexiePromise(function (resolve, reject) {\n        var doDelete = function () {\n          _this.close();\n          var req = _this._deps.indexedDB.deleteDatabase(_this.name);\n          req.onsuccess = wrap(function () {\n            _onDatabaseDeleted(_this._deps, _this.name);\n            resolve();\n          });\n          req.onerror = eventRejectHandler(reject);\n          req.onblocked = _this._fireOnBlocked;\n        };\n        if (hasArguments) throw new exceptions.InvalidArgument(\"Arguments not allowed in db.delete()\");\n        if (state.isBeingOpened) {\n          state.dbReadyPromise.then(doDelete);\n        } else {\n          doDelete();\n        }\n      });\n    };\n    Dexie.prototype.backendDB = function () {\n      return this.idbdb;\n    };\n    Dexie.prototype.isOpen = function () {\n      return this.idbdb !== null;\n    };\n    Dexie.prototype.hasBeenClosed = function () {\n      var dbOpenError = this._state.dbOpenError;\n      return dbOpenError && dbOpenError.name === 'DatabaseClosed';\n    };\n    Dexie.prototype.hasFailed = function () {\n      return this._state.dbOpenError !== null;\n    };\n    Dexie.prototype.dynamicallyOpened = function () {\n      return this._state.autoSchema;\n    };\n    Object.defineProperty(Dexie.prototype, \"tables\", {\n      get: function () {\n        var _this = this;\n        return keys(this._allTables).map(function (name) {\n          return _this._allTables[name];\n        });\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Dexie.prototype.transaction = function () {\n      var args = extractTransactionArgs.apply(this, arguments);\n      return this._transaction.apply(this, args);\n    };\n    Dexie.prototype._transaction = function (mode, tables, scopeFunc) {\n      var _this = this;\n      var parentTransaction = PSD.trans;\n      if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1) parentTransaction = null;\n      var onlyIfCompatible = mode.indexOf('?') !== -1;\n      mode = mode.replace('!', '').replace('?', '');\n      var idbMode, storeNames;\n      try {\n        storeNames = tables.map(function (table) {\n          var storeName = table instanceof _this.Table ? table.name : table;\n          if (typeof storeName !== 'string') throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n          return storeName;\n        });\n        if (mode == \"r\" || mode === READONLY) idbMode = READONLY;else if (mode == \"rw\" || mode == READWRITE) idbMode = READWRITE;else throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n        if (parentTransaction) {\n          if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n            if (onlyIfCompatible) {\n              parentTransaction = null;\n            } else throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n          }\n          if (parentTransaction) {\n            storeNames.forEach(function (storeName) {\n              if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n                if (onlyIfCompatible) {\n                  parentTransaction = null;\n                } else throw new exceptions.SubTransaction(\"Table \" + storeName + \" not included in parent transaction.\");\n              }\n            });\n          }\n          if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n            parentTransaction = null;\n          }\n        }\n      } catch (e) {\n        return parentTransaction ? parentTransaction._promise(null, function (_, reject) {\n          reject(e);\n        }) : rejection(e);\n      }\n      var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n      return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, \"lock\") : PSD.trans ? usePSD(PSD.transless, function () {\n        return _this._whenReady(enterTransaction);\n      }) : this._whenReady(enterTransaction);\n    };\n    Dexie.prototype.table = function (tableName) {\n      if (!hasOwn(this._allTables, tableName)) {\n        throw new exceptions.InvalidTable(\"Table \" + tableName + \" does not exist\");\n      }\n      return this._allTables[tableName];\n    };\n    return Dexie;\n  }();\n  var symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol ? Symbol.observable : \"@@observable\";\n  var Observable = function () {\n    function Observable(subscribe) {\n      this._subscribe = subscribe;\n    }\n    Observable.prototype.subscribe = function (x, error, complete) {\n      return this._subscribe(!x || typeof x === \"function\" ? {\n        next: x,\n        error: error,\n        complete: complete\n      } : x);\n    };\n    Observable.prototype[symbolObservable] = function () {\n      return this;\n    };\n    return Observable;\n  }();\n  function extendObservabilitySet(target, newSet) {\n    keys(newSet).forEach(function (part) {\n      var rangeSet = target[part] || (target[part] = new RangeSet());\n      mergeRanges(rangeSet, newSet[part]);\n    });\n    return target;\n  }\n  function liveQuery(querier) {\n    var hasValue = false;\n    var currentValue = undefined;\n    var observable = new Observable(function (observer) {\n      var scopeFuncIsAsync = isAsyncFunction(querier);\n      function execute(subscr) {\n        if (scopeFuncIsAsync) {\n          incrementExpectedAwaits();\n        }\n        var exec = function () {\n          return newScope(querier, {\n            subscr: subscr,\n            trans: null\n          });\n        };\n        var rv = PSD.trans ? usePSD(PSD.transless, exec) : exec();\n        if (scopeFuncIsAsync) {\n          rv.then(decrementExpectedAwaits, decrementExpectedAwaits);\n        }\n        return rv;\n      }\n      var closed = false;\n      var accumMuts = {};\n      var currentObs = {};\n      var subscription = {\n        get closed() {\n          return closed;\n        },\n        unsubscribe: function () {\n          closed = true;\n          globalEvents.storagemutated.unsubscribe(mutationListener);\n        }\n      };\n      observer.start && observer.start(subscription);\n      var querying = false,\n        startedListening = false;\n      function shouldNotify() {\n        return keys(currentObs).some(function (key) {\n          return accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]);\n        });\n      }\n      var mutationListener = function (parts) {\n        extendObservabilitySet(accumMuts, parts);\n        if (shouldNotify()) {\n          doQuery();\n        }\n      };\n      var doQuery = function () {\n        if (querying || closed) return;\n        accumMuts = {};\n        var subscr = {};\n        var ret = execute(subscr);\n        if (!startedListening) {\n          globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n          startedListening = true;\n        }\n        querying = true;\n        Promise.resolve(ret).then(function (result) {\n          hasValue = true;\n          currentValue = result;\n          querying = false;\n          if (closed) return;\n          if (shouldNotify()) {\n            doQuery();\n          } else {\n            accumMuts = {};\n            currentObs = subscr;\n            observer.next && observer.next(result);\n          }\n        }, function (err) {\n          querying = false;\n          hasValue = false;\n          observer.error && observer.error(err);\n          subscription.unsubscribe();\n        });\n      };\n      doQuery();\n      return subscription;\n    });\n    observable.hasValue = function () {\n      return hasValue;\n    };\n    observable.getValue = function () {\n      return currentValue;\n    };\n    return observable;\n  }\n  var domDeps;\n  try {\n    domDeps = {\n      indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n      IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n    };\n  } catch (e) {\n    domDeps = {\n      indexedDB: null,\n      IDBKeyRange: null\n    };\n  }\n  var Dexie = Dexie$1;\n  props(Dexie, __assign(__assign({}, fullNameExceptions), {\n    delete: function (databaseName) {\n      var db = new Dexie(databaseName, {\n        addons: []\n      });\n      return db.delete();\n    },\n    exists: function (name) {\n      return new Dexie(name, {\n        addons: []\n      }).open().then(function (db) {\n        db.close();\n        return true;\n      }).catch('NoSuchDatabaseError', function () {\n        return false;\n      });\n    },\n    getDatabaseNames: function (cb) {\n      try {\n        return getDatabaseNames(Dexie.dependencies).then(cb);\n      } catch (_a) {\n        return rejection(new exceptions.MissingAPI());\n      }\n    },\n    defineClass: function () {\n      function Class(content) {\n        extend(this, content);\n      }\n      return Class;\n    },\n    ignoreTransaction: function (scopeFunc) {\n      return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();\n    },\n    vip: vip,\n    async: function (generatorFn) {\n      return function () {\n        try {\n          var rv = awaitIterator(generatorFn.apply(this, arguments));\n          if (!rv || typeof rv.then !== 'function') return DexiePromise.resolve(rv);\n          return rv;\n        } catch (e) {\n          return rejection(e);\n        }\n      };\n    },\n    spawn: function (generatorFn, args, thiz) {\n      try {\n        var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n        if (!rv || typeof rv.then !== 'function') return DexiePromise.resolve(rv);\n        return rv;\n      } catch (e) {\n        return rejection(e);\n      }\n    },\n    currentTransaction: {\n      get: function () {\n        return PSD.trans || null;\n      }\n    },\n    waitFor: function (promiseOrFunction, optionalTimeout) {\n      var promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ? Dexie.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 60000);\n      return PSD.trans ? PSD.trans.waitFor(promise) : promise;\n    },\n    Promise: DexiePromise,\n    debug: {\n      get: function () {\n        return debug;\n      },\n      set: function (value) {\n        setDebug(value, value === 'dexie' ? function () {\n          return true;\n        } : dexieStackFrameFilter);\n      }\n    },\n    derive: derive,\n    extend: extend,\n    props: props,\n    override: override,\n    Events: Events,\n    on: globalEvents,\n    liveQuery: liveQuery,\n    extendObservabilitySet: extendObservabilitySet,\n    getByKeyPath: getByKeyPath,\n    setByKeyPath: setByKeyPath,\n    delByKeyPath: delByKeyPath,\n    shallowClone: shallowClone,\n    deepClone: deepClone,\n    getObjectDiff: getObjectDiff,\n    cmp: cmp,\n    asap: asap$1,\n    minKey: minKey,\n    addons: [],\n    connections: connections,\n    errnames: errnames,\n    dependencies: domDeps,\n    semVer: DEXIE_VERSION,\n    version: DEXIE_VERSION.split('.').map(function (n) {\n      return parseInt(n);\n    }).reduce(function (p, c, i) {\n      return p + c / Math.pow(10, i * 2);\n    })\n  }));\n  Dexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\n  if (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (updatedParts) {\n      if (!propagatingLocally) {\n        var event_1;\n        if (isIEOrEdge) {\n          event_1 = document.createEvent('CustomEvent');\n          event_1.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);\n        } else {\n          event_1 = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n            detail: updatedParts\n          });\n        }\n        propagatingLocally = true;\n        dispatchEvent(event_1);\n        propagatingLocally = false;\n      }\n    });\n    addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, function (_a) {\n      var detail = _a.detail;\n      if (!propagatingLocally) {\n        propagateLocally(detail);\n      }\n    });\n  }\n  function propagateLocally(updateParts) {\n    var wasMe = propagatingLocally;\n    try {\n      propagatingLocally = true;\n      globalEvents.storagemutated.fire(updateParts);\n    } finally {\n      propagatingLocally = wasMe;\n    }\n  }\n  var propagatingLocally = false;\n  if (typeof BroadcastChannel !== 'undefined') {\n    var bc_1 = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n    if (typeof bc_1.unref === 'function') {\n      bc_1.unref();\n    }\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (changedParts) {\n      if (!propagatingLocally) {\n        bc_1.postMessage(changedParts);\n      }\n    });\n    bc_1.onmessage = function (ev) {\n      if (ev.data) propagateLocally(ev.data);\n    };\n  } else if (typeof self !== 'undefined' && typeof navigator !== 'undefined') {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (changedParts) {\n      try {\n        if (!propagatingLocally) {\n          if (typeof localStorage !== 'undefined') {\n            localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({\n              trig: Math.random(),\n              changedParts: changedParts\n            }));\n          }\n          if (typeof self['clients'] === 'object') {\n            __spreadArray([], self['clients'].matchAll({\n              includeUncontrolled: true\n            }), true).forEach(function (client) {\n              return client.postMessage({\n                type: STORAGE_MUTATED_DOM_EVENT_NAME,\n                changedParts: changedParts\n              });\n            });\n          }\n        }\n      } catch (_a) {}\n    });\n    if (typeof addEventListener !== 'undefined') {\n      addEventListener('storage', function (ev) {\n        if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {\n          var data = JSON.parse(ev.newValue);\n          if (data) propagateLocally(data.changedParts);\n        }\n      });\n    }\n    var swContainer = self.document && navigator.serviceWorker;\n    if (swContainer) {\n      swContainer.addEventListener('message', propagateMessageLocally);\n    }\n  }\n  function propagateMessageLocally(_a) {\n    var data = _a.data;\n    if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {\n      propagateLocally(data.changedParts);\n    }\n  }\n  DexiePromise.rejectionMapper = mapError;\n  setDebug(debug, dexieStackFrameFilter);\n  var namedExports = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Dexie: Dexie$1,\n    liveQuery: liveQuery,\n    'default': Dexie$1,\n    RangeSet: RangeSet,\n    mergeRanges: mergeRanges,\n    rangesOverlap: rangesOverlap\n  });\n  __assign(Dexie$1, namedExports, {\n    default: Dexie$1\n  });\n  return Dexie$1;\n});\n\n//# sourceURL=webpack://mytonwallet-lib/./src/lib/dexie/dexie.js?");

/***/ }),

/***/ "./src/lib/is-retry-allowed/index.js":
/*!*******************************************!*\
  !*** ./src/lib/is-retry-allowed/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ isRetryAllowed)\n/* harmony export */ });\nconst denyList = new Set(['ENOTFOUND', 'ENETUNREACH',\n// SSL errors from https://github.com/nodejs/node/blob/fc8e3e2cdc521978351de257030db0076d79e0ab/src/crypto/crypto_common.cc#L301-L328\n'UNABLE_TO_GET_ISSUER_CERT', 'UNABLE_TO_GET_CRL', 'UNABLE_TO_DECRYPT_CERT_SIGNATURE', 'UNABLE_TO_DECRYPT_CRL_SIGNATURE', 'UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY', 'CERT_SIGNATURE_FAILURE', 'CRL_SIGNATURE_FAILURE', 'CERT_NOT_YET_VALID', 'CERT_HAS_EXPIRED', 'CRL_NOT_YET_VALID', 'CRL_HAS_EXPIRED', 'ERROR_IN_CERT_NOT_BEFORE_FIELD', 'ERROR_IN_CERT_NOT_AFTER_FIELD', 'ERROR_IN_CRL_LAST_UPDATE_FIELD', 'ERROR_IN_CRL_NEXT_UPDATE_FIELD', 'OUT_OF_MEM', 'DEPTH_ZERO_SELF_SIGNED_CERT', 'SELF_SIGNED_CERT_IN_CHAIN', 'UNABLE_TO_GET_ISSUER_CERT_LOCALLY', 'UNABLE_TO_VERIFY_LEAF_SIGNATURE', 'CERT_CHAIN_TOO_LONG', 'CERT_REVOKED', 'INVALID_CA', 'PATH_LENGTH_EXCEEDED', 'INVALID_PURPOSE', 'CERT_UNTRUSTED', 'CERT_REJECTED', 'HOSTNAME_MISMATCH']);\n\n// TODO: Use `error?.code` when targeting Node.js 14\nfunction isRetryAllowed(error) {\n  return !denyList.has(error && error.code);\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/lib/is-retry-allowed/index.js?");

/***/ }),

/***/ "./src/lib/noble-ed25519/index.js":
/*!****************************************!*\
  !*** ./src/lib/noble-ed25519/index.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("// Version 1.7.3\n(function (global, factory) {\n   true ? factory(exports) : 0;\n})(this, function (exports) {\n  'use strict';\n\n  const _nodeResolve_empty = {};\n  const nodeCrypto = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    'default': _nodeResolve_empty\n  });\n\n  /*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\n  const _0n = BigInt(0);\n  const _1n = BigInt(1);\n  const _2n = BigInt(2);\n  const _8n = BigInt(8);\n  const CU_O = BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989');\n  const CURVE = Object.freeze({\n    a: BigInt(-1),\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    P: BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949'),\n    l: CU_O,\n    n: CU_O,\n    h: BigInt(8),\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960')\n  });\n  const POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\n  const SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\n  BigInt('6853475219497561581579357271197624642482790079785650197046958215289687604742');\n  const SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\n  const INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\n  const ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\n  const D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\n  class ExtendedPoint {\n    constructor(x, y, z, t) {\n      this.x = x;\n      this.y = y;\n      this.z = z;\n      this.t = t;\n    }\n    static fromAffine(p) {\n      if (!(p instanceof Point)) {\n        throw new TypeError('ExtendedPoint#fromAffine: expected Point');\n      }\n      if (p.equals(Point.ZERO)) return ExtendedPoint.ZERO;\n      return new ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));\n    }\n    static toAffineBatch(points) {\n      const toInv = invertBatch(points.map(p => p.z));\n      return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n      return this.toAffineBatch(points).map(this.fromAffine);\n    }\n    equals(other) {\n      assertExtPoint(other);\n      const {\n        x: X1,\n        y: Y1,\n        z: Z1\n      } = this;\n      const {\n        x: X2,\n        y: Y2,\n        z: Z2\n      } = other;\n      const X1Z2 = mod(X1 * Z2);\n      const X2Z1 = mod(X2 * Z1);\n      const Y1Z2 = mod(Y1 * Z2);\n      const Y2Z1 = mod(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    negate() {\n      return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));\n    }\n    double() {\n      const {\n        x: X1,\n        y: Y1,\n        z: Z1\n      } = this;\n      const {\n        a\n      } = CURVE;\n      const A = mod(X1 * X1);\n      const B = mod(Y1 * Y1);\n      const C = mod(_2n * mod(Z1 * Z1));\n      const D = mod(a * A);\n      const x1y1 = X1 + Y1;\n      const E = mod(mod(x1y1 * x1y1) - A - B);\n      const G = D + B;\n      const F = G - C;\n      const H = D - B;\n      const X3 = mod(E * F);\n      const Y3 = mod(G * H);\n      const T3 = mod(E * H);\n      const Z3 = mod(F * G);\n      return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    add(other) {\n      assertExtPoint(other);\n      const {\n        x: X1,\n        y: Y1,\n        z: Z1,\n        t: T1\n      } = this;\n      const {\n        x: X2,\n        y: Y2,\n        z: Z2,\n        t: T2\n      } = other;\n      const A = mod((Y1 - X1) * (Y2 + X2));\n      const B = mod((Y1 + X1) * (Y2 - X2));\n      const F = mod(B - A);\n      if (F === _0n) return this.double();\n      const C = mod(Z1 * _2n * T2);\n      const D = mod(T1 * _2n * Z2);\n      const E = D + C;\n      const G = B + A;\n      const H = D - C;\n      const X3 = mod(E * F);\n      const Y3 = mod(G * H);\n      const T3 = mod(E * H);\n      const Z3 = mod(F * G);\n      return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    subtract(other) {\n      return this.add(other.negate());\n    }\n    precomputeWindow(W) {\n      const windows = 1 + 256 / W;\n      const points = [];\n      let p = this;\n      let base = p;\n      for (let window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n        for (let i = 1; i < 2 ** (W - 1); i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n        p = base.double();\n      }\n      return points;\n    }\n    wNAF(n, affinePoint) {\n      if (!affinePoint && this.equals(ExtendedPoint.BASE)) affinePoint = Point.BASE;\n      const W = affinePoint && affinePoint._WINDOW_SIZE || 1;\n      if (256 % W) {\n        throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n      }\n      let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n      if (!precomputes) {\n        precomputes = this.precomputeWindow(W);\n        if (affinePoint && W !== 1) {\n          precomputes = ExtendedPoint.normalizeZ(precomputes);\n          pointPrecomputes.set(affinePoint, precomputes);\n        }\n      }\n      let p = ExtendedPoint.ZERO;\n      let f = ExtendedPoint.BASE;\n      const windows = 1 + 256 / W;\n      const windowSize = 2 ** (W - 1);\n      const mask = BigInt(2 ** W - 1);\n      const maxNumber = 2 ** W;\n      const shiftBy = BigInt(W);\n      for (let window = 0; window < windows; window++) {\n        const offset = window * windowSize;\n        let wbits = Number(n & mask);\n        n >>= shiftBy;\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n        const offset1 = offset;\n        const offset2 = offset + Math.abs(wbits) - 1;\n        const cond1 = window % 2 !== 0;\n        const cond2 = wbits < 0;\n        if (wbits === 0) {\n          f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n        } else {\n          p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n        }\n      }\n      return ExtendedPoint.normalizeZ([p, f])[0];\n    }\n    multiply(scalar, affinePoint) {\n      return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);\n    }\n    multiplyUnsafe(scalar) {\n      let n = normalizeScalar(scalar, CURVE.l, false);\n      const G = ExtendedPoint.BASE;\n      const P0 = ExtendedPoint.ZERO;\n      if (n === _0n) return P0;\n      if (this.equals(P0) || n === _1n) return this;\n      if (this.equals(G)) return this.wNAF(n);\n      let p = P0;\n      let d = this;\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n      return p;\n    }\n    isSmallOrder() {\n      return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n    }\n    isTorsionFree() {\n      let p = this.multiplyUnsafe(CURVE.l / _2n).double();\n      if (CURVE.l % _2n) p = p.add(this);\n      return p.equals(ExtendedPoint.ZERO);\n    }\n    toAffine(invZ) {\n      const {\n        x,\n        y,\n        z\n      } = this;\n      const is0 = this.equals(ExtendedPoint.ZERO);\n      if (invZ == null) invZ = is0 ? _8n : invert(z);\n      const ax = mod(x * invZ);\n      const ay = mod(y * invZ);\n      const zz = mod(z * invZ);\n      if (is0) return Point.ZERO;\n      if (zz !== _1n) throw new Error('invZ was invalid');\n      return new Point(ax, ay);\n    }\n    fromRistrettoBytes() {\n      legacyRist();\n    }\n    toRistrettoBytes() {\n      legacyRist();\n    }\n    fromRistrettoHash() {\n      legacyRist();\n    }\n  }\n  ExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));\n  ExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);\n  function constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n  }\n  function assertExtPoint(other) {\n    if (!(other instanceof ExtendedPoint)) throw new TypeError('ExtendedPoint expected');\n  }\n  function assertRstPoint(other) {\n    if (!(other instanceof RistrettoPoint)) throw new TypeError('RistrettoPoint expected');\n  }\n  function legacyRist() {\n    throw new Error('Legacy method: switch to RistrettoPoint');\n  }\n  class RistrettoPoint {\n    constructor(ep) {\n      this.ep = ep;\n    }\n    static calcElligatorRistrettoMap(r0) {\n      const {\n        d\n      } = CURVE;\n      const r = mod(SQRT_M1 * r0 * r0);\n      const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);\n      let c = BigInt(-1);\n      const D = mod((c - d * r) * mod(r + d));\n      let {\n        isValid: Ns_D_is_sq,\n        value: s\n      } = uvRatio(Ns, D);\n      let s_ = mod(s * r0);\n      if (!edIsNegative(s_)) s_ = mod(-s_);\n      if (!Ns_D_is_sq) s = s_;\n      if (!Ns_D_is_sq) c = r;\n      const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);\n      const s2 = s * s;\n      const W0 = mod((s + s) * D);\n      const W1 = mod(Nt * SQRT_AD_MINUS_ONE);\n      const W2 = mod(_1n - s2);\n      const W3 = mod(_1n + s2);\n      return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n    }\n    static hashToCurve(hex) {\n      hex = ensureBytes(hex, 64);\n      const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n      const R1 = this.calcElligatorRistrettoMap(r1);\n      const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n      const R2 = this.calcElligatorRistrettoMap(r2);\n      return new RistrettoPoint(R1.add(R2));\n    }\n    static fromHex(hex) {\n      hex = ensureBytes(hex, 32);\n      const {\n        a,\n        d\n      } = CURVE;\n      const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n      const s = bytes255ToNumberLE(hex);\n      if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s)) throw new Error(emsg);\n      const s2 = mod(s * s);\n      const u1 = mod(_1n + a * s2);\n      const u2 = mod(_1n - a * s2);\n      const u1_2 = mod(u1 * u1);\n      const u2_2 = mod(u2 * u2);\n      const v = mod(a * d * u1_2 - u2_2);\n      const {\n        isValid,\n        value: I\n      } = invertSqrt(mod(v * u2_2));\n      const Dx = mod(I * u2);\n      const Dy = mod(I * Dx * v);\n      let x = mod((s + s) * Dx);\n      if (edIsNegative(x)) x = mod(-x);\n      const y = mod(u1 * Dy);\n      const t = mod(x * y);\n      if (!isValid || edIsNegative(t) || y === _0n) throw new Error(emsg);\n      return new RistrettoPoint(new ExtendedPoint(x, y, _1n, t));\n    }\n    toRawBytes() {\n      let {\n        x,\n        y,\n        z,\n        t\n      } = this.ep;\n      const u1 = mod(mod(z + y) * mod(z - y));\n      const u2 = mod(x * y);\n      const u2sq = mod(u2 * u2);\n      const {\n        value: invsqrt\n      } = invertSqrt(mod(u1 * u2sq));\n      const D1 = mod(invsqrt * u1);\n      const D2 = mod(invsqrt * u2);\n      const zInv = mod(D1 * D2 * t);\n      let D;\n      if (edIsNegative(t * zInv)) {\n        let _x = mod(y * SQRT_M1);\n        let _y = mod(x * SQRT_M1);\n        x = _x;\n        y = _y;\n        D = mod(D1 * INVSQRT_A_MINUS_D);\n      } else {\n        D = D2;\n      }\n      if (edIsNegative(x * zInv)) y = mod(-y);\n      let s = mod((z - y) * D);\n      if (edIsNegative(s)) s = mod(-s);\n      return numberTo32BytesLE(s);\n    }\n    toHex() {\n      return bytesToHex(this.toRawBytes());\n    }\n    toString() {\n      return this.toHex();\n    }\n    equals(other) {\n      assertRstPoint(other);\n      const a = this.ep;\n      const b = other.ep;\n      const one = mod(a.x * b.y) === mod(a.y * b.x);\n      const two = mod(a.y * b.y) === mod(a.x * b.x);\n      return one || two;\n    }\n    add(other) {\n      assertRstPoint(other);\n      return new RistrettoPoint(this.ep.add(other.ep));\n    }\n    subtract(other) {\n      assertRstPoint(other);\n      return new RistrettoPoint(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n      return new RistrettoPoint(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n      return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));\n    }\n  }\n  RistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);\n  RistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);\n  const pointPrecomputes = new WeakMap();\n  class Point {\n    constructor(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n    _setWindowSize(windowSize) {\n      this._WINDOW_SIZE = windowSize;\n      pointPrecomputes.delete(this);\n    }\n    static fromHex(hex) {\n      let strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      const {\n        d,\n        P\n      } = CURVE;\n      hex = ensureBytes(hex, 32);\n      const normed = hex.slice();\n      normed[31] = hex[31] & ~0x80;\n      const y = bytesToNumberLE(normed);\n      if (strict && y >= P) throw new Error('Expected 0 < hex < P');\n      if (!strict && y >= POW_2_256) throw new Error('Expected 0 < hex < 2**256');\n      const y2 = mod(y * y);\n      const u = mod(y2 - _1n);\n      const v = mod(d * y2 + _1n);\n      let {\n        isValid,\n        value: x\n      } = uvRatio(u, v);\n      if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');\n      const isXOdd = (x & _1n) === _1n;\n      const isLastByteOdd = (hex[31] & 0x80) !== 0;\n      if (isLastByteOdd !== isXOdd) {\n        x = mod(-x);\n      }\n      return new Point(x, y);\n    }\n    static async fromPrivateKey(privateKey) {\n      return (await getExtendedPublicKey(privateKey)).point;\n    }\n    toRawBytes() {\n      const bytes = numberTo32BytesLE(this.y);\n      bytes[31] |= this.x & _1n ? 0x80 : 0;\n      return bytes;\n    }\n    toHex() {\n      return bytesToHex(this.toRawBytes());\n    }\n    toX25519() {\n      const {\n        y\n      } = this;\n      const u = mod((_1n + y) * invert(_1n - y));\n      return numberTo32BytesLE(u);\n    }\n    isTorsionFree() {\n      return ExtendedPoint.fromAffine(this).isTorsionFree();\n    }\n    equals(other) {\n      return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n      return new Point(mod(-this.x), this.y);\n    }\n    add(other) {\n      return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n      return this.add(other.negate());\n    }\n    multiply(scalar) {\n      return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n  }\n  Point.BASE = new Point(CURVE.Gx, CURVE.Gy);\n  Point.ZERO = new Point(_0n, _1n);\n  class Signature {\n    constructor(r, s) {\n      this.r = r;\n      this.s = s;\n      this.assertValidity();\n    }\n    static fromHex(hex) {\n      const bytes = ensureBytes(hex, 64);\n      const r = Point.fromHex(bytes.slice(0, 32), false);\n      const s = bytesToNumberLE(bytes.slice(32, 64));\n      return new Signature(r, s);\n    }\n    assertValidity() {\n      const {\n        r,\n        s\n      } = this;\n      if (!(r instanceof Point)) throw new Error('Expected Point instance');\n      normalizeScalar(s, CURVE.l, false);\n      return this;\n    }\n    toRawBytes() {\n      const u8 = new Uint8Array(64);\n      u8.set(this.r.toRawBytes());\n      u8.set(numberTo32BytesLE(this.s), 32);\n      return u8;\n    }\n    toHex() {\n      return bytesToHex(this.toRawBytes());\n    }\n  }\n  function concatBytes() {\n    for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n      arrays[_key] = arguments[_key];\n    }\n    if (!arrays.every(a => a instanceof Uint8Array)) throw new Error('Expected Uint8Array list');\n    if (arrays.length === 1) return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n      const arr = arrays[i];\n      result.set(arr, pad);\n      pad += arr.length;\n    }\n    return result;\n  }\n  const hexes = Array.from({\n    length: 256\n  }, (v, i) => i.toString(16).padStart(2, '0'));\n  function bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array)) throw new Error('Uint8Array expected');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n      hex += hexes[uint8a[i]];\n    }\n    return hex;\n  }\n  function hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n      throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n      const j = i * 2;\n      const hexByte = hex.slice(j, j + 2);\n      const byte = Number.parseInt(hexByte, 16);\n      if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n      array[i] = byte;\n    }\n    return array;\n  }\n  function numberTo32BytesBE(num) {\n    const length = 32;\n    const hex = num.toString(16).padStart(length * 2, '0');\n    return hexToBytes(hex);\n  }\n  function numberTo32BytesLE(num) {\n    return numberTo32BytesBE(num).reverse();\n  }\n  function edIsNegative(num) {\n    return (mod(num) & _1n) === _1n;\n  }\n  function bytesToNumberLE(uint8a) {\n    if (!(uint8a instanceof Uint8Array)) throw new Error('Expected Uint8Array');\n    return BigInt('0x' + bytesToHex(Uint8Array.from(uint8a).reverse()));\n  }\n  const MAX_255B = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\n  function bytes255ToNumberLE(bytes) {\n    return mod(bytesToNumberLE(bytes) & MAX_255B);\n  }\n  function mod(a) {\n    let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n    const res = a % b;\n    return res >= _0n ? res : b + res;\n  }\n  function invert(number) {\n    let modulo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n    if (number === _0n || modulo <= _0n) {\n      throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n,\n      u = _1n;\n    while (a !== _0n) {\n      const q = b / a;\n      const r = b % a;\n      const m = x - u * q;\n      b = a, a = r, x = u, u = m;\n    }\n    const gcd = b;\n    if (gcd !== _1n) throw new Error('invert: does not exist');\n    return mod(x, modulo);\n  }\n  function invertBatch(nums) {\n    let p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n    const tmp = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n      if (num === _0n) return acc;\n      tmp[i] = acc;\n      return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n      if (num === _0n) return acc;\n      tmp[i] = mod(acc * tmp[i], p);\n      return mod(acc * num, p);\n    }, inverted);\n    return tmp;\n  }\n  function pow2(x, power) {\n    const {\n      P\n    } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n      res *= res;\n      res %= P;\n    }\n    return res;\n  }\n  function pow_2_252_3(x) {\n    const {\n      P\n    } = CURVE;\n    const _5n = BigInt(5);\n    const _10n = BigInt(10);\n    const _20n = BigInt(20);\n    const _40n = BigInt(40);\n    const _80n = BigInt(80);\n    const x2 = x * x % P;\n    const b2 = x2 * x % P;\n    const b4 = pow2(b2, _2n) * b2 % P;\n    const b5 = pow2(b4, _1n) * x % P;\n    const b10 = pow2(b5, _5n) * b5 % P;\n    const b20 = pow2(b10, _10n) * b10 % P;\n    const b40 = pow2(b20, _20n) * b20 % P;\n    const b80 = pow2(b40, _40n) * b40 % P;\n    const b160 = pow2(b80, _80n) * b80 % P;\n    const b240 = pow2(b160, _80n) * b80 % P;\n    const b250 = pow2(b240, _10n) * b10 % P;\n    const pow_p_5_8 = pow2(b250, _2n) * x % P;\n    return {\n      pow_p_5_8,\n      b2\n    };\n  }\n  function uvRatio(u, v) {\n    const v3 = mod(v * v * v);\n    const v7 = mod(v3 * v3 * v);\n    const pow = pow_2_252_3(u * v7).pow_p_5_8;\n    let x = mod(u * v3 * pow);\n    const vx2 = mod(v * x * x);\n    const root1 = x;\n    const root2 = mod(x * SQRT_M1);\n    const useRoot1 = vx2 === u;\n    const useRoot2 = vx2 === mod(-u);\n    const noRoot = vx2 === mod(-u * SQRT_M1);\n    if (useRoot1) x = root1;\n    if (useRoot2 || noRoot) x = root2;\n    if (edIsNegative(x)) x = mod(-x);\n    return {\n      isValid: useRoot1 || useRoot2,\n      value: x\n    };\n  }\n  function invertSqrt(number) {\n    return uvRatio(_1n, number);\n  }\n  function modlLE(hash) {\n    return mod(bytesToNumberLE(hash), CURVE.l);\n  }\n  function equalBytes(b1, b2) {\n    if (b1.length !== b2.length) {\n      return false;\n    }\n    for (let i = 0; i < b1.length; i++) {\n      if (b1[i] !== b2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function ensureBytes(hex, expectedLength) {\n    const bytes = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n    if (typeof expectedLength === 'number' && bytes.length !== expectedLength) throw new Error(`Expected ${expectedLength} bytes`);\n    return bytes;\n  }\n  function normalizeScalar(num, max) {\n    let strict = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (!max) throw new TypeError('Specify max value');\n    if (typeof num === 'number' && Number.isSafeInteger(num)) num = BigInt(num);\n    if (typeof num === 'bigint' && num < max) {\n      if (strict) {\n        if (_0n < num) return num;\n      } else {\n        if (_0n <= num) return num;\n      }\n    }\n    throw new TypeError('Expected valid scalar: 0 < scalar < max');\n  }\n  function adjustBytes25519(bytes) {\n    bytes[0] &= 248;\n    bytes[31] &= 127;\n    bytes[31] |= 64;\n    return bytes;\n  }\n  function decodeScalar25519(n) {\n    return bytesToNumberLE(adjustBytes25519(ensureBytes(n, 32)));\n  }\n  function checkPrivateKey(key) {\n    key = typeof key === 'bigint' || typeof key === 'number' ? numberTo32BytesBE(normalizeScalar(key, POW_2_256)) : ensureBytes(key);\n    if (key.length !== 32) throw new Error(`Expected 32 bytes`);\n    return key;\n  }\n  function getKeyFromHash(hashed) {\n    const head = adjustBytes25519(hashed.slice(0, 32));\n    const prefix = hashed.slice(32, 64);\n    const scalar = modlLE(head);\n    const point = Point.BASE.multiply(scalar);\n    const pointBytes = point.toRawBytes();\n    return {\n      head,\n      prefix,\n      scalar,\n      point,\n      pointBytes\n    };\n  }\n  let _sha512Sync;\n  function sha512s() {\n    if (typeof _sha512Sync !== 'function') throw new Error('utils.sha512Sync must be set to use sync methods');\n    return _sha512Sync(...arguments);\n  }\n  async function getExtendedPublicKey(key) {\n    return getKeyFromHash(await utils.sha512(checkPrivateKey(key)));\n  }\n  function getExtendedPublicKeySync(key) {\n    return getKeyFromHash(sha512s(checkPrivateKey(key)));\n  }\n  async function getPublicKey(privateKey) {\n    return (await getExtendedPublicKey(privateKey)).pointBytes;\n  }\n  function getPublicKeySync(privateKey) {\n    return getExtendedPublicKeySync(privateKey).pointBytes;\n  }\n  async function sign(message, privateKey) {\n    message = ensureBytes(message);\n    const {\n      prefix,\n      scalar,\n      pointBytes\n    } = await getExtendedPublicKey(privateKey);\n    const r = modlLE(await utils.sha512(prefix, message));\n    const R = Point.BASE.multiply(r);\n    const k = modlLE(await utils.sha512(R.toRawBytes(), pointBytes, message));\n    const s = mod(r + k * scalar, CURVE.l);\n    return new Signature(R, s).toRawBytes();\n  }\n  function signSync(message, privateKey) {\n    message = ensureBytes(message);\n    const {\n      prefix,\n      scalar,\n      pointBytes\n    } = getExtendedPublicKeySync(privateKey);\n    const r = modlLE(sha512s(prefix, message));\n    const R = Point.BASE.multiply(r);\n    const k = modlLE(sha512s(R.toRawBytes(), pointBytes, message));\n    const s = mod(r + k * scalar, CURVE.l);\n    return new Signature(R, s).toRawBytes();\n  }\n  function prepareVerification(sig, message, publicKey) {\n    message = ensureBytes(message);\n    if (!(publicKey instanceof Point)) publicKey = Point.fromHex(publicKey, false);\n    const {\n      r,\n      s\n    } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);\n    const SB = ExtendedPoint.BASE.multiplyUnsafe(s);\n    return {\n      r,\n      s,\n      SB,\n      pub: publicKey,\n      msg: message\n    };\n  }\n  function finishVerification(publicKey, r, SB, hashed) {\n    const k = modlLE(hashed);\n    const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);\n    const RkA = ExtendedPoint.fromAffine(r).add(kA);\n    return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n  }\n  async function verify(sig, message, publicKey) {\n    const {\n      r,\n      SB,\n      msg,\n      pub\n    } = prepareVerification(sig, message, publicKey);\n    const hashed = await utils.sha512(r.toRawBytes(), pub.toRawBytes(), msg);\n    return finishVerification(pub, r, SB, hashed);\n  }\n  function verifySync(sig, message, publicKey) {\n    const {\n      r,\n      SB,\n      msg,\n      pub\n    } = prepareVerification(sig, message, publicKey);\n    const hashed = sha512s(r.toRawBytes(), pub.toRawBytes(), msg);\n    return finishVerification(pub, r, SB, hashed);\n  }\n  const sync = {\n    getExtendedPublicKey: getExtendedPublicKeySync,\n    getPublicKey: getPublicKeySync,\n    sign: signSync,\n    verify: verifySync\n  };\n  async function getSharedSecret(privateKey, publicKey) {\n    const {\n      head\n    } = await getExtendedPublicKey(privateKey);\n    const u = Point.fromHex(publicKey).toX25519();\n    return curve25519.scalarMult(head, u);\n  }\n  Point.BASE._setWindowSize(8);\n  function cswap(swap, x_2, x_3) {\n    const dummy = mod(swap * (x_2 - x_3));\n    x_2 = mod(x_2 - dummy);\n    x_3 = mod(x_3 + dummy);\n    return [x_2, x_3];\n  }\n  function montgomeryLadder(pointU, scalar) {\n    const {\n      P\n    } = CURVE;\n    const u = normalizeScalar(pointU, P);\n    const k = normalizeScalar(scalar, P);\n    const a24 = BigInt(121665);\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    let sw;\n    for (let t = BigInt(255 - 1); t >= _0n; t--) {\n      const k_t = k >> t & _1n;\n      swap ^= k_t;\n      sw = cswap(swap, x_2, x_3);\n      x_2 = sw[0];\n      x_3 = sw[1];\n      sw = cswap(swap, z_2, z_3);\n      z_2 = sw[0];\n      z_3 = sw[1];\n      swap = k_t;\n      const A = x_2 + z_2;\n      const AA = mod(A * A);\n      const B = x_2 - z_2;\n      const BB = mod(B * B);\n      const E = AA - BB;\n      const C = x_3 + z_3;\n      const D = x_3 - z_3;\n      const DA = mod(D * A);\n      const CB = mod(C * B);\n      const dacb = DA + CB;\n      const da_cb = DA - CB;\n      x_3 = mod(dacb * dacb);\n      z_3 = mod(x_1 * mod(da_cb * da_cb));\n      x_2 = mod(AA * BB);\n      z_2 = mod(E * (AA + mod(a24 * E)));\n    }\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    const {\n      pow_p_5_8,\n      b2\n    } = pow_2_252_3(z_2);\n    const xp2 = mod(pow2(pow_p_5_8, BigInt(3)) * b2);\n    return mod(x_2 * xp2);\n  }\n  function encodeUCoordinate(u) {\n    return numberTo32BytesLE(mod(u, CURVE.P));\n  }\n  function decodeUCoordinate(uEnc) {\n    const u = ensureBytes(uEnc, 32);\n    u[31] &= 127;\n    return bytesToNumberLE(u);\n  }\n  const curve25519 = {\n    BASE_POINT_U: '0900000000000000000000000000000000000000000000000000000000000000',\n    scalarMult(privateKey, publicKey) {\n      const u = decodeUCoordinate(publicKey);\n      const p = decodeScalar25519(privateKey);\n      const pu = montgomeryLadder(u, p);\n      if (pu === _0n) throw new Error('Invalid private or public key received');\n      return encodeUCoordinate(pu);\n    },\n    scalarMultBase(privateKey) {\n      return curve25519.scalarMult(privateKey, curve25519.BASE_POINT_U);\n    }\n  };\n  const crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined\n  };\n  const utils = {\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    getExtendedPublicKey,\n    mod,\n    invert,\n    TORSION_SUBGROUP: ['0100000000000000000000000000000000000000000000000000000000000000', 'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a', '0000000000000000000000000000000000000000000000000000000000000080', '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05', 'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f', '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85', '0000000000000000000000000000000000000000000000000000000000000000', 'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa'],\n    hashToPrivateScalar: hash => {\n      hash = ensureBytes(hash);\n      if (hash.length < 40 || hash.length > 1024) throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n      return mod(bytesToNumberLE(hash), CURVE.l - _1n) + _1n;\n    },\n    randomBytes: function () {\n      let bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;\n      if (crypto.web) {\n        return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n      } else if (crypto.node) {\n        const {\n          randomBytes\n        } = crypto.node;\n        return new Uint8Array(randomBytes(bytesLength).buffer);\n      } else {\n        throw new Error(\"The environment doesn't have randomBytes function\");\n      }\n    },\n    randomPrivateKey: () => {\n      return utils.randomBytes(32);\n    },\n    sha512: async function () {\n      const message = concatBytes(...arguments);\n      if (crypto.web) {\n        const buffer = await crypto.web.subtle.digest('SHA-512', message.buffer);\n        return new Uint8Array(buffer);\n      } else if (crypto.node) {\n        return Uint8Array.from(crypto.node.createHash('sha512').update(message).digest());\n      } else {\n        throw new Error(\"The environment doesn't have sha512 function\");\n      }\n    },\n    precompute() {\n      let windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n      let point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Point.BASE;\n      const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);\n      cached._setWindowSize(windowSize);\n      cached.multiply(_2n);\n      return cached;\n    },\n    sha512Sync: undefined\n  };\n  Object.defineProperties(utils, {\n    sha512Sync: {\n      configurable: false,\n      get() {\n        return _sha512Sync;\n      },\n      set(val) {\n        if (!_sha512Sync) _sha512Sync = val;\n      }\n    }\n  });\n  exports.CURVE = CURVE;\n  exports.ExtendedPoint = ExtendedPoint;\n  exports.Point = Point;\n  exports.RistrettoPoint = RistrettoPoint;\n  exports.Signature = Signature;\n  exports.curve25519 = curve25519;\n  exports.getPublicKey = getPublicKey;\n  exports.getSharedSecret = getSharedSecret;\n  exports.sign = sign;\n  exports.sync = sync;\n  exports.utils = utils;\n  exports.verify = verify;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});\n\n//# sourceURL=webpack://mytonwallet-lib/./src/lib/noble-ed25519/index.js?");

/***/ }),

/***/ "./src/util/Deferred.ts":
/*!******************************!*\
  !*** ./src/util/Deferred.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Deferred)\n/* harmony export */ });\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nclass Deferred {\n  constructor() {\n    _defineProperty(this, \"promise\", void 0);\n    _defineProperty(this, \"reject\", void 0);\n    _defineProperty(this, \"resolve\", void 0);\n    this.promise = new Promise((resolve, reject) => {\n      this.reject = reject;\n      this.resolve = resolve;\n    });\n  }\n  static resolved(value) {\n    const deferred = new Deferred();\n    deferred.resolve(value);\n    return deferred;\n  }\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/util/Deferred.ts?");

/***/ }),

/***/ "./src/util/account.ts":
/*!*****************************!*\
  !*** ./src/util/account.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"buildAccountId\": () => (/* binding */ buildAccountId),\n/* harmony export */   \"parseAccountId\": () => (/* binding */ parseAccountId)\n/* harmony export */ });\nfunction parseAccountId(accountId) {\n  const [id, blockchain = 'ton',\n  // Handle deprecated case when `accountId = '0'`\n  network = 'mainnet'] = accountId.split('-');\n  return {\n    id: Number(id),\n    blockchain: blockchain,\n    network: network\n  };\n}\nfunction buildAccountId(account) {\n  const {\n    id,\n    network,\n    blockchain\n  } = account;\n  return `${id}-${blockchain}-${network}`;\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/util/account.ts?");

/***/ }),

/***/ "./src/util/areDeepEqual.ts":
/*!**********************************!*\
  !*** ./src/util/areDeepEqual.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"areDeepEqual\": () => (/* binding */ areDeepEqual)\n/* harmony export */ });\nfunction areDeepEqual(value1, value2) {\n  const type1 = typeof value1;\n  const type2 = typeof value2;\n  if (type1 !== type2) {\n    return false;\n  }\n\n  // eslint-disable-next-line no-null/no-null\n  if (type1 !== 'object' || value1 === null || value2 === null) {\n    return value1 === value2;\n  }\n  const isArray1 = Array.isArray(value1);\n  const isArray2 = Array.isArray(value2);\n  if (isArray1 !== isArray2) {\n    return false;\n  }\n  if (isArray1) {\n    const array1 = value1;\n    const array2 = value2;\n    if (array1.length !== array2.length) {\n      return false;\n    }\n    return array1.every((member1, i) => areDeepEqual(member1, array2[i]));\n  }\n  const object1 = value1;\n  const object2 = value2;\n  const keys1 = Object.keys(object1);\n  return keys1.every(key1 => areDeepEqual(object1[key1], object2[key1]));\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/util/areDeepEqual.ts?");

/***/ }),

/***/ "./src/util/assert.ts":
/*!****************************!*\
  !*** ./src/util/assert.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"assert\": () => (/* binding */ assert)\n/* harmony export */ });\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'Assertion failed');\n  }\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/util/assert.ts?");

/***/ }),

/***/ "./src/util/bigint.ts":
/*!****************************!*\
  !*** ./src/util/bigint.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"bigintAbs\": () => (/* binding */ bigintAbs),\n/* harmony export */   \"bigintDivideToNumber\": () => (/* binding */ bigintDivideToNumber),\n/* harmony export */   \"bigintMultiplyToNumber\": () => (/* binding */ bigintMultiplyToNumber),\n/* harmony export */   \"bigintReviver\": () => (/* binding */ bigintReviver)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ \"./src/config.ts\");\n/* harmony import */ var _decimals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decimals */ \"./src/util/decimals.ts\");\n\n\nconst PREFIX = 'bigint:';\n\n// @ts-ignore\nBigInt.prototype.toJSON = function toJSON() {\n  return `${PREFIX}${this}`;\n};\nfunction bigintReviver(key, value) {\n  if (typeof value === 'string' && value.startsWith(PREFIX)) {\n    return BigInt(value.slice(7));\n  }\n  return value;\n}\nfunction bigintAbs(value) {\n  return value === -0n || value < 0n ? -value : value;\n}\nfunction bigintDivideToNumber(value, num) {\n  return value * _config__WEBPACK_IMPORTED_MODULE_0__.ONE_TON / (0,_decimals__WEBPACK_IMPORTED_MODULE_1__.fromDecimal)(num);\n}\nfunction bigintMultiplyToNumber(value, num) {\n  return value * (0,_decimals__WEBPACK_IMPORTED_MODULE_1__.fromDecimal)(num) / _config__WEBPACK_IMPORTED_MODULE_0__.ONE_TON;\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/util/bigint.ts?");

/***/ }),

/***/ "./src/util/callbacks.ts":
/*!*******************************!*\
  !*** ./src/util/callbacks.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EventEmitter\": () => (/* binding */ EventEmitter),\n/* harmony export */   \"createCallbackManager\": () => (/* binding */ createCallbackManager)\n/* harmony export */ });\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction createCallbackManager() {\n  const callbacks = new Set();\n  function addCallback(cb) {\n    callbacks.add(cb);\n    return () => {\n      removeCallback(cb);\n    };\n  }\n  function removeCallback(cb) {\n    callbacks.delete(cb);\n  }\n  function runCallbacks() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    callbacks.forEach(callback => {\n      callback(...args);\n    });\n  }\n  function hasCallbacks() {\n    return Boolean(callbacks.size);\n  }\n  return {\n    runCallbacks,\n    addCallback,\n    removeCallback,\n    hasCallbacks\n  };\n}\nclass EventEmitter {\n  constructor() {\n    _defineProperty(this, \"channels\", new Map());\n  }\n  on(name, handler) {\n    this.resolveChannel(name).addCallback(handler);\n    return this;\n  }\n  removeListener(name, handler) {\n    this.resolveChannel(name).removeCallback(handler);\n    return this;\n  }\n  emit(name) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    this.resolveChannel(name).runCallbacks(...args);\n    return this;\n  }\n  resolveChannel(name) {\n    let channel = this.channels.get(name);\n    if (!channel) {\n      channel = createCallbackManager();\n      this.channels.set(name, channel);\n    }\n    return channel;\n  }\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/util/callbacks.ts?");

/***/ }),

/***/ "./src/util/compareActivities.ts":
/*!***************************************!*\
  !*** ./src/util/compareActivities.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"compareActivities\": () => (/* binding */ compareActivities)\n/* harmony export */ });\nfunction compareActivities(a, b) {\n  let isAsc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let value = a.timestamp - b.timestamp;\n  if (value === 0) {\n    value = a.id > b.id ? 1 : a.id < b.id ? -1 : 0;\n  }\n  return isAsc ? value : -value;\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/util/compareActivities.ts?");

/***/ }),

/***/ "./src/util/createPostMessageInterface.ts":
/*!************************************************!*\
  !*** ./src/util/createPostMessageInterface.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createPostMessageInterface\": () => (/* binding */ createPostMessageInterface)\n/* harmony export */ });\n/* harmony import */ var _logs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logs */ \"./src/util/logs.ts\");\n\nconst callbackState = new Map();\nfunction createPostMessageInterface(api, channel) {\n  let target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : self;\n  let shouldIgnoreErrors = arguments.length > 3 ? arguments[3] : undefined;\n  function sendToOrigin(data, transferables) {\n    data.channel = channel;\n    if (transferables) {\n      target.postMessage(data, transferables);\n    } else {\n      target.postMessage(data);\n    }\n  }\n  if (!shouldIgnoreErrors) {\n    handleErrors(sendToOrigin);\n  }\n  target.onmessage = message => {\n    var _message$data;\n    if (((_message$data = message.data) === null || _message$data === void 0 ? void 0 : _message$data.channel) === channel) {\n      onMessage(api, message.data, sendToOrigin);\n    }\n  };\n}\nasync function onMessage(api, data, sendToOrigin, onUpdate, origin) {\n  if (!onUpdate) {\n    onUpdate = update => {\n      sendToOrigin({\n        type: 'update',\n        update\n      });\n    };\n  }\n  switch (data.type) {\n    case 'init':\n      {\n        var _api$init;\n        const {\n          args\n        } = data;\n        const promise = typeof api === 'function' ? api('init', origin, onUpdate, ...args) : (_api$init = api.init) === null || _api$init === void 0 ? void 0 : _api$init.call(api, onUpdate, ...args);\n        await promise;\n        break;\n      }\n    case 'callMethod':\n      {\n        const {\n          messageId,\n          name,\n          args,\n          withCallback\n        } = data;\n        try {\n          if (messageId && withCallback) {\n            const callback = function () {\n              for (var _len = arguments.length, callbackArgs = new Array(_len), _key = 0; _key < _len; _key++) {\n                callbackArgs[_key] = arguments[_key];\n              }\n              const lastArg = callbackArgs[callbackArgs.length - 1];\n              sendToOrigin({\n                type: 'methodCallback',\n                messageId,\n                callbackArgs\n              }, isTransferable(lastArg) ? [lastArg] : undefined);\n            };\n            callbackState.set(messageId, callback);\n            args.push(callback);\n          }\n          const response = typeof api === 'function' ? await api(name, origin, ...args) : await api[name](...args);\n          const {\n            arrayBuffer\n          } = typeof response === 'object' && 'arrayBuffer' in response && response || {};\n          if (messageId) {\n            sendToOrigin({\n              type: 'methodResponse',\n              messageId,\n              response\n            }, arrayBuffer ? [arrayBuffer] : undefined);\n          }\n        } catch (err) {\n          (0,_logs__WEBPACK_IMPORTED_MODULE_0__.logDebugError)(name, err);\n          if (messageId) {\n            sendToOrigin({\n              type: 'methodResponse',\n              messageId,\n              error: {\n                message: err.message\n              }\n            });\n          }\n        }\n        if (messageId) {\n          callbackState.delete(messageId);\n        }\n        break;\n      }\n    case 'cancelProgress':\n      {\n        const callback = callbackState.get(data.messageId);\n        if (callback) {\n          callback.isCanceled = true;\n        }\n        break;\n      }\n  }\n}\nfunction isTransferable(obj) {\n  return obj instanceof ArrayBuffer || obj instanceof ImageBitmap;\n}\nfunction handleErrors(sendToOrigin) {\n  self.onerror = e => {\n    var _e$error;\n    // eslint-disable-next-line no-console\n    console.error(e);\n    sendToOrigin({\n      type: 'unhandledError',\n      error: {\n        message: ((_e$error = e.error) === null || _e$error === void 0 ? void 0 : _e$error.message) || 'Uncaught exception in worker'\n      }\n    });\n  };\n  self.addEventListener('unhandledrejection', e => {\n    var _e$reason;\n    // eslint-disable-next-line no-console\n    console.error(e);\n    sendToOrigin({\n      type: 'unhandledError',\n      error: {\n        message: ((_e$reason = e.reason) === null || _e$reason === void 0 ? void 0 : _e$reason.message) || 'Uncaught rejection in worker'\n      }\n    });\n  });\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/util/createPostMessageInterface.ts?");

/***/ }),

/***/ "./src/util/decimals.ts":
/*!******************************!*\
  !*** ./src/util/decimals.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"fromDecimal\": () => (/* binding */ fromDecimal),\n/* harmony export */   \"getIsPositiveDecimal\": () => (/* binding */ getIsPositiveDecimal),\n/* harmony export */   \"roundDecimal\": () => (/* binding */ roundDecimal),\n/* harmony export */   \"toBig\": () => (/* binding */ toBig),\n/* harmony export */   \"toDecimal\": () => (/* binding */ toDecimal)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ \"./src/config.ts\");\n/* harmony import */ var _lib_big_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/big.js */ \"./src/lib/big.js/index.js\");\n\n\n_lib_big_js__WEBPACK_IMPORTED_MODULE_1__.Big.RM = 0; // RoundDown\n_lib_big_js__WEBPACK_IMPORTED_MODULE_1__.Big.NE = -100000; // Disable exponential form\n_lib_big_js__WEBPACK_IMPORTED_MODULE_1__.Big.PE = 100000; // Disable exponential form\n\nconst ten = (0,_lib_big_js__WEBPACK_IMPORTED_MODULE_1__.Big)(10);\nfunction fromDecimal(value, decimals) {\n  return BigInt((0,_lib_big_js__WEBPACK_IMPORTED_MODULE_1__.Big)(value).mul(ten.pow(decimals !== null && decimals !== void 0 ? decimals : _config__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_DECIMAL_PLACES)).round().toString());\n}\nfunction toDecimal(value, decimals) {\n  let noFloor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return toBig(value, decimals !== null && decimals !== void 0 ? decimals : _config__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_DECIMAL_PLACES, noFloor).toString();\n}\nfunction toBig(value) {\n  let decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _config__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_DECIMAL_PLACES;\n  let noFloor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return (0,_lib_big_js__WEBPACK_IMPORTED_MODULE_1__.Big)(value.toString()).div(ten.pow(decimals)).round(decimals, noFloor ? _lib_big_js__WEBPACK_IMPORTED_MODULE_1__.Big.roundHalfUp : undefined);\n}\nfunction roundDecimal(value, decimals) {\n  return (0,_lib_big_js__WEBPACK_IMPORTED_MODULE_1__.Big)(value).round(decimals).toString();\n}\nfunction getIsPositiveDecimal(value) {\n  return !value.startsWith('-');\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/util/decimals.ts?");

/***/ }),

/***/ "./src/util/dns.ts":
/*!*************************!*\
  !*** ./src/util/dns.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst zones = ['ton', 't.me', 'vip'];\nconst zonesRegex = {\n  ton: /^([-\\da-z]+\\.){0,2}([-\\da-z]{4,126})\\.ton$/i,\n  't.me': /^([-\\da-z]+\\.){0,2}([-_\\da-z]{4,126})\\.t\\.me$/i,\n  vip: /^(?<base>([-\\da-z]+\\.){0,2}([\\da-z]{1,24}))\\.(ton\\.vip|vip\\.ton|vip)$/i\n};\nfunction isDnsDomain(value) {\n  return Object.values(zonesRegex).some(zone => zone.test(value));\n}\nfunction isVipDnsDomain(value) {\n  return zonesRegex.vip.test(value);\n}\nfunction removeVipZone(value) {\n  var _value$match;\n  value = value.replace(/\\.ton\\.vip$/i, '.vip').replace(/\\.vip\\.ton$/i, '.vip');\n  return (_value$match = value.match(zonesRegex.vip)) === null || _value$match === void 0 || (_value$match = _value$match.groups) === null || _value$match === void 0 ? void 0 : _value$match.base;\n}\nfunction removeTonZone(value) {\n  return value.replace(/\\.ton$/i, '');\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  zones,\n  zonesRegex,\n  isDnsDomain,\n  isVipDnsDomain,\n  removeVipZone,\n  removeTonZone\n});\n\n//# sourceURL=webpack://mytonwallet-lib/./src/util/dns.ts?");

/***/ }),

/***/ "./src/util/fetch.ts":
/*!***************************!*\
  !*** ./src/util/fetch.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"fetchJson\": () => (/* binding */ fetchJson),\n/* harmony export */   \"fetchWithRetry\": () => (/* binding */ fetchWithRetry),\n/* harmony export */   \"fetchWithTimeout\": () => (/* binding */ fetchWithTimeout),\n/* harmony export */   \"handleFetchErrors\": () => (/* binding */ handleFetchErrors)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ \"./src/config.ts\");\n/* harmony import */ var _api_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api/errors */ \"./src/api/errors.ts\");\n/* harmony import */ var _logs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./logs */ \"./src/util/logs.ts\");\n/* harmony import */ var _schedulers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./schedulers */ \"./src/util/schedulers.ts\");\n\n\n\n\nconst DEFAULT_TIMEOUTS = [5000, 10000, 30000]; // 5, 10, 30 sec\n\nasync function fetchJson(url, data, init) {\n  const urlObject = new URL(url);\n  if (data) {\n    Object.entries(data).forEach(_ref => {\n      let [key, value] = _ref;\n      if (value === undefined) {\n        return;\n      }\n      if (Array.isArray(value)) {\n        value.forEach(item => {\n          urlObject.searchParams.append(key, item.toString());\n        });\n      } else {\n        urlObject.searchParams.set(key, value.toString());\n      }\n    });\n  }\n  const response = await fetchWithRetry(urlObject, init);\n  return response.json();\n}\nasync function fetchWithRetry(url, init, options) {\n  const {\n    retries = _config__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_RETRIES,\n    timeouts = DEFAULT_TIMEOUTS,\n    conditionFn\n  } = options !== null && options !== void 0 ? options : {};\n  let message = 'Unknown error.';\n  let statusCode;\n  for (let i = 1; i <= retries; i++) {\n    try {\n      var _timeouts;\n      if (i > 1) {\n        (0,_logs__WEBPACK_IMPORTED_MODULE_2__.logDebug)(`Retry request #${i}:`, url.toString());\n      }\n      const timeout = Array.isArray(timeouts) ? (_timeouts = timeouts[i - 1]) !== null && _timeouts !== void 0 ? _timeouts : timeouts[timeouts.length - 1] : timeouts;\n      const response = await fetchWithTimeout(url, init, timeout);\n      statusCode = response.status;\n      if (statusCode >= 400) {\n        if (response.headers.get('content-type') !== 'application/json') {\n          throw new Error(`HTTP Error ${statusCode}`);\n        }\n        const {\n          error\n        } = await response.json();\n        throw new Error(error !== null && error !== void 0 ? error : `HTTP Error ${statusCode}`);\n      }\n      return response;\n    } catch (err) {\n      var _err$message;\n      message = typeof err === 'string' ? err : (_err$message = err.message) !== null && _err$message !== void 0 ? _err$message : message;\n      if (statusCode === 400 || conditionFn !== null && conditionFn !== void 0 && conditionFn(message, statusCode)) {\n        throw new _api_errors__WEBPACK_IMPORTED_MODULE_1__.ApiServerError(message, statusCode);\n      }\n      if (i < retries) {\n        await (0,_schedulers__WEBPACK_IMPORTED_MODULE_3__.pause)(_config__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_ERROR_PAUSE * i);\n      }\n    }\n  }\n  throw new _api_errors__WEBPACK_IMPORTED_MODULE_1__.ApiServerError(message);\n}\nasync function fetchWithTimeout(url, init) {\n  let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _config__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_TIMEOUT;\n  const controller = new AbortController();\n  const id = setTimeout(() => {\n    controller.abort();\n  }, timeout);\n  try {\n    return await fetch(url, {\n      ...init,\n      signal: controller.signal\n    });\n  } finally {\n    clearTimeout(id);\n  }\n}\nfunction handleFetchErrors(response, ignoreHttpCodes) {\n  if (!response.ok && !(ignoreHttpCodes !== null && ignoreHttpCodes !== void 0 && ignoreHttpCodes.includes(response.status))) {\n    throw new Error(response.statusText);\n  }\n  return response;\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/util/fetch.ts?");

/***/ }),

/***/ "./src/util/generateUniqueId.ts":
/*!**************************************!*\
  !*** ./src/util/generateUniqueId.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ generateUniqueId)\n/* harmony export */ });\nfunction generateUniqueId() {\n  return Date.now().toString(36) + Math.random().toString(36).slice(2);\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/util/generateUniqueId.ts?");

/***/ }),

/***/ "./src/util/handleError.ts":
/*!*********************************!*\
  !*** ./src/util/handleError.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"handleError\": () => (/* binding */ handleError)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ \"./src/config.ts\");\n/* harmony import */ var _schedulers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedulers */ \"./src/util/schedulers.ts\");\n\n\nconst noop = () => {};\nconst throttledAlert = typeof window !== 'undefined' ? (0,_schedulers__WEBPACK_IMPORTED_MODULE_1__.throttle)(window.alert, 1000) : noop;\n\n// eslint-disable-next-line no-restricted-globals\nself.addEventListener('error', handleErrorEvent);\n// eslint-disable-next-line no-restricted-globals\nself.addEventListener('unhandledrejection', handleErrorEvent);\nfunction handleErrorEvent(e) {\n  // https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded\n  if (e instanceof ErrorEvent && e.message === 'ResizeObserver loop limit exceeded') {\n    return;\n  }\n  e.preventDefault();\n  handleError(e instanceof ErrorEvent ? e.error || e.message : e.reason);\n}\nfunction handleError(err) {\n  // eslint-disable-next-line no-console\n  console.error(err);\n  if (_config__WEBPACK_IMPORTED_MODULE_0__.APP_ENV === 'development' || _config__WEBPACK_IMPORTED_MODULE_0__.APP_ENV === 'staging') {\n    throttledAlert(`${_config__WEBPACK_IMPORTED_MODULE_0__.DEBUG_ALERT_MSG}\\n\\n${(err === null || err === void 0 ? void 0 : err.message) || err}\\n${err === null || err === void 0 ? void 0 : err.stack}`);\n  }\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/util/handleError.ts?");

/***/ }),

/***/ "./src/util/iteratees.ts":
/*!*******************************!*\
  !*** ./src/util/iteratees.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"areSortedArraysEqual\": () => (/* binding */ areSortedArraysEqual),\n/* harmony export */   \"buildCollectionByKey\": () => (/* binding */ buildCollectionByKey),\n/* harmony export */   \"cloneDeep\": () => (/* binding */ cloneDeep),\n/* harmony export */   \"compact\": () => (/* binding */ compact),\n/* harmony export */   \"extractKey\": () => (/* binding */ extractKey),\n/* harmony export */   \"findLast\": () => (/* binding */ findLast),\n/* harmony export */   \"fromKeyValueArrays\": () => (/* binding */ fromKeyValueArrays),\n/* harmony export */   \"mapValues\": () => (/* binding */ mapValues),\n/* harmony export */   \"omit\": () => (/* binding */ omit),\n/* harmony export */   \"orderBy\": () => (/* binding */ orderBy),\n/* harmony export */   \"pick\": () => (/* binding */ pick),\n/* harmony export */   \"pickTruthy\": () => (/* binding */ pickTruthy),\n/* harmony export */   \"range\": () => (/* binding */ range),\n/* harmony export */   \"split\": () => (/* binding */ split),\n/* harmony export */   \"unique\": () => (/* binding */ unique)\n/* harmony export */ });\nfunction buildCollectionByKey(collection, key) {\n  return collection.reduce((byKey, member) => {\n    byKey[member[key]] = member;\n    return byKey;\n  }, {});\n}\nfunction mapValues(byKey, callback) {\n  return Object.keys(byKey).reduce((newByKey, key, index) => {\n    newByKey[key] = callback(byKey[key], key, index, byKey);\n    return newByKey;\n  }, {});\n}\nfunction pick(object, keys) {\n  return keys.reduce((result, key) => {\n    result[key] = object[key];\n    return result;\n  }, {});\n}\nfunction pickTruthy(object, keys) {\n  return keys.reduce((result, key) => {\n    if (object[key]) {\n      result[key] = object[key];\n    }\n    return result;\n  }, {});\n}\nfunction omit(object, keys) {\n  const stringKeys = new Set(keys.map(String));\n  const savedKeys = Object.keys(object).filter(key => !stringKeys.has(key));\n  return pick(object, savedKeys);\n}\nfunction orderBy(collection, orderRule) {\n  let mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'asc';\n  function compareValues(a, b, currentOrderRule, isAsc) {\n    const aValue = (typeof currentOrderRule === 'function' ? currentOrderRule(a) : a[currentOrderRule]) || 0;\n    const bValue = (typeof currentOrderRule === 'function' ? currentOrderRule(b) : b[currentOrderRule]) || 0;\n    return isAsc ? aValue - bValue : bValue - aValue;\n  }\n  if (Array.isArray(orderRule)) {\n    const [mode1, mode2] = Array.isArray(mode) ? mode : [mode, mode];\n    const [orderRule1, orderRule2] = orderRule;\n    const isAsc1 = mode1 === 'asc';\n    const isAsc2 = mode2 === 'asc';\n    return collection.sort((a, b) => {\n      return compareValues(a, b, orderRule1, isAsc1) || compareValues(a, b, orderRule2, isAsc2);\n    });\n  }\n  const isAsc = mode === 'asc';\n  return collection.sort((a, b) => {\n    return compareValues(a, b, orderRule, isAsc);\n  });\n}\nfunction unique(array) {\n  return Array.from(new Set(array));\n}\nfunction compact(array) {\n  return array.filter(Boolean);\n}\nfunction areSortedArraysEqual(array1, array2) {\n  if (array1.length !== array2.length) {\n    return false;\n  }\n  return array1.every((item, i) => item === array2[i]);\n}\nfunction split(array, chunkSize) {\n  const result = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    result.push(array.slice(i, i + chunkSize));\n  }\n  return result;\n}\nfunction cloneDeep(value) {\n  if (!isObject(value)) {\n    return value;\n  }\n  if (Array.isArray(value)) {\n    return value.map(cloneDeep);\n  }\n  return Object.keys(value).reduce((acc, key) => {\n    acc[key] = cloneDeep(value[key]);\n    return acc;\n  }, {});\n}\nfunction isObject(value) {\n  // eslint-disable-next-line no-null/no-null\n  return typeof value === 'object' && value !== null;\n}\nfunction findLast(array, predicate) {\n  let cursor = array.length;\n  while (cursor--) {\n    if (predicate(array[cursor], cursor, array)) {\n      return array[cursor];\n    }\n  }\n  return undefined;\n}\nfunction range(start, end) {\n  const arr = [];\n  for (let i = start; i < end;) {\n    arr.push(i++);\n  }\n  return arr;\n}\nfunction fromKeyValueArrays(keys, values) {\n  return keys.reduce((acc, key, index) => {\n    acc[key] = Array.isArray(values) ? values[index] : values;\n    return acc;\n  }, {});\n}\nfunction extractKey(array, key) {\n  return array.map(value => value[key]);\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/util/iteratees.ts?");

/***/ }),

/***/ "./src/util/logs.ts":
/*!**************************!*\
  !*** ./src/util/logs.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"logDebug\": () => (/* binding */ logDebug),\n/* harmony export */   \"logDebugError\": () => (/* binding */ logDebugError)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ \"./src/config.ts\");\n\nfunction logDebugError(message) {\n  if (_config__WEBPACK_IMPORTED_MODULE_0__.DEBUG) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    // eslint-disable-next-line no-console\n    console.error(`[DEBUG][${message}]`, ...args);\n  }\n}\nfunction logDebug(message) {\n  if (_config__WEBPACK_IMPORTED_MODULE_0__.DEBUG) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    // eslint-disable-next-line no-console\n    console.log(`[DEBUG] ${message}`, ...args);\n  }\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/util/logs.ts?");

/***/ }),

/***/ "./src/util/metadata.ts":
/*!******************************!*\
  !*** ./src/util/metadata.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"fetchJsonMetadata\": () => (/* binding */ fetchJsonMetadata),\n/* harmony export */   \"fixIpfsUrl\": () => (/* binding */ fixIpfsUrl)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ \"./src/config.ts\");\n\nconst IPFS_GATEWAY_BASE_URL = 'https://ipfs.io/ipfs/';\nfunction fetchJsonMetadata(url) {\n  url = fixIpfsUrl(url);\n  const reserveUrl = `${_config__WEBPACK_IMPORTED_MODULE_0__.BRILLIANT_API_BASE_URL}/utils/download-json?url=${url}`;\n  return fetchJson(url).catch(() => {\n    return fetchJson(reserveUrl);\n  });\n}\nfunction fixIpfsUrl(url) {\n  return url.replace('ipfs://', IPFS_GATEWAY_BASE_URL);\n}\nasync function fetchJson(url) {\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw Error(`Http error ${response.status}`);\n  }\n  return response.json();\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/util/metadata.ts?");

/***/ }),

/***/ "./src/util/pauseOrFocus.ts":
/*!**********************************!*\
  !*** ./src/util/pauseOrFocus.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"pauseOrFocus\": () => (/* binding */ pauseOrFocus),\n/* harmony export */   \"setIsAppFocused\": () => (/* binding */ setIsAppFocused)\n/* harmony export */ });\n/* harmony import */ var _schedulers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedulers */ \"./src/util/schedulers.ts\");\n/* harmony import */ var _Deferred__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Deferred */ \"./src/util/Deferred.ts\");\n\n\nconst deferreds = new Set();\nlet isFocused = true;\nfunction pauseOrFocus(ms) {\n  let msWhenNotFocused = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ms;\n  const deferred = new _Deferred__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n  deferreds.add(deferred);\n  deferred.promise.then(() => {\n    deferreds.delete(deferred);\n  });\n  (0,_schedulers__WEBPACK_IMPORTED_MODULE_0__.pause)(isFocused ? ms : msWhenNotFocused).then(deferred.resolve);\n  return deferred.promise;\n}\nfunction setIsAppFocused(_isFocused) {\n  isFocused = _isFocused;\n  if (_isFocused) {\n    deferreds.forEach(d => d.resolve());\n  }\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/util/pauseOrFocus.ts?");

/***/ }),

/***/ "./src/util/safeExec.ts":
/*!******************************!*\
  !*** ./src/util/safeExec.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ safeExec)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ \"./src/config.ts\");\n/* harmony import */ var _handleError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./handleError */ \"./src/util/handleError.ts\");\n\n\nconst SAFE_EXEC_ENABLED = !_config__WEBPACK_IMPORTED_MODULE_0__.DEBUG_MORE;\nfunction safeExec(cb, rescue, always) {\n  if (!SAFE_EXEC_ENABLED) {\n    return cb();\n  }\n  try {\n    return cb();\n  } catch (err) {\n    rescue === null || rescue === void 0 || rescue(err);\n    (0,_handleError__WEBPACK_IMPORTED_MODULE_1__.handleError)(err);\n    return undefined;\n  } finally {\n    always === null || always === void 0 || always();\n  }\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/util/safeExec.ts?");

/***/ }),

/***/ "./src/util/schedulers.ts":
/*!********************************!*\
  !*** ./src/util/schedulers.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"debounce\": () => (/* binding */ debounce),\n/* harmony export */   \"fastRaf\": () => (/* binding */ fastRaf),\n/* harmony export */   \"onBeforeUnload\": () => (/* binding */ onBeforeUnload),\n/* harmony export */   \"onIdle\": () => (/* binding */ onIdle),\n/* harmony export */   \"onTickEnd\": () => (/* binding */ onTickEnd),\n/* harmony export */   \"pause\": () => (/* binding */ pause),\n/* harmony export */   \"rafPromise\": () => (/* binding */ rafPromise),\n/* harmony export */   \"throttle\": () => (/* binding */ throttle),\n/* harmony export */   \"throttleWith\": () => (/* binding */ throttleWith),\n/* harmony export */   \"throttleWithTickEnd\": () => (/* binding */ throttleWithTickEnd),\n/* harmony export */   \"waitFor\": () => (/* binding */ waitFor)\n/* harmony export */ });\nfunction debounce(fn, ms) {\n  let shouldRunFirst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let shouldRunLast = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  let waitingTimeout;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (waitingTimeout) {\n      clearTimeout(waitingTimeout);\n      waitingTimeout = undefined;\n    } else if (shouldRunFirst) {\n      fn(...args);\n    }\n\n    // eslint-disable-next-line no-restricted-globals\n    waitingTimeout = self.setTimeout(() => {\n      if (shouldRunLast) {\n        fn(...args);\n      }\n      waitingTimeout = undefined;\n    }, ms);\n  };\n}\nfunction throttle(fn, ms) {\n  let shouldRunFirst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let interval;\n  let isPending;\n  let args;\n  return function () {\n    isPending = true;\n    for (var _len2 = arguments.length, _args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      _args[_key2] = arguments[_key2];\n    }\n    args = _args;\n    if (!interval) {\n      if (shouldRunFirst) {\n        isPending = false;\n        fn(...args);\n      }\n\n      // eslint-disable-next-line no-restricted-globals\n      interval = self.setInterval(() => {\n        if (!isPending) {\n          // eslint-disable-next-line no-restricted-globals\n          self.clearInterval(interval);\n          interval = undefined;\n          return;\n        }\n        isPending = false;\n        fn(...args);\n      }, ms);\n    }\n  };\n}\nfunction throttleWithTickEnd(fn) {\n  return throttleWith(onTickEnd, fn);\n}\nfunction throttleWith(schedulerFn, fn) {\n  let waiting = false;\n  let args;\n  return function () {\n    for (var _len3 = arguments.length, _args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      _args[_key3] = arguments[_key3];\n    }\n    args = _args;\n    if (!waiting) {\n      waiting = true;\n      schedulerFn(() => {\n        waiting = false;\n        fn(...args);\n      });\n    }\n  };\n}\nfunction onIdle(cb, timeout) {\n  // eslint-disable-next-line no-restricted-globals\n  if (self.requestIdleCallback) {\n    // eslint-disable-next-line no-restricted-globals\n    self.requestIdleCallback(cb, {\n      timeout\n    });\n  } else {\n    onTickEnd(cb);\n  }\n}\nconst pause = ms => new Promise(resolve => {\n  setTimeout(() => resolve(), ms);\n});\nfunction rafPromise() {\n  return new Promise(resolve => {\n    fastRaf(resolve);\n  });\n}\nconst FAST_RAF_TIMEOUT_FALLBACK_MS = 35; // < 30 FPS\n\nlet fastRafCallbacks;\nlet fastRafFallbackCallbacks;\nlet fastRafFallbackTimeout;\n\n// May result in an immediate execution if called from another RAF callback which was scheduled\n// (and therefore is executed) earlier than RAF callback scheduled by `fastRaf`\nfunction fastRaf(callback) {\n  let withTimeoutFallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (!fastRafCallbacks) {\n    fastRafCallbacks = new Set([callback]);\n    requestAnimationFrame(() => {\n      const currentCallbacks = fastRafCallbacks;\n      fastRafCallbacks = undefined;\n      fastRafFallbackCallbacks = undefined;\n      if (fastRafFallbackTimeout) {\n        clearTimeout(fastRafFallbackTimeout);\n        fastRafFallbackTimeout = undefined;\n      }\n      currentCallbacks.forEach(cb => cb());\n    });\n  } else {\n    fastRafCallbacks.add(callback);\n  }\n  if (withTimeoutFallback) {\n    if (!fastRafFallbackCallbacks) {\n      fastRafFallbackCallbacks = new Set([callback]);\n    } else {\n      fastRafFallbackCallbacks.add(callback);\n    }\n    if (!fastRafFallbackTimeout) {\n      fastRafFallbackTimeout = window.setTimeout(() => {\n        const currentTimeoutCallbacks = fastRafFallbackCallbacks;\n        if (fastRafCallbacks) {\n          currentTimeoutCallbacks.forEach(fastRafCallbacks.delete, fastRafCallbacks);\n        }\n        fastRafFallbackCallbacks = undefined;\n        if (fastRafFallbackTimeout) {\n          clearTimeout(fastRafFallbackTimeout);\n          fastRafFallbackTimeout = undefined;\n        }\n        currentTimeoutCallbacks.forEach(cb => cb());\n      }, FAST_RAF_TIMEOUT_FALLBACK_MS);\n    }\n  }\n}\nlet onTickEndCallbacks;\nfunction onTickEnd(callback) {\n  if (!onTickEndCallbacks) {\n    onTickEndCallbacks = [callback];\n    Promise.resolve().then(() => {\n      const currentCallbacks = onTickEndCallbacks;\n      onTickEndCallbacks = undefined;\n      currentCallbacks.forEach(cb => cb());\n    });\n  } else {\n    onTickEndCallbacks.push(callback);\n  }\n}\nlet beforeUnloadCallbacks;\nfunction onBeforeUnload(callback) {\n  let isLast = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (!beforeUnloadCallbacks) {\n    beforeUnloadCallbacks = [];\n    // eslint-disable-next-line no-restricted-globals\n    self.addEventListener('beforeunload', () => {\n      beforeUnloadCallbacks.forEach(cb => cb());\n    });\n  }\n  if (isLast) {\n    beforeUnloadCallbacks.push(callback);\n  } else {\n    beforeUnloadCallbacks.unshift(callback);\n  }\n  return () => {\n    beforeUnloadCallbacks = beforeUnloadCallbacks.filter(cb => cb !== callback);\n  };\n}\nasync function waitFor(cb, interval, attempts) {\n  let i = 0;\n  let result = cb();\n  while (!result && i < attempts) {\n    await pause(interval);\n    i++;\n    result = cb();\n  }\n  return result;\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/util/schedulers.ts?");

/***/ }),

/***/ "./src/util/stringFormat.ts":
/*!**********************************!*\
  !*** ./src/util/stringFormat.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isAscii\": () => (/* binding */ isAscii)\n/* harmony export */ });\nfunction isAscii(str) {\n  for (let i = 0; i < str.length; i++) {\n    if (str.charCodeAt(i) > 127) {\n      return false;\n    }\n  }\n  return true;\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/util/stringFormat.ts?");

/***/ }),

/***/ "./src/util/swap/buildSwapId.ts":
/*!**************************************!*\
  !*** ./src/util/swap/buildSwapId.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"buildSwapId\": () => (/* binding */ buildSwapId)\n/* harmony export */ });\nfunction buildSwapId(backendId) {\n  return `swap:${backendId}`;\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/util/swap/buildSwapId.ts?");

/***/ }),

/***/ "./src/util/withCacheAsync.ts":
/*!************************************!*\
  !*** ./src/util/withCacheAsync.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ withCacheAsync)\n/* harmony export */ });\nconst cache = new WeakMap();\nfunction withCacheAsync(fn) {\n  let canBeCached = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : value => !!value;\n  return async function () {\n    let fnCache = cache.get(fn);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    const cacheKey = buildCacheKey(args);\n    if (fnCache) {\n      const cached = fnCache.get(cacheKey);\n      if (cached) {\n        return cached;\n      }\n    } else {\n      fnCache = new Map();\n      cache.set(fn, fnCache);\n    }\n    const newValue = await fn(...args);\n    if (canBeCached(newValue)) {\n      fnCache.set(cacheKey, newValue);\n    }\n    return newValue;\n  };\n}\nfunction buildCacheKey(args) {\n  return args.reduce((cacheKey, arg) => {\n    return `${cacheKey}_${typeof arg === 'object' ? JSON.stringify(args) : arg}`;\n  }, '');\n}\n\n//# sourceURL=webpack://mytonwallet-lib/./src/util/withCacheAsync.ts?");

/***/ }),

/***/ "?44dc":
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://mytonwallet-lib/buffer_(ignored)?");

/***/ }),

/***/ "?dba7":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://mytonwallet-lib/crypto_(ignored)?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// the startup function
/******/ 	__webpack_require__.x = () => {
/******/ 		// Load entry module and return exports
/******/ 		// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 		var __webpack_exports__ = __webpack_require__.O(undefined, ["vendors-node_modules_ton_ton_dist_client_TonClient_js-node_modules_ton_ton_dist_wallets_Walle-18999f"], () => (__webpack_require__("./src/api/providers/worker/provider.ts")))
/******/ 		__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 		return __webpack_exports__;
/******/ 	};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks and sibling chunks for the entrypoint
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".bundle.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = {
/******/ 			"worker": 1
/******/ 		};
/******/ 		
/******/ 		// importScripts chunk loading
/******/ 		var installChunk = (data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			while(chunkIds.length)
/******/ 				installedChunks[chunkIds.pop()] = 1;
/******/ 			parentChunkLoadingFunction(data);
/******/ 		};
/******/ 		__webpack_require__.f.i = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					importScripts(__webpack_require__.p + __webpack_require__.u(chunkId));
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkmytonwallet_lib"] = self["webpackChunkmytonwallet_lib"] || [];
/******/ 		var parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);
/******/ 		chunkLoadingGlobal.push = installChunk;
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/startup chunk dependencies */
/******/ 	(() => {
/******/ 		var next = __webpack_require__.x;
/******/ 		__webpack_require__.x = () => {
/******/ 			return __webpack_require__.e("vendors-node_modules_ton_ton_dist_client_TonClient_js-node_modules_ton_ton_dist_wallets_Walle-18999f").then(next);
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// run startup
/******/ 	var __webpack_exports__ = __webpack_require__.x();
/******/ 	
/******/ })()
;